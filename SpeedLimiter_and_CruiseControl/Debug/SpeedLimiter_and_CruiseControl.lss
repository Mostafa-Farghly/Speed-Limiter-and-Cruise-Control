
SpeedLimiter_and_CruiseControl.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b4  00800100  00005c72  00005d06  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005c72  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a7c  008001b4  008001b4  00005dba  2**0
                  ALLOC
  3 .stab         00007d04  00000000  00000000  00005dbc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003901  00000000  00000000  0000dac0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  000113c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00011501  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00011671  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  000132ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000141a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00014f54  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028e  00000000  00000000  000150b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00015342  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00015b10  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 18 12 	jmp	0x2430	; 0x2430 <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e2 e7       	ldi	r30, 0x72	; 114
      a0:	fc e5       	ldi	r31, 0x5C	; 92
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a4 3b       	cpi	r26, 0xB4	; 180
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	1c e0       	ldi	r17, 0x0C	; 12
      b4:	a4 eb       	ldi	r26, 0xB4	; 180
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a0 33       	cpi	r26, 0x30	; 48
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 40 2b 	call	0x5680	; 0x5680 <main>
      c6:	0c 94 37 2e 	jmp	0x5c6e	; 0x5c6e <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <__fixunssfsi>:
      ce:	ef 92       	push	r14
      d0:	ff 92       	push	r15
      d2:	0f 93       	push	r16
      d4:	1f 93       	push	r17
      d6:	7b 01       	movw	r14, r22
      d8:	8c 01       	movw	r16, r24
      da:	20 e0       	ldi	r18, 0x00	; 0
      dc:	30 e0       	ldi	r19, 0x00	; 0
      de:	40 e0       	ldi	r20, 0x00	; 0
      e0:	5f e4       	ldi	r21, 0x4F	; 79
      e2:	0e 94 67 03 	call	0x6ce	; 0x6ce <__gesf2>
      e6:	88 23       	and	r24, r24
      e8:	8c f0       	brlt	.+34     	; 0x10c <__fixunssfsi+0x3e>
      ea:	c8 01       	movw	r24, r16
      ec:	b7 01       	movw	r22, r14
      ee:	20 e0       	ldi	r18, 0x00	; 0
      f0:	30 e0       	ldi	r19, 0x00	; 0
      f2:	40 e0       	ldi	r20, 0x00	; 0
      f4:	5f e4       	ldi	r21, 0x4F	; 79
      f6:	0e 94 df 01 	call	0x3be	; 0x3be <__subsf3>
      fa:	0e 94 c7 03 	call	0x78e	; 0x78e <__fixsfsi>
      fe:	9b 01       	movw	r18, r22
     100:	ac 01       	movw	r20, r24
     102:	20 50       	subi	r18, 0x00	; 0
     104:	30 40       	sbci	r19, 0x00	; 0
     106:	40 40       	sbci	r20, 0x00	; 0
     108:	50 48       	sbci	r21, 0x80	; 128
     10a:	06 c0       	rjmp	.+12     	; 0x118 <__fixunssfsi+0x4a>
     10c:	c8 01       	movw	r24, r16
     10e:	b7 01       	movw	r22, r14
     110:	0e 94 c7 03 	call	0x78e	; 0x78e <__fixsfsi>
     114:	9b 01       	movw	r18, r22
     116:	ac 01       	movw	r20, r24
     118:	b9 01       	movw	r22, r18
     11a:	ca 01       	movw	r24, r20
     11c:	1f 91       	pop	r17
     11e:	0f 91       	pop	r16
     120:	ff 90       	pop	r15
     122:	ef 90       	pop	r14
     124:	08 95       	ret

00000126 <_fpadd_parts>:
     126:	a0 e0       	ldi	r26, 0x00	; 0
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	e9 e9       	ldi	r30, 0x99	; 153
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	0c 94 b2 2d 	jmp	0x5b64	; 0x5b64 <__prologue_saves__>
     132:	dc 01       	movw	r26, r24
     134:	2b 01       	movw	r4, r22
     136:	fa 01       	movw	r30, r20
     138:	9c 91       	ld	r25, X
     13a:	92 30       	cpi	r25, 0x02	; 2
     13c:	08 f4       	brcc	.+2      	; 0x140 <_fpadd_parts+0x1a>
     13e:	39 c1       	rjmp	.+626    	; 0x3b2 <_fpadd_parts+0x28c>
     140:	eb 01       	movw	r28, r22
     142:	88 81       	ld	r24, Y
     144:	82 30       	cpi	r24, 0x02	; 2
     146:	08 f4       	brcc	.+2      	; 0x14a <_fpadd_parts+0x24>
     148:	33 c1       	rjmp	.+614    	; 0x3b0 <_fpadd_parts+0x28a>
     14a:	94 30       	cpi	r25, 0x04	; 4
     14c:	69 f4       	brne	.+26     	; 0x168 <_fpadd_parts+0x42>
     14e:	84 30       	cpi	r24, 0x04	; 4
     150:	09 f0       	breq	.+2      	; 0x154 <_fpadd_parts+0x2e>
     152:	2f c1       	rjmp	.+606    	; 0x3b2 <_fpadd_parts+0x28c>
     154:	11 96       	adiw	r26, 0x01	; 1
     156:	9c 91       	ld	r25, X
     158:	11 97       	sbiw	r26, 0x01	; 1
     15a:	89 81       	ldd	r24, Y+1	; 0x01
     15c:	98 17       	cp	r25, r24
     15e:	09 f4       	brne	.+2      	; 0x162 <_fpadd_parts+0x3c>
     160:	28 c1       	rjmp	.+592    	; 0x3b2 <_fpadd_parts+0x28c>
     162:	a3 ea       	ldi	r26, 0xA3	; 163
     164:	b1 e0       	ldi	r27, 0x01	; 1
     166:	25 c1       	rjmp	.+586    	; 0x3b2 <_fpadd_parts+0x28c>
     168:	84 30       	cpi	r24, 0x04	; 4
     16a:	09 f4       	brne	.+2      	; 0x16e <_fpadd_parts+0x48>
     16c:	21 c1       	rjmp	.+578    	; 0x3b0 <_fpadd_parts+0x28a>
     16e:	82 30       	cpi	r24, 0x02	; 2
     170:	a9 f4       	brne	.+42     	; 0x19c <_fpadd_parts+0x76>
     172:	92 30       	cpi	r25, 0x02	; 2
     174:	09 f0       	breq	.+2      	; 0x178 <_fpadd_parts+0x52>
     176:	1d c1       	rjmp	.+570    	; 0x3b2 <_fpadd_parts+0x28c>
     178:	9a 01       	movw	r18, r20
     17a:	ad 01       	movw	r20, r26
     17c:	88 e0       	ldi	r24, 0x08	; 8
     17e:	ea 01       	movw	r28, r20
     180:	09 90       	ld	r0, Y+
     182:	ae 01       	movw	r20, r28
     184:	e9 01       	movw	r28, r18
     186:	09 92       	st	Y+, r0
     188:	9e 01       	movw	r18, r28
     18a:	81 50       	subi	r24, 0x01	; 1
     18c:	c1 f7       	brne	.-16     	; 0x17e <_fpadd_parts+0x58>
     18e:	e2 01       	movw	r28, r4
     190:	89 81       	ldd	r24, Y+1	; 0x01
     192:	11 96       	adiw	r26, 0x01	; 1
     194:	9c 91       	ld	r25, X
     196:	89 23       	and	r24, r25
     198:	81 83       	std	Z+1, r24	; 0x01
     19a:	08 c1       	rjmp	.+528    	; 0x3ac <_fpadd_parts+0x286>
     19c:	92 30       	cpi	r25, 0x02	; 2
     19e:	09 f4       	brne	.+2      	; 0x1a2 <_fpadd_parts+0x7c>
     1a0:	07 c1       	rjmp	.+526    	; 0x3b0 <_fpadd_parts+0x28a>
     1a2:	12 96       	adiw	r26, 0x02	; 2
     1a4:	2d 90       	ld	r2, X+
     1a6:	3c 90       	ld	r3, X
     1a8:	13 97       	sbiw	r26, 0x03	; 3
     1aa:	eb 01       	movw	r28, r22
     1ac:	8a 81       	ldd	r24, Y+2	; 0x02
     1ae:	9b 81       	ldd	r25, Y+3	; 0x03
     1b0:	14 96       	adiw	r26, 0x04	; 4
     1b2:	ad 90       	ld	r10, X+
     1b4:	bd 90       	ld	r11, X+
     1b6:	cd 90       	ld	r12, X+
     1b8:	dc 90       	ld	r13, X
     1ba:	17 97       	sbiw	r26, 0x07	; 7
     1bc:	ec 80       	ldd	r14, Y+4	; 0x04
     1be:	fd 80       	ldd	r15, Y+5	; 0x05
     1c0:	0e 81       	ldd	r16, Y+6	; 0x06
     1c2:	1f 81       	ldd	r17, Y+7	; 0x07
     1c4:	91 01       	movw	r18, r2
     1c6:	28 1b       	sub	r18, r24
     1c8:	39 0b       	sbc	r19, r25
     1ca:	b9 01       	movw	r22, r18
     1cc:	37 ff       	sbrs	r19, 7
     1ce:	04 c0       	rjmp	.+8      	; 0x1d8 <_fpadd_parts+0xb2>
     1d0:	66 27       	eor	r22, r22
     1d2:	77 27       	eor	r23, r23
     1d4:	62 1b       	sub	r22, r18
     1d6:	73 0b       	sbc	r23, r19
     1d8:	60 32       	cpi	r22, 0x20	; 32
     1da:	71 05       	cpc	r23, r1
     1dc:	0c f0       	brlt	.+2      	; 0x1e0 <_fpadd_parts+0xba>
     1de:	61 c0       	rjmp	.+194    	; 0x2a2 <_fpadd_parts+0x17c>
     1e0:	12 16       	cp	r1, r18
     1e2:	13 06       	cpc	r1, r19
     1e4:	6c f5       	brge	.+90     	; 0x240 <_fpadd_parts+0x11a>
     1e6:	37 01       	movw	r6, r14
     1e8:	48 01       	movw	r8, r16
     1ea:	06 2e       	mov	r0, r22
     1ec:	04 c0       	rjmp	.+8      	; 0x1f6 <_fpadd_parts+0xd0>
     1ee:	96 94       	lsr	r9
     1f0:	87 94       	ror	r8
     1f2:	77 94       	ror	r7
     1f4:	67 94       	ror	r6
     1f6:	0a 94       	dec	r0
     1f8:	d2 f7       	brpl	.-12     	; 0x1ee <_fpadd_parts+0xc8>
     1fa:	21 e0       	ldi	r18, 0x01	; 1
     1fc:	30 e0       	ldi	r19, 0x00	; 0
     1fe:	40 e0       	ldi	r20, 0x00	; 0
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	04 c0       	rjmp	.+8      	; 0x20c <_fpadd_parts+0xe6>
     204:	22 0f       	add	r18, r18
     206:	33 1f       	adc	r19, r19
     208:	44 1f       	adc	r20, r20
     20a:	55 1f       	adc	r21, r21
     20c:	6a 95       	dec	r22
     20e:	d2 f7       	brpl	.-12     	; 0x204 <_fpadd_parts+0xde>
     210:	21 50       	subi	r18, 0x01	; 1
     212:	30 40       	sbci	r19, 0x00	; 0
     214:	40 40       	sbci	r20, 0x00	; 0
     216:	50 40       	sbci	r21, 0x00	; 0
     218:	2e 21       	and	r18, r14
     21a:	3f 21       	and	r19, r15
     21c:	40 23       	and	r20, r16
     21e:	51 23       	and	r21, r17
     220:	21 15       	cp	r18, r1
     222:	31 05       	cpc	r19, r1
     224:	41 05       	cpc	r20, r1
     226:	51 05       	cpc	r21, r1
     228:	21 f0       	breq	.+8      	; 0x232 <_fpadd_parts+0x10c>
     22a:	21 e0       	ldi	r18, 0x01	; 1
     22c:	30 e0       	ldi	r19, 0x00	; 0
     22e:	40 e0       	ldi	r20, 0x00	; 0
     230:	50 e0       	ldi	r21, 0x00	; 0
     232:	79 01       	movw	r14, r18
     234:	8a 01       	movw	r16, r20
     236:	e6 28       	or	r14, r6
     238:	f7 28       	or	r15, r7
     23a:	08 29       	or	r16, r8
     23c:	19 29       	or	r17, r9
     23e:	3c c0       	rjmp	.+120    	; 0x2b8 <_fpadd_parts+0x192>
     240:	23 2b       	or	r18, r19
     242:	d1 f1       	breq	.+116    	; 0x2b8 <_fpadd_parts+0x192>
     244:	26 0e       	add	r2, r22
     246:	37 1e       	adc	r3, r23
     248:	35 01       	movw	r6, r10
     24a:	46 01       	movw	r8, r12
     24c:	06 2e       	mov	r0, r22
     24e:	04 c0       	rjmp	.+8      	; 0x258 <_fpadd_parts+0x132>
     250:	96 94       	lsr	r9
     252:	87 94       	ror	r8
     254:	77 94       	ror	r7
     256:	67 94       	ror	r6
     258:	0a 94       	dec	r0
     25a:	d2 f7       	brpl	.-12     	; 0x250 <_fpadd_parts+0x12a>
     25c:	21 e0       	ldi	r18, 0x01	; 1
     25e:	30 e0       	ldi	r19, 0x00	; 0
     260:	40 e0       	ldi	r20, 0x00	; 0
     262:	50 e0       	ldi	r21, 0x00	; 0
     264:	04 c0       	rjmp	.+8      	; 0x26e <_fpadd_parts+0x148>
     266:	22 0f       	add	r18, r18
     268:	33 1f       	adc	r19, r19
     26a:	44 1f       	adc	r20, r20
     26c:	55 1f       	adc	r21, r21
     26e:	6a 95       	dec	r22
     270:	d2 f7       	brpl	.-12     	; 0x266 <_fpadd_parts+0x140>
     272:	21 50       	subi	r18, 0x01	; 1
     274:	30 40       	sbci	r19, 0x00	; 0
     276:	40 40       	sbci	r20, 0x00	; 0
     278:	50 40       	sbci	r21, 0x00	; 0
     27a:	2a 21       	and	r18, r10
     27c:	3b 21       	and	r19, r11
     27e:	4c 21       	and	r20, r12
     280:	5d 21       	and	r21, r13
     282:	21 15       	cp	r18, r1
     284:	31 05       	cpc	r19, r1
     286:	41 05       	cpc	r20, r1
     288:	51 05       	cpc	r21, r1
     28a:	21 f0       	breq	.+8      	; 0x294 <_fpadd_parts+0x16e>
     28c:	21 e0       	ldi	r18, 0x01	; 1
     28e:	30 e0       	ldi	r19, 0x00	; 0
     290:	40 e0       	ldi	r20, 0x00	; 0
     292:	50 e0       	ldi	r21, 0x00	; 0
     294:	59 01       	movw	r10, r18
     296:	6a 01       	movw	r12, r20
     298:	a6 28       	or	r10, r6
     29a:	b7 28       	or	r11, r7
     29c:	c8 28       	or	r12, r8
     29e:	d9 28       	or	r13, r9
     2a0:	0b c0       	rjmp	.+22     	; 0x2b8 <_fpadd_parts+0x192>
     2a2:	82 15       	cp	r24, r2
     2a4:	93 05       	cpc	r25, r3
     2a6:	2c f0       	brlt	.+10     	; 0x2b2 <_fpadd_parts+0x18c>
     2a8:	1c 01       	movw	r2, r24
     2aa:	aa 24       	eor	r10, r10
     2ac:	bb 24       	eor	r11, r11
     2ae:	65 01       	movw	r12, r10
     2b0:	03 c0       	rjmp	.+6      	; 0x2b8 <_fpadd_parts+0x192>
     2b2:	ee 24       	eor	r14, r14
     2b4:	ff 24       	eor	r15, r15
     2b6:	87 01       	movw	r16, r14
     2b8:	11 96       	adiw	r26, 0x01	; 1
     2ba:	9c 91       	ld	r25, X
     2bc:	d2 01       	movw	r26, r4
     2be:	11 96       	adiw	r26, 0x01	; 1
     2c0:	8c 91       	ld	r24, X
     2c2:	98 17       	cp	r25, r24
     2c4:	09 f4       	brne	.+2      	; 0x2c8 <_fpadd_parts+0x1a2>
     2c6:	45 c0       	rjmp	.+138    	; 0x352 <_fpadd_parts+0x22c>
     2c8:	99 23       	and	r25, r25
     2ca:	39 f0       	breq	.+14     	; 0x2da <_fpadd_parts+0x1b4>
     2cc:	a8 01       	movw	r20, r16
     2ce:	97 01       	movw	r18, r14
     2d0:	2a 19       	sub	r18, r10
     2d2:	3b 09       	sbc	r19, r11
     2d4:	4c 09       	sbc	r20, r12
     2d6:	5d 09       	sbc	r21, r13
     2d8:	06 c0       	rjmp	.+12     	; 0x2e6 <_fpadd_parts+0x1c0>
     2da:	a6 01       	movw	r20, r12
     2dc:	95 01       	movw	r18, r10
     2de:	2e 19       	sub	r18, r14
     2e0:	3f 09       	sbc	r19, r15
     2e2:	40 0b       	sbc	r20, r16
     2e4:	51 0b       	sbc	r21, r17
     2e6:	57 fd       	sbrc	r21, 7
     2e8:	08 c0       	rjmp	.+16     	; 0x2fa <_fpadd_parts+0x1d4>
     2ea:	11 82       	std	Z+1, r1	; 0x01
     2ec:	33 82       	std	Z+3, r3	; 0x03
     2ee:	22 82       	std	Z+2, r2	; 0x02
     2f0:	24 83       	std	Z+4, r18	; 0x04
     2f2:	35 83       	std	Z+5, r19	; 0x05
     2f4:	46 83       	std	Z+6, r20	; 0x06
     2f6:	57 83       	std	Z+7, r21	; 0x07
     2f8:	1d c0       	rjmp	.+58     	; 0x334 <_fpadd_parts+0x20e>
     2fa:	81 e0       	ldi	r24, 0x01	; 1
     2fc:	81 83       	std	Z+1, r24	; 0x01
     2fe:	33 82       	std	Z+3, r3	; 0x03
     300:	22 82       	std	Z+2, r2	; 0x02
     302:	88 27       	eor	r24, r24
     304:	99 27       	eor	r25, r25
     306:	dc 01       	movw	r26, r24
     308:	82 1b       	sub	r24, r18
     30a:	93 0b       	sbc	r25, r19
     30c:	a4 0b       	sbc	r26, r20
     30e:	b5 0b       	sbc	r27, r21
     310:	84 83       	std	Z+4, r24	; 0x04
     312:	95 83       	std	Z+5, r25	; 0x05
     314:	a6 83       	std	Z+6, r26	; 0x06
     316:	b7 83       	std	Z+7, r27	; 0x07
     318:	0d c0       	rjmp	.+26     	; 0x334 <_fpadd_parts+0x20e>
     31a:	22 0f       	add	r18, r18
     31c:	33 1f       	adc	r19, r19
     31e:	44 1f       	adc	r20, r20
     320:	55 1f       	adc	r21, r21
     322:	24 83       	std	Z+4, r18	; 0x04
     324:	35 83       	std	Z+5, r19	; 0x05
     326:	46 83       	std	Z+6, r20	; 0x06
     328:	57 83       	std	Z+7, r21	; 0x07
     32a:	82 81       	ldd	r24, Z+2	; 0x02
     32c:	93 81       	ldd	r25, Z+3	; 0x03
     32e:	01 97       	sbiw	r24, 0x01	; 1
     330:	93 83       	std	Z+3, r25	; 0x03
     332:	82 83       	std	Z+2, r24	; 0x02
     334:	24 81       	ldd	r18, Z+4	; 0x04
     336:	35 81       	ldd	r19, Z+5	; 0x05
     338:	46 81       	ldd	r20, Z+6	; 0x06
     33a:	57 81       	ldd	r21, Z+7	; 0x07
     33c:	da 01       	movw	r26, r20
     33e:	c9 01       	movw	r24, r18
     340:	01 97       	sbiw	r24, 0x01	; 1
     342:	a1 09       	sbc	r26, r1
     344:	b1 09       	sbc	r27, r1
     346:	8f 5f       	subi	r24, 0xFF	; 255
     348:	9f 4f       	sbci	r25, 0xFF	; 255
     34a:	af 4f       	sbci	r26, 0xFF	; 255
     34c:	bf 43       	sbci	r27, 0x3F	; 63
     34e:	28 f3       	brcs	.-54     	; 0x31a <_fpadd_parts+0x1f4>
     350:	0b c0       	rjmp	.+22     	; 0x368 <_fpadd_parts+0x242>
     352:	91 83       	std	Z+1, r25	; 0x01
     354:	33 82       	std	Z+3, r3	; 0x03
     356:	22 82       	std	Z+2, r2	; 0x02
     358:	ea 0c       	add	r14, r10
     35a:	fb 1c       	adc	r15, r11
     35c:	0c 1d       	adc	r16, r12
     35e:	1d 1d       	adc	r17, r13
     360:	e4 82       	std	Z+4, r14	; 0x04
     362:	f5 82       	std	Z+5, r15	; 0x05
     364:	06 83       	std	Z+6, r16	; 0x06
     366:	17 83       	std	Z+7, r17	; 0x07
     368:	83 e0       	ldi	r24, 0x03	; 3
     36a:	80 83       	st	Z, r24
     36c:	24 81       	ldd	r18, Z+4	; 0x04
     36e:	35 81       	ldd	r19, Z+5	; 0x05
     370:	46 81       	ldd	r20, Z+6	; 0x06
     372:	57 81       	ldd	r21, Z+7	; 0x07
     374:	57 ff       	sbrs	r21, 7
     376:	1a c0       	rjmp	.+52     	; 0x3ac <_fpadd_parts+0x286>
     378:	c9 01       	movw	r24, r18
     37a:	aa 27       	eor	r26, r26
     37c:	97 fd       	sbrc	r25, 7
     37e:	a0 95       	com	r26
     380:	ba 2f       	mov	r27, r26
     382:	81 70       	andi	r24, 0x01	; 1
     384:	90 70       	andi	r25, 0x00	; 0
     386:	a0 70       	andi	r26, 0x00	; 0
     388:	b0 70       	andi	r27, 0x00	; 0
     38a:	56 95       	lsr	r21
     38c:	47 95       	ror	r20
     38e:	37 95       	ror	r19
     390:	27 95       	ror	r18
     392:	82 2b       	or	r24, r18
     394:	93 2b       	or	r25, r19
     396:	a4 2b       	or	r26, r20
     398:	b5 2b       	or	r27, r21
     39a:	84 83       	std	Z+4, r24	; 0x04
     39c:	95 83       	std	Z+5, r25	; 0x05
     39e:	a6 83       	std	Z+6, r26	; 0x06
     3a0:	b7 83       	std	Z+7, r27	; 0x07
     3a2:	82 81       	ldd	r24, Z+2	; 0x02
     3a4:	93 81       	ldd	r25, Z+3	; 0x03
     3a6:	01 96       	adiw	r24, 0x01	; 1
     3a8:	93 83       	std	Z+3, r25	; 0x03
     3aa:	82 83       	std	Z+2, r24	; 0x02
     3ac:	df 01       	movw	r26, r30
     3ae:	01 c0       	rjmp	.+2      	; 0x3b2 <_fpadd_parts+0x28c>
     3b0:	d2 01       	movw	r26, r4
     3b2:	cd 01       	movw	r24, r26
     3b4:	cd b7       	in	r28, 0x3d	; 61
     3b6:	de b7       	in	r29, 0x3e	; 62
     3b8:	e2 e1       	ldi	r30, 0x12	; 18
     3ba:	0c 94 ce 2d 	jmp	0x5b9c	; 0x5b9c <__epilogue_restores__>

000003be <__subsf3>:
     3be:	a0 e2       	ldi	r26, 0x20	; 32
     3c0:	b0 e0       	ldi	r27, 0x00	; 0
     3c2:	e5 ee       	ldi	r30, 0xE5	; 229
     3c4:	f1 e0       	ldi	r31, 0x01	; 1
     3c6:	0c 94 be 2d 	jmp	0x5b7c	; 0x5b7c <__prologue_saves__+0x18>
     3ca:	69 83       	std	Y+1, r22	; 0x01
     3cc:	7a 83       	std	Y+2, r23	; 0x02
     3ce:	8b 83       	std	Y+3, r24	; 0x03
     3d0:	9c 83       	std	Y+4, r25	; 0x04
     3d2:	2d 83       	std	Y+5, r18	; 0x05
     3d4:	3e 83       	std	Y+6, r19	; 0x06
     3d6:	4f 83       	std	Y+7, r20	; 0x07
     3d8:	58 87       	std	Y+8, r21	; 0x08
     3da:	e9 e0       	ldi	r30, 0x09	; 9
     3dc:	ee 2e       	mov	r14, r30
     3de:	f1 2c       	mov	r15, r1
     3e0:	ec 0e       	add	r14, r28
     3e2:	fd 1e       	adc	r15, r29
     3e4:	ce 01       	movw	r24, r28
     3e6:	01 96       	adiw	r24, 0x01	; 1
     3e8:	b7 01       	movw	r22, r14
     3ea:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     3ee:	8e 01       	movw	r16, r28
     3f0:	0f 5e       	subi	r16, 0xEF	; 239
     3f2:	1f 4f       	sbci	r17, 0xFF	; 255
     3f4:	ce 01       	movw	r24, r28
     3f6:	05 96       	adiw	r24, 0x05	; 5
     3f8:	b8 01       	movw	r22, r16
     3fa:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     3fe:	8a 89       	ldd	r24, Y+18	; 0x12
     400:	91 e0       	ldi	r25, 0x01	; 1
     402:	89 27       	eor	r24, r25
     404:	8a 8b       	std	Y+18, r24	; 0x12
     406:	c7 01       	movw	r24, r14
     408:	b8 01       	movw	r22, r16
     40a:	ae 01       	movw	r20, r28
     40c:	47 5e       	subi	r20, 0xE7	; 231
     40e:	5f 4f       	sbci	r21, 0xFF	; 255
     410:	0e 94 93 00 	call	0x126	; 0x126 <_fpadd_parts>
     414:	0e 94 1b 04 	call	0x836	; 0x836 <__pack_f>
     418:	a0 96       	adiw	r28, 0x20	; 32
     41a:	e6 e0       	ldi	r30, 0x06	; 6
     41c:	0c 94 da 2d 	jmp	0x5bb4	; 0x5bb4 <__epilogue_restores__+0x18>

00000420 <__addsf3>:
     420:	a0 e2       	ldi	r26, 0x20	; 32
     422:	b0 e0       	ldi	r27, 0x00	; 0
     424:	e6 e1       	ldi	r30, 0x16	; 22
     426:	f2 e0       	ldi	r31, 0x02	; 2
     428:	0c 94 be 2d 	jmp	0x5b7c	; 0x5b7c <__prologue_saves__+0x18>
     42c:	69 83       	std	Y+1, r22	; 0x01
     42e:	7a 83       	std	Y+2, r23	; 0x02
     430:	8b 83       	std	Y+3, r24	; 0x03
     432:	9c 83       	std	Y+4, r25	; 0x04
     434:	2d 83       	std	Y+5, r18	; 0x05
     436:	3e 83       	std	Y+6, r19	; 0x06
     438:	4f 83       	std	Y+7, r20	; 0x07
     43a:	58 87       	std	Y+8, r21	; 0x08
     43c:	f9 e0       	ldi	r31, 0x09	; 9
     43e:	ef 2e       	mov	r14, r31
     440:	f1 2c       	mov	r15, r1
     442:	ec 0e       	add	r14, r28
     444:	fd 1e       	adc	r15, r29
     446:	ce 01       	movw	r24, r28
     448:	01 96       	adiw	r24, 0x01	; 1
     44a:	b7 01       	movw	r22, r14
     44c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     450:	8e 01       	movw	r16, r28
     452:	0f 5e       	subi	r16, 0xEF	; 239
     454:	1f 4f       	sbci	r17, 0xFF	; 255
     456:	ce 01       	movw	r24, r28
     458:	05 96       	adiw	r24, 0x05	; 5
     45a:	b8 01       	movw	r22, r16
     45c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     460:	c7 01       	movw	r24, r14
     462:	b8 01       	movw	r22, r16
     464:	ae 01       	movw	r20, r28
     466:	47 5e       	subi	r20, 0xE7	; 231
     468:	5f 4f       	sbci	r21, 0xFF	; 255
     46a:	0e 94 93 00 	call	0x126	; 0x126 <_fpadd_parts>
     46e:	0e 94 1b 04 	call	0x836	; 0x836 <__pack_f>
     472:	a0 96       	adiw	r28, 0x20	; 32
     474:	e6 e0       	ldi	r30, 0x06	; 6
     476:	0c 94 da 2d 	jmp	0x5bb4	; 0x5bb4 <__epilogue_restores__+0x18>

0000047a <__mulsf3>:
     47a:	a0 e2       	ldi	r26, 0x20	; 32
     47c:	b0 e0       	ldi	r27, 0x00	; 0
     47e:	e3 e4       	ldi	r30, 0x43	; 67
     480:	f2 e0       	ldi	r31, 0x02	; 2
     482:	0c 94 b2 2d 	jmp	0x5b64	; 0x5b64 <__prologue_saves__>
     486:	69 83       	std	Y+1, r22	; 0x01
     488:	7a 83       	std	Y+2, r23	; 0x02
     48a:	8b 83       	std	Y+3, r24	; 0x03
     48c:	9c 83       	std	Y+4, r25	; 0x04
     48e:	2d 83       	std	Y+5, r18	; 0x05
     490:	3e 83       	std	Y+6, r19	; 0x06
     492:	4f 83       	std	Y+7, r20	; 0x07
     494:	58 87       	std	Y+8, r21	; 0x08
     496:	ce 01       	movw	r24, r28
     498:	01 96       	adiw	r24, 0x01	; 1
     49a:	be 01       	movw	r22, r28
     49c:	67 5f       	subi	r22, 0xF7	; 247
     49e:	7f 4f       	sbci	r23, 0xFF	; 255
     4a0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     4a4:	ce 01       	movw	r24, r28
     4a6:	05 96       	adiw	r24, 0x05	; 5
     4a8:	be 01       	movw	r22, r28
     4aa:	6f 5e       	subi	r22, 0xEF	; 239
     4ac:	7f 4f       	sbci	r23, 0xFF	; 255
     4ae:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     4b2:	99 85       	ldd	r25, Y+9	; 0x09
     4b4:	92 30       	cpi	r25, 0x02	; 2
     4b6:	88 f0       	brcs	.+34     	; 0x4da <__mulsf3+0x60>
     4b8:	89 89       	ldd	r24, Y+17	; 0x11
     4ba:	82 30       	cpi	r24, 0x02	; 2
     4bc:	c8 f0       	brcs	.+50     	; 0x4f0 <__mulsf3+0x76>
     4be:	94 30       	cpi	r25, 0x04	; 4
     4c0:	19 f4       	brne	.+6      	; 0x4c8 <__mulsf3+0x4e>
     4c2:	82 30       	cpi	r24, 0x02	; 2
     4c4:	51 f4       	brne	.+20     	; 0x4da <__mulsf3+0x60>
     4c6:	04 c0       	rjmp	.+8      	; 0x4d0 <__mulsf3+0x56>
     4c8:	84 30       	cpi	r24, 0x04	; 4
     4ca:	29 f4       	brne	.+10     	; 0x4d6 <__mulsf3+0x5c>
     4cc:	92 30       	cpi	r25, 0x02	; 2
     4ce:	81 f4       	brne	.+32     	; 0x4f0 <__mulsf3+0x76>
     4d0:	83 ea       	ldi	r24, 0xA3	; 163
     4d2:	91 e0       	ldi	r25, 0x01	; 1
     4d4:	c6 c0       	rjmp	.+396    	; 0x662 <__mulsf3+0x1e8>
     4d6:	92 30       	cpi	r25, 0x02	; 2
     4d8:	49 f4       	brne	.+18     	; 0x4ec <__mulsf3+0x72>
     4da:	20 e0       	ldi	r18, 0x00	; 0
     4dc:	9a 85       	ldd	r25, Y+10	; 0x0a
     4de:	8a 89       	ldd	r24, Y+18	; 0x12
     4e0:	98 13       	cpse	r25, r24
     4e2:	21 e0       	ldi	r18, 0x01	; 1
     4e4:	2a 87       	std	Y+10, r18	; 0x0a
     4e6:	ce 01       	movw	r24, r28
     4e8:	09 96       	adiw	r24, 0x09	; 9
     4ea:	bb c0       	rjmp	.+374    	; 0x662 <__mulsf3+0x1e8>
     4ec:	82 30       	cpi	r24, 0x02	; 2
     4ee:	49 f4       	brne	.+18     	; 0x502 <__mulsf3+0x88>
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	9a 85       	ldd	r25, Y+10	; 0x0a
     4f4:	8a 89       	ldd	r24, Y+18	; 0x12
     4f6:	98 13       	cpse	r25, r24
     4f8:	21 e0       	ldi	r18, 0x01	; 1
     4fa:	2a 8b       	std	Y+18, r18	; 0x12
     4fc:	ce 01       	movw	r24, r28
     4fe:	41 96       	adiw	r24, 0x11	; 17
     500:	b0 c0       	rjmp	.+352    	; 0x662 <__mulsf3+0x1e8>
     502:	2d 84       	ldd	r2, Y+13	; 0x0d
     504:	3e 84       	ldd	r3, Y+14	; 0x0e
     506:	4f 84       	ldd	r4, Y+15	; 0x0f
     508:	58 88       	ldd	r5, Y+16	; 0x10
     50a:	6d 88       	ldd	r6, Y+21	; 0x15
     50c:	7e 88       	ldd	r7, Y+22	; 0x16
     50e:	8f 88       	ldd	r8, Y+23	; 0x17
     510:	98 8c       	ldd	r9, Y+24	; 0x18
     512:	ee 24       	eor	r14, r14
     514:	ff 24       	eor	r15, r15
     516:	87 01       	movw	r16, r14
     518:	aa 24       	eor	r10, r10
     51a:	bb 24       	eor	r11, r11
     51c:	65 01       	movw	r12, r10
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	50 e0       	ldi	r21, 0x00	; 0
     522:	60 e0       	ldi	r22, 0x00	; 0
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	e0 e0       	ldi	r30, 0x00	; 0
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	c1 01       	movw	r24, r2
     52c:	81 70       	andi	r24, 0x01	; 1
     52e:	90 70       	andi	r25, 0x00	; 0
     530:	89 2b       	or	r24, r25
     532:	e9 f0       	breq	.+58     	; 0x56e <__mulsf3+0xf4>
     534:	e6 0c       	add	r14, r6
     536:	f7 1c       	adc	r15, r7
     538:	08 1d       	adc	r16, r8
     53a:	19 1d       	adc	r17, r9
     53c:	9a 01       	movw	r18, r20
     53e:	ab 01       	movw	r20, r22
     540:	2a 0d       	add	r18, r10
     542:	3b 1d       	adc	r19, r11
     544:	4c 1d       	adc	r20, r12
     546:	5d 1d       	adc	r21, r13
     548:	80 e0       	ldi	r24, 0x00	; 0
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	a0 e0       	ldi	r26, 0x00	; 0
     54e:	b0 e0       	ldi	r27, 0x00	; 0
     550:	e6 14       	cp	r14, r6
     552:	f7 04       	cpc	r15, r7
     554:	08 05       	cpc	r16, r8
     556:	19 05       	cpc	r17, r9
     558:	20 f4       	brcc	.+8      	; 0x562 <__mulsf3+0xe8>
     55a:	81 e0       	ldi	r24, 0x01	; 1
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	a0 e0       	ldi	r26, 0x00	; 0
     560:	b0 e0       	ldi	r27, 0x00	; 0
     562:	ba 01       	movw	r22, r20
     564:	a9 01       	movw	r20, r18
     566:	48 0f       	add	r20, r24
     568:	59 1f       	adc	r21, r25
     56a:	6a 1f       	adc	r22, r26
     56c:	7b 1f       	adc	r23, r27
     56e:	aa 0c       	add	r10, r10
     570:	bb 1c       	adc	r11, r11
     572:	cc 1c       	adc	r12, r12
     574:	dd 1c       	adc	r13, r13
     576:	97 fe       	sbrs	r9, 7
     578:	08 c0       	rjmp	.+16     	; 0x58a <__mulsf3+0x110>
     57a:	81 e0       	ldi	r24, 0x01	; 1
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	a0 e0       	ldi	r26, 0x00	; 0
     580:	b0 e0       	ldi	r27, 0x00	; 0
     582:	a8 2a       	or	r10, r24
     584:	b9 2a       	or	r11, r25
     586:	ca 2a       	or	r12, r26
     588:	db 2a       	or	r13, r27
     58a:	31 96       	adiw	r30, 0x01	; 1
     58c:	e0 32       	cpi	r30, 0x20	; 32
     58e:	f1 05       	cpc	r31, r1
     590:	49 f0       	breq	.+18     	; 0x5a4 <__mulsf3+0x12a>
     592:	66 0c       	add	r6, r6
     594:	77 1c       	adc	r7, r7
     596:	88 1c       	adc	r8, r8
     598:	99 1c       	adc	r9, r9
     59a:	56 94       	lsr	r5
     59c:	47 94       	ror	r4
     59e:	37 94       	ror	r3
     5a0:	27 94       	ror	r2
     5a2:	c3 cf       	rjmp	.-122    	; 0x52a <__mulsf3+0xb0>
     5a4:	fa 85       	ldd	r31, Y+10	; 0x0a
     5a6:	ea 89       	ldd	r30, Y+18	; 0x12
     5a8:	2b 89       	ldd	r18, Y+19	; 0x13
     5aa:	3c 89       	ldd	r19, Y+20	; 0x14
     5ac:	8b 85       	ldd	r24, Y+11	; 0x0b
     5ae:	9c 85       	ldd	r25, Y+12	; 0x0c
     5b0:	28 0f       	add	r18, r24
     5b2:	39 1f       	adc	r19, r25
     5b4:	2e 5f       	subi	r18, 0xFE	; 254
     5b6:	3f 4f       	sbci	r19, 0xFF	; 255
     5b8:	17 c0       	rjmp	.+46     	; 0x5e8 <__mulsf3+0x16e>
     5ba:	ca 01       	movw	r24, r20
     5bc:	81 70       	andi	r24, 0x01	; 1
     5be:	90 70       	andi	r25, 0x00	; 0
     5c0:	89 2b       	or	r24, r25
     5c2:	61 f0       	breq	.+24     	; 0x5dc <__mulsf3+0x162>
     5c4:	16 95       	lsr	r17
     5c6:	07 95       	ror	r16
     5c8:	f7 94       	ror	r15
     5ca:	e7 94       	ror	r14
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	a0 e0       	ldi	r26, 0x00	; 0
     5d2:	b0 e8       	ldi	r27, 0x80	; 128
     5d4:	e8 2a       	or	r14, r24
     5d6:	f9 2a       	or	r15, r25
     5d8:	0a 2b       	or	r16, r26
     5da:	1b 2b       	or	r17, r27
     5dc:	76 95       	lsr	r23
     5de:	67 95       	ror	r22
     5e0:	57 95       	ror	r21
     5e2:	47 95       	ror	r20
     5e4:	2f 5f       	subi	r18, 0xFF	; 255
     5e6:	3f 4f       	sbci	r19, 0xFF	; 255
     5e8:	77 fd       	sbrc	r23, 7
     5ea:	e7 cf       	rjmp	.-50     	; 0x5ba <__mulsf3+0x140>
     5ec:	0c c0       	rjmp	.+24     	; 0x606 <__mulsf3+0x18c>
     5ee:	44 0f       	add	r20, r20
     5f0:	55 1f       	adc	r21, r21
     5f2:	66 1f       	adc	r22, r22
     5f4:	77 1f       	adc	r23, r23
     5f6:	17 fd       	sbrc	r17, 7
     5f8:	41 60       	ori	r20, 0x01	; 1
     5fa:	ee 0c       	add	r14, r14
     5fc:	ff 1c       	adc	r15, r15
     5fe:	00 1f       	adc	r16, r16
     600:	11 1f       	adc	r17, r17
     602:	21 50       	subi	r18, 0x01	; 1
     604:	30 40       	sbci	r19, 0x00	; 0
     606:	40 30       	cpi	r20, 0x00	; 0
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	59 07       	cpc	r21, r25
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	69 07       	cpc	r22, r25
     610:	90 e4       	ldi	r25, 0x40	; 64
     612:	79 07       	cpc	r23, r25
     614:	60 f3       	brcs	.-40     	; 0x5ee <__mulsf3+0x174>
     616:	2b 8f       	std	Y+27, r18	; 0x1b
     618:	3c 8f       	std	Y+28, r19	; 0x1c
     61a:	db 01       	movw	r26, r22
     61c:	ca 01       	movw	r24, r20
     61e:	8f 77       	andi	r24, 0x7F	; 127
     620:	90 70       	andi	r25, 0x00	; 0
     622:	a0 70       	andi	r26, 0x00	; 0
     624:	b0 70       	andi	r27, 0x00	; 0
     626:	80 34       	cpi	r24, 0x40	; 64
     628:	91 05       	cpc	r25, r1
     62a:	a1 05       	cpc	r26, r1
     62c:	b1 05       	cpc	r27, r1
     62e:	61 f4       	brne	.+24     	; 0x648 <__mulsf3+0x1ce>
     630:	47 fd       	sbrc	r20, 7
     632:	0a c0       	rjmp	.+20     	; 0x648 <__mulsf3+0x1ce>
     634:	e1 14       	cp	r14, r1
     636:	f1 04       	cpc	r15, r1
     638:	01 05       	cpc	r16, r1
     63a:	11 05       	cpc	r17, r1
     63c:	29 f0       	breq	.+10     	; 0x648 <__mulsf3+0x1ce>
     63e:	40 5c       	subi	r20, 0xC0	; 192
     640:	5f 4f       	sbci	r21, 0xFF	; 255
     642:	6f 4f       	sbci	r22, 0xFF	; 255
     644:	7f 4f       	sbci	r23, 0xFF	; 255
     646:	40 78       	andi	r20, 0x80	; 128
     648:	1a 8e       	std	Y+26, r1	; 0x1a
     64a:	fe 17       	cp	r31, r30
     64c:	11 f0       	breq	.+4      	; 0x652 <__mulsf3+0x1d8>
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	8a 8f       	std	Y+26, r24	; 0x1a
     652:	4d 8f       	std	Y+29, r20	; 0x1d
     654:	5e 8f       	std	Y+30, r21	; 0x1e
     656:	6f 8f       	std	Y+31, r22	; 0x1f
     658:	78 a3       	std	Y+32, r23	; 0x20
     65a:	83 e0       	ldi	r24, 0x03	; 3
     65c:	89 8f       	std	Y+25, r24	; 0x19
     65e:	ce 01       	movw	r24, r28
     660:	49 96       	adiw	r24, 0x19	; 25
     662:	0e 94 1b 04 	call	0x836	; 0x836 <__pack_f>
     666:	a0 96       	adiw	r28, 0x20	; 32
     668:	e2 e1       	ldi	r30, 0x12	; 18
     66a:	0c 94 ce 2d 	jmp	0x5b9c	; 0x5b9c <__epilogue_restores__>

0000066e <__gtsf2>:
     66e:	a8 e1       	ldi	r26, 0x18	; 24
     670:	b0 e0       	ldi	r27, 0x00	; 0
     672:	ed e3       	ldi	r30, 0x3D	; 61
     674:	f3 e0       	ldi	r31, 0x03	; 3
     676:	0c 94 be 2d 	jmp	0x5b7c	; 0x5b7c <__prologue_saves__+0x18>
     67a:	69 83       	std	Y+1, r22	; 0x01
     67c:	7a 83       	std	Y+2, r23	; 0x02
     67e:	8b 83       	std	Y+3, r24	; 0x03
     680:	9c 83       	std	Y+4, r25	; 0x04
     682:	2d 83       	std	Y+5, r18	; 0x05
     684:	3e 83       	std	Y+6, r19	; 0x06
     686:	4f 83       	std	Y+7, r20	; 0x07
     688:	58 87       	std	Y+8, r21	; 0x08
     68a:	89 e0       	ldi	r24, 0x09	; 9
     68c:	e8 2e       	mov	r14, r24
     68e:	f1 2c       	mov	r15, r1
     690:	ec 0e       	add	r14, r28
     692:	fd 1e       	adc	r15, r29
     694:	ce 01       	movw	r24, r28
     696:	01 96       	adiw	r24, 0x01	; 1
     698:	b7 01       	movw	r22, r14
     69a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     69e:	8e 01       	movw	r16, r28
     6a0:	0f 5e       	subi	r16, 0xEF	; 239
     6a2:	1f 4f       	sbci	r17, 0xFF	; 255
     6a4:	ce 01       	movw	r24, r28
     6a6:	05 96       	adiw	r24, 0x05	; 5
     6a8:	b8 01       	movw	r22, r16
     6aa:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     6ae:	89 85       	ldd	r24, Y+9	; 0x09
     6b0:	82 30       	cpi	r24, 0x02	; 2
     6b2:	40 f0       	brcs	.+16     	; 0x6c4 <__gtsf2+0x56>
     6b4:	89 89       	ldd	r24, Y+17	; 0x11
     6b6:	82 30       	cpi	r24, 0x02	; 2
     6b8:	28 f0       	brcs	.+10     	; 0x6c4 <__gtsf2+0x56>
     6ba:	c7 01       	movw	r24, r14
     6bc:	b8 01       	movw	r22, r16
     6be:	0e 94 68 05 	call	0xad0	; 0xad0 <__fpcmp_parts_f>
     6c2:	01 c0       	rjmp	.+2      	; 0x6c6 <__gtsf2+0x58>
     6c4:	8f ef       	ldi	r24, 0xFF	; 255
     6c6:	68 96       	adiw	r28, 0x18	; 24
     6c8:	e6 e0       	ldi	r30, 0x06	; 6
     6ca:	0c 94 da 2d 	jmp	0x5bb4	; 0x5bb4 <__epilogue_restores__+0x18>

000006ce <__gesf2>:
     6ce:	a8 e1       	ldi	r26, 0x18	; 24
     6d0:	b0 e0       	ldi	r27, 0x00	; 0
     6d2:	ed e6       	ldi	r30, 0x6D	; 109
     6d4:	f3 e0       	ldi	r31, 0x03	; 3
     6d6:	0c 94 be 2d 	jmp	0x5b7c	; 0x5b7c <__prologue_saves__+0x18>
     6da:	69 83       	std	Y+1, r22	; 0x01
     6dc:	7a 83       	std	Y+2, r23	; 0x02
     6de:	8b 83       	std	Y+3, r24	; 0x03
     6e0:	9c 83       	std	Y+4, r25	; 0x04
     6e2:	2d 83       	std	Y+5, r18	; 0x05
     6e4:	3e 83       	std	Y+6, r19	; 0x06
     6e6:	4f 83       	std	Y+7, r20	; 0x07
     6e8:	58 87       	std	Y+8, r21	; 0x08
     6ea:	89 e0       	ldi	r24, 0x09	; 9
     6ec:	e8 2e       	mov	r14, r24
     6ee:	f1 2c       	mov	r15, r1
     6f0:	ec 0e       	add	r14, r28
     6f2:	fd 1e       	adc	r15, r29
     6f4:	ce 01       	movw	r24, r28
     6f6:	01 96       	adiw	r24, 0x01	; 1
     6f8:	b7 01       	movw	r22, r14
     6fa:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     6fe:	8e 01       	movw	r16, r28
     700:	0f 5e       	subi	r16, 0xEF	; 239
     702:	1f 4f       	sbci	r17, 0xFF	; 255
     704:	ce 01       	movw	r24, r28
     706:	05 96       	adiw	r24, 0x05	; 5
     708:	b8 01       	movw	r22, r16
     70a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     70e:	89 85       	ldd	r24, Y+9	; 0x09
     710:	82 30       	cpi	r24, 0x02	; 2
     712:	40 f0       	brcs	.+16     	; 0x724 <__gesf2+0x56>
     714:	89 89       	ldd	r24, Y+17	; 0x11
     716:	82 30       	cpi	r24, 0x02	; 2
     718:	28 f0       	brcs	.+10     	; 0x724 <__gesf2+0x56>
     71a:	c7 01       	movw	r24, r14
     71c:	b8 01       	movw	r22, r16
     71e:	0e 94 68 05 	call	0xad0	; 0xad0 <__fpcmp_parts_f>
     722:	01 c0       	rjmp	.+2      	; 0x726 <__gesf2+0x58>
     724:	8f ef       	ldi	r24, 0xFF	; 255
     726:	68 96       	adiw	r28, 0x18	; 24
     728:	e6 e0       	ldi	r30, 0x06	; 6
     72a:	0c 94 da 2d 	jmp	0x5bb4	; 0x5bb4 <__epilogue_restores__+0x18>

0000072e <__ltsf2>:
     72e:	a8 e1       	ldi	r26, 0x18	; 24
     730:	b0 e0       	ldi	r27, 0x00	; 0
     732:	ed e9       	ldi	r30, 0x9D	; 157
     734:	f3 e0       	ldi	r31, 0x03	; 3
     736:	0c 94 be 2d 	jmp	0x5b7c	; 0x5b7c <__prologue_saves__+0x18>
     73a:	69 83       	std	Y+1, r22	; 0x01
     73c:	7a 83       	std	Y+2, r23	; 0x02
     73e:	8b 83       	std	Y+3, r24	; 0x03
     740:	9c 83       	std	Y+4, r25	; 0x04
     742:	2d 83       	std	Y+5, r18	; 0x05
     744:	3e 83       	std	Y+6, r19	; 0x06
     746:	4f 83       	std	Y+7, r20	; 0x07
     748:	58 87       	std	Y+8, r21	; 0x08
     74a:	89 e0       	ldi	r24, 0x09	; 9
     74c:	e8 2e       	mov	r14, r24
     74e:	f1 2c       	mov	r15, r1
     750:	ec 0e       	add	r14, r28
     752:	fd 1e       	adc	r15, r29
     754:	ce 01       	movw	r24, r28
     756:	01 96       	adiw	r24, 0x01	; 1
     758:	b7 01       	movw	r22, r14
     75a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     75e:	8e 01       	movw	r16, r28
     760:	0f 5e       	subi	r16, 0xEF	; 239
     762:	1f 4f       	sbci	r17, 0xFF	; 255
     764:	ce 01       	movw	r24, r28
     766:	05 96       	adiw	r24, 0x05	; 5
     768:	b8 01       	movw	r22, r16
     76a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     76e:	89 85       	ldd	r24, Y+9	; 0x09
     770:	82 30       	cpi	r24, 0x02	; 2
     772:	40 f0       	brcs	.+16     	; 0x784 <__ltsf2+0x56>
     774:	89 89       	ldd	r24, Y+17	; 0x11
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	28 f0       	brcs	.+10     	; 0x784 <__ltsf2+0x56>
     77a:	c7 01       	movw	r24, r14
     77c:	b8 01       	movw	r22, r16
     77e:	0e 94 68 05 	call	0xad0	; 0xad0 <__fpcmp_parts_f>
     782:	01 c0       	rjmp	.+2      	; 0x786 <__ltsf2+0x58>
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	68 96       	adiw	r28, 0x18	; 24
     788:	e6 e0       	ldi	r30, 0x06	; 6
     78a:	0c 94 da 2d 	jmp	0x5bb4	; 0x5bb4 <__epilogue_restores__+0x18>

0000078e <__fixsfsi>:
     78e:	ac e0       	ldi	r26, 0x0C	; 12
     790:	b0 e0       	ldi	r27, 0x00	; 0
     792:	ed ec       	ldi	r30, 0xCD	; 205
     794:	f3 e0       	ldi	r31, 0x03	; 3
     796:	0c 94 c2 2d 	jmp	0x5b84	; 0x5b84 <__prologue_saves__+0x20>
     79a:	69 83       	std	Y+1, r22	; 0x01
     79c:	7a 83       	std	Y+2, r23	; 0x02
     79e:	8b 83       	std	Y+3, r24	; 0x03
     7a0:	9c 83       	std	Y+4, r25	; 0x04
     7a2:	ce 01       	movw	r24, r28
     7a4:	01 96       	adiw	r24, 0x01	; 1
     7a6:	be 01       	movw	r22, r28
     7a8:	6b 5f       	subi	r22, 0xFB	; 251
     7aa:	7f 4f       	sbci	r23, 0xFF	; 255
     7ac:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     7b0:	8d 81       	ldd	r24, Y+5	; 0x05
     7b2:	82 30       	cpi	r24, 0x02	; 2
     7b4:	61 f1       	breq	.+88     	; 0x80e <__fixsfsi+0x80>
     7b6:	82 30       	cpi	r24, 0x02	; 2
     7b8:	50 f1       	brcs	.+84     	; 0x80e <__fixsfsi+0x80>
     7ba:	84 30       	cpi	r24, 0x04	; 4
     7bc:	21 f4       	brne	.+8      	; 0x7c6 <__fixsfsi+0x38>
     7be:	8e 81       	ldd	r24, Y+6	; 0x06
     7c0:	88 23       	and	r24, r24
     7c2:	51 f1       	breq	.+84     	; 0x818 <__fixsfsi+0x8a>
     7c4:	2e c0       	rjmp	.+92     	; 0x822 <__fixsfsi+0x94>
     7c6:	2f 81       	ldd	r18, Y+7	; 0x07
     7c8:	38 85       	ldd	r19, Y+8	; 0x08
     7ca:	37 fd       	sbrc	r19, 7
     7cc:	20 c0       	rjmp	.+64     	; 0x80e <__fixsfsi+0x80>
     7ce:	6e 81       	ldd	r22, Y+6	; 0x06
     7d0:	2f 31       	cpi	r18, 0x1F	; 31
     7d2:	31 05       	cpc	r19, r1
     7d4:	1c f0       	brlt	.+6      	; 0x7dc <__fixsfsi+0x4e>
     7d6:	66 23       	and	r22, r22
     7d8:	f9 f0       	breq	.+62     	; 0x818 <__fixsfsi+0x8a>
     7da:	23 c0       	rjmp	.+70     	; 0x822 <__fixsfsi+0x94>
     7dc:	8e e1       	ldi	r24, 0x1E	; 30
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	82 1b       	sub	r24, r18
     7e2:	93 0b       	sbc	r25, r19
     7e4:	29 85       	ldd	r18, Y+9	; 0x09
     7e6:	3a 85       	ldd	r19, Y+10	; 0x0a
     7e8:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ea:	5c 85       	ldd	r21, Y+12	; 0x0c
     7ec:	04 c0       	rjmp	.+8      	; 0x7f6 <__fixsfsi+0x68>
     7ee:	56 95       	lsr	r21
     7f0:	47 95       	ror	r20
     7f2:	37 95       	ror	r19
     7f4:	27 95       	ror	r18
     7f6:	8a 95       	dec	r24
     7f8:	d2 f7       	brpl	.-12     	; 0x7ee <__fixsfsi+0x60>
     7fa:	66 23       	and	r22, r22
     7fc:	b1 f0       	breq	.+44     	; 0x82a <__fixsfsi+0x9c>
     7fe:	50 95       	com	r21
     800:	40 95       	com	r20
     802:	30 95       	com	r19
     804:	21 95       	neg	r18
     806:	3f 4f       	sbci	r19, 0xFF	; 255
     808:	4f 4f       	sbci	r20, 0xFF	; 255
     80a:	5f 4f       	sbci	r21, 0xFF	; 255
     80c:	0e c0       	rjmp	.+28     	; 0x82a <__fixsfsi+0x9c>
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	30 e0       	ldi	r19, 0x00	; 0
     812:	40 e0       	ldi	r20, 0x00	; 0
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	09 c0       	rjmp	.+18     	; 0x82a <__fixsfsi+0x9c>
     818:	2f ef       	ldi	r18, 0xFF	; 255
     81a:	3f ef       	ldi	r19, 0xFF	; 255
     81c:	4f ef       	ldi	r20, 0xFF	; 255
     81e:	5f e7       	ldi	r21, 0x7F	; 127
     820:	04 c0       	rjmp	.+8      	; 0x82a <__fixsfsi+0x9c>
     822:	20 e0       	ldi	r18, 0x00	; 0
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	40 e0       	ldi	r20, 0x00	; 0
     828:	50 e8       	ldi	r21, 0x80	; 128
     82a:	b9 01       	movw	r22, r18
     82c:	ca 01       	movw	r24, r20
     82e:	2c 96       	adiw	r28, 0x0c	; 12
     830:	e2 e0       	ldi	r30, 0x02	; 2
     832:	0c 94 de 2d 	jmp	0x5bbc	; 0x5bbc <__epilogue_restores__+0x20>

00000836 <__pack_f>:
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	fc 01       	movw	r30, r24
     842:	e4 80       	ldd	r14, Z+4	; 0x04
     844:	f5 80       	ldd	r15, Z+5	; 0x05
     846:	06 81       	ldd	r16, Z+6	; 0x06
     848:	17 81       	ldd	r17, Z+7	; 0x07
     84a:	d1 80       	ldd	r13, Z+1	; 0x01
     84c:	80 81       	ld	r24, Z
     84e:	82 30       	cpi	r24, 0x02	; 2
     850:	48 f4       	brcc	.+18     	; 0x864 <__pack_f+0x2e>
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	a0 e1       	ldi	r26, 0x10	; 16
     858:	b0 e0       	ldi	r27, 0x00	; 0
     85a:	e8 2a       	or	r14, r24
     85c:	f9 2a       	or	r15, r25
     85e:	0a 2b       	or	r16, r26
     860:	1b 2b       	or	r17, r27
     862:	a5 c0       	rjmp	.+330    	; 0x9ae <__pack_f+0x178>
     864:	84 30       	cpi	r24, 0x04	; 4
     866:	09 f4       	brne	.+2      	; 0x86a <__pack_f+0x34>
     868:	9f c0       	rjmp	.+318    	; 0x9a8 <__pack_f+0x172>
     86a:	82 30       	cpi	r24, 0x02	; 2
     86c:	21 f4       	brne	.+8      	; 0x876 <__pack_f+0x40>
     86e:	ee 24       	eor	r14, r14
     870:	ff 24       	eor	r15, r15
     872:	87 01       	movw	r16, r14
     874:	05 c0       	rjmp	.+10     	; 0x880 <__pack_f+0x4a>
     876:	e1 14       	cp	r14, r1
     878:	f1 04       	cpc	r15, r1
     87a:	01 05       	cpc	r16, r1
     87c:	11 05       	cpc	r17, r1
     87e:	19 f4       	brne	.+6      	; 0x886 <__pack_f+0x50>
     880:	e0 e0       	ldi	r30, 0x00	; 0
     882:	f0 e0       	ldi	r31, 0x00	; 0
     884:	96 c0       	rjmp	.+300    	; 0x9b2 <__pack_f+0x17c>
     886:	62 81       	ldd	r22, Z+2	; 0x02
     888:	73 81       	ldd	r23, Z+3	; 0x03
     88a:	9f ef       	ldi	r25, 0xFF	; 255
     88c:	62 38       	cpi	r22, 0x82	; 130
     88e:	79 07       	cpc	r23, r25
     890:	0c f0       	brlt	.+2      	; 0x894 <__pack_f+0x5e>
     892:	5b c0       	rjmp	.+182    	; 0x94a <__pack_f+0x114>
     894:	22 e8       	ldi	r18, 0x82	; 130
     896:	3f ef       	ldi	r19, 0xFF	; 255
     898:	26 1b       	sub	r18, r22
     89a:	37 0b       	sbc	r19, r23
     89c:	2a 31       	cpi	r18, 0x1A	; 26
     89e:	31 05       	cpc	r19, r1
     8a0:	2c f0       	brlt	.+10     	; 0x8ac <__pack_f+0x76>
     8a2:	20 e0       	ldi	r18, 0x00	; 0
     8a4:	30 e0       	ldi	r19, 0x00	; 0
     8a6:	40 e0       	ldi	r20, 0x00	; 0
     8a8:	50 e0       	ldi	r21, 0x00	; 0
     8aa:	2a c0       	rjmp	.+84     	; 0x900 <__pack_f+0xca>
     8ac:	b8 01       	movw	r22, r16
     8ae:	a7 01       	movw	r20, r14
     8b0:	02 2e       	mov	r0, r18
     8b2:	04 c0       	rjmp	.+8      	; 0x8bc <__pack_f+0x86>
     8b4:	76 95       	lsr	r23
     8b6:	67 95       	ror	r22
     8b8:	57 95       	ror	r21
     8ba:	47 95       	ror	r20
     8bc:	0a 94       	dec	r0
     8be:	d2 f7       	brpl	.-12     	; 0x8b4 <__pack_f+0x7e>
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	a0 e0       	ldi	r26, 0x00	; 0
     8c6:	b0 e0       	ldi	r27, 0x00	; 0
     8c8:	04 c0       	rjmp	.+8      	; 0x8d2 <__pack_f+0x9c>
     8ca:	88 0f       	add	r24, r24
     8cc:	99 1f       	adc	r25, r25
     8ce:	aa 1f       	adc	r26, r26
     8d0:	bb 1f       	adc	r27, r27
     8d2:	2a 95       	dec	r18
     8d4:	d2 f7       	brpl	.-12     	; 0x8ca <__pack_f+0x94>
     8d6:	01 97       	sbiw	r24, 0x01	; 1
     8d8:	a1 09       	sbc	r26, r1
     8da:	b1 09       	sbc	r27, r1
     8dc:	8e 21       	and	r24, r14
     8de:	9f 21       	and	r25, r15
     8e0:	a0 23       	and	r26, r16
     8e2:	b1 23       	and	r27, r17
     8e4:	00 97       	sbiw	r24, 0x00	; 0
     8e6:	a1 05       	cpc	r26, r1
     8e8:	b1 05       	cpc	r27, r1
     8ea:	21 f0       	breq	.+8      	; 0x8f4 <__pack_f+0xbe>
     8ec:	81 e0       	ldi	r24, 0x01	; 1
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	a0 e0       	ldi	r26, 0x00	; 0
     8f2:	b0 e0       	ldi	r27, 0x00	; 0
     8f4:	9a 01       	movw	r18, r20
     8f6:	ab 01       	movw	r20, r22
     8f8:	28 2b       	or	r18, r24
     8fa:	39 2b       	or	r19, r25
     8fc:	4a 2b       	or	r20, r26
     8fe:	5b 2b       	or	r21, r27
     900:	da 01       	movw	r26, r20
     902:	c9 01       	movw	r24, r18
     904:	8f 77       	andi	r24, 0x7F	; 127
     906:	90 70       	andi	r25, 0x00	; 0
     908:	a0 70       	andi	r26, 0x00	; 0
     90a:	b0 70       	andi	r27, 0x00	; 0
     90c:	80 34       	cpi	r24, 0x40	; 64
     90e:	91 05       	cpc	r25, r1
     910:	a1 05       	cpc	r26, r1
     912:	b1 05       	cpc	r27, r1
     914:	39 f4       	brne	.+14     	; 0x924 <__pack_f+0xee>
     916:	27 ff       	sbrs	r18, 7
     918:	09 c0       	rjmp	.+18     	; 0x92c <__pack_f+0xf6>
     91a:	20 5c       	subi	r18, 0xC0	; 192
     91c:	3f 4f       	sbci	r19, 0xFF	; 255
     91e:	4f 4f       	sbci	r20, 0xFF	; 255
     920:	5f 4f       	sbci	r21, 0xFF	; 255
     922:	04 c0       	rjmp	.+8      	; 0x92c <__pack_f+0xf6>
     924:	21 5c       	subi	r18, 0xC1	; 193
     926:	3f 4f       	sbci	r19, 0xFF	; 255
     928:	4f 4f       	sbci	r20, 0xFF	; 255
     92a:	5f 4f       	sbci	r21, 0xFF	; 255
     92c:	e0 e0       	ldi	r30, 0x00	; 0
     92e:	f0 e0       	ldi	r31, 0x00	; 0
     930:	20 30       	cpi	r18, 0x00	; 0
     932:	a0 e0       	ldi	r26, 0x00	; 0
     934:	3a 07       	cpc	r19, r26
     936:	a0 e0       	ldi	r26, 0x00	; 0
     938:	4a 07       	cpc	r20, r26
     93a:	a0 e4       	ldi	r26, 0x40	; 64
     93c:	5a 07       	cpc	r21, r26
     93e:	10 f0       	brcs	.+4      	; 0x944 <__pack_f+0x10e>
     940:	e1 e0       	ldi	r30, 0x01	; 1
     942:	f0 e0       	ldi	r31, 0x00	; 0
     944:	79 01       	movw	r14, r18
     946:	8a 01       	movw	r16, r20
     948:	27 c0       	rjmp	.+78     	; 0x998 <__pack_f+0x162>
     94a:	60 38       	cpi	r22, 0x80	; 128
     94c:	71 05       	cpc	r23, r1
     94e:	64 f5       	brge	.+88     	; 0x9a8 <__pack_f+0x172>
     950:	fb 01       	movw	r30, r22
     952:	e1 58       	subi	r30, 0x81	; 129
     954:	ff 4f       	sbci	r31, 0xFF	; 255
     956:	d8 01       	movw	r26, r16
     958:	c7 01       	movw	r24, r14
     95a:	8f 77       	andi	r24, 0x7F	; 127
     95c:	90 70       	andi	r25, 0x00	; 0
     95e:	a0 70       	andi	r26, 0x00	; 0
     960:	b0 70       	andi	r27, 0x00	; 0
     962:	80 34       	cpi	r24, 0x40	; 64
     964:	91 05       	cpc	r25, r1
     966:	a1 05       	cpc	r26, r1
     968:	b1 05       	cpc	r27, r1
     96a:	39 f4       	brne	.+14     	; 0x97a <__pack_f+0x144>
     96c:	e7 fe       	sbrs	r14, 7
     96e:	0d c0       	rjmp	.+26     	; 0x98a <__pack_f+0x154>
     970:	80 e4       	ldi	r24, 0x40	; 64
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	a0 e0       	ldi	r26, 0x00	; 0
     976:	b0 e0       	ldi	r27, 0x00	; 0
     978:	04 c0       	rjmp	.+8      	; 0x982 <__pack_f+0x14c>
     97a:	8f e3       	ldi	r24, 0x3F	; 63
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	a0 e0       	ldi	r26, 0x00	; 0
     980:	b0 e0       	ldi	r27, 0x00	; 0
     982:	e8 0e       	add	r14, r24
     984:	f9 1e       	adc	r15, r25
     986:	0a 1f       	adc	r16, r26
     988:	1b 1f       	adc	r17, r27
     98a:	17 ff       	sbrs	r17, 7
     98c:	05 c0       	rjmp	.+10     	; 0x998 <__pack_f+0x162>
     98e:	16 95       	lsr	r17
     990:	07 95       	ror	r16
     992:	f7 94       	ror	r15
     994:	e7 94       	ror	r14
     996:	31 96       	adiw	r30, 0x01	; 1
     998:	87 e0       	ldi	r24, 0x07	; 7
     99a:	16 95       	lsr	r17
     99c:	07 95       	ror	r16
     99e:	f7 94       	ror	r15
     9a0:	e7 94       	ror	r14
     9a2:	8a 95       	dec	r24
     9a4:	d1 f7       	brne	.-12     	; 0x99a <__pack_f+0x164>
     9a6:	05 c0       	rjmp	.+10     	; 0x9b2 <__pack_f+0x17c>
     9a8:	ee 24       	eor	r14, r14
     9aa:	ff 24       	eor	r15, r15
     9ac:	87 01       	movw	r16, r14
     9ae:	ef ef       	ldi	r30, 0xFF	; 255
     9b0:	f0 e0       	ldi	r31, 0x00	; 0
     9b2:	6e 2f       	mov	r22, r30
     9b4:	67 95       	ror	r22
     9b6:	66 27       	eor	r22, r22
     9b8:	67 95       	ror	r22
     9ba:	90 2f       	mov	r25, r16
     9bc:	9f 77       	andi	r25, 0x7F	; 127
     9be:	d7 94       	ror	r13
     9c0:	dd 24       	eor	r13, r13
     9c2:	d7 94       	ror	r13
     9c4:	8e 2f       	mov	r24, r30
     9c6:	86 95       	lsr	r24
     9c8:	49 2f       	mov	r20, r25
     9ca:	46 2b       	or	r20, r22
     9cc:	58 2f       	mov	r21, r24
     9ce:	5d 29       	or	r21, r13
     9d0:	b7 01       	movw	r22, r14
     9d2:	ca 01       	movw	r24, r20
     9d4:	1f 91       	pop	r17
     9d6:	0f 91       	pop	r16
     9d8:	ff 90       	pop	r15
     9da:	ef 90       	pop	r14
     9dc:	df 90       	pop	r13
     9de:	08 95       	ret

000009e0 <__unpack_f>:
     9e0:	fc 01       	movw	r30, r24
     9e2:	db 01       	movw	r26, r22
     9e4:	40 81       	ld	r20, Z
     9e6:	51 81       	ldd	r21, Z+1	; 0x01
     9e8:	22 81       	ldd	r18, Z+2	; 0x02
     9ea:	62 2f       	mov	r22, r18
     9ec:	6f 77       	andi	r22, 0x7F	; 127
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	22 1f       	adc	r18, r18
     9f2:	22 27       	eor	r18, r18
     9f4:	22 1f       	adc	r18, r18
     9f6:	93 81       	ldd	r25, Z+3	; 0x03
     9f8:	89 2f       	mov	r24, r25
     9fa:	88 0f       	add	r24, r24
     9fc:	82 2b       	or	r24, r18
     9fe:	28 2f       	mov	r18, r24
     a00:	30 e0       	ldi	r19, 0x00	; 0
     a02:	99 1f       	adc	r25, r25
     a04:	99 27       	eor	r25, r25
     a06:	99 1f       	adc	r25, r25
     a08:	11 96       	adiw	r26, 0x01	; 1
     a0a:	9c 93       	st	X, r25
     a0c:	11 97       	sbiw	r26, 0x01	; 1
     a0e:	21 15       	cp	r18, r1
     a10:	31 05       	cpc	r19, r1
     a12:	a9 f5       	brne	.+106    	; 0xa7e <__unpack_f+0x9e>
     a14:	41 15       	cp	r20, r1
     a16:	51 05       	cpc	r21, r1
     a18:	61 05       	cpc	r22, r1
     a1a:	71 05       	cpc	r23, r1
     a1c:	11 f4       	brne	.+4      	; 0xa22 <__unpack_f+0x42>
     a1e:	82 e0       	ldi	r24, 0x02	; 2
     a20:	37 c0       	rjmp	.+110    	; 0xa90 <__unpack_f+0xb0>
     a22:	82 e8       	ldi	r24, 0x82	; 130
     a24:	9f ef       	ldi	r25, 0xFF	; 255
     a26:	13 96       	adiw	r26, 0x03	; 3
     a28:	9c 93       	st	X, r25
     a2a:	8e 93       	st	-X, r24
     a2c:	12 97       	sbiw	r26, 0x02	; 2
     a2e:	9a 01       	movw	r18, r20
     a30:	ab 01       	movw	r20, r22
     a32:	67 e0       	ldi	r22, 0x07	; 7
     a34:	22 0f       	add	r18, r18
     a36:	33 1f       	adc	r19, r19
     a38:	44 1f       	adc	r20, r20
     a3a:	55 1f       	adc	r21, r21
     a3c:	6a 95       	dec	r22
     a3e:	d1 f7       	brne	.-12     	; 0xa34 <__unpack_f+0x54>
     a40:	83 e0       	ldi	r24, 0x03	; 3
     a42:	8c 93       	st	X, r24
     a44:	0d c0       	rjmp	.+26     	; 0xa60 <__unpack_f+0x80>
     a46:	22 0f       	add	r18, r18
     a48:	33 1f       	adc	r19, r19
     a4a:	44 1f       	adc	r20, r20
     a4c:	55 1f       	adc	r21, r21
     a4e:	12 96       	adiw	r26, 0x02	; 2
     a50:	8d 91       	ld	r24, X+
     a52:	9c 91       	ld	r25, X
     a54:	13 97       	sbiw	r26, 0x03	; 3
     a56:	01 97       	sbiw	r24, 0x01	; 1
     a58:	13 96       	adiw	r26, 0x03	; 3
     a5a:	9c 93       	st	X, r25
     a5c:	8e 93       	st	-X, r24
     a5e:	12 97       	sbiw	r26, 0x02	; 2
     a60:	20 30       	cpi	r18, 0x00	; 0
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	38 07       	cpc	r19, r24
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	48 07       	cpc	r20, r24
     a6a:	80 e4       	ldi	r24, 0x40	; 64
     a6c:	58 07       	cpc	r21, r24
     a6e:	58 f3       	brcs	.-42     	; 0xa46 <__unpack_f+0x66>
     a70:	14 96       	adiw	r26, 0x04	; 4
     a72:	2d 93       	st	X+, r18
     a74:	3d 93       	st	X+, r19
     a76:	4d 93       	st	X+, r20
     a78:	5c 93       	st	X, r21
     a7a:	17 97       	sbiw	r26, 0x07	; 7
     a7c:	08 95       	ret
     a7e:	2f 3f       	cpi	r18, 0xFF	; 255
     a80:	31 05       	cpc	r19, r1
     a82:	79 f4       	brne	.+30     	; 0xaa2 <__unpack_f+0xc2>
     a84:	41 15       	cp	r20, r1
     a86:	51 05       	cpc	r21, r1
     a88:	61 05       	cpc	r22, r1
     a8a:	71 05       	cpc	r23, r1
     a8c:	19 f4       	brne	.+6      	; 0xa94 <__unpack_f+0xb4>
     a8e:	84 e0       	ldi	r24, 0x04	; 4
     a90:	8c 93       	st	X, r24
     a92:	08 95       	ret
     a94:	64 ff       	sbrs	r22, 4
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <__unpack_f+0xbe>
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	8c 93       	st	X, r24
     a9c:	12 c0       	rjmp	.+36     	; 0xac2 <__unpack_f+0xe2>
     a9e:	1c 92       	st	X, r1
     aa0:	10 c0       	rjmp	.+32     	; 0xac2 <__unpack_f+0xe2>
     aa2:	2f 57       	subi	r18, 0x7F	; 127
     aa4:	30 40       	sbci	r19, 0x00	; 0
     aa6:	13 96       	adiw	r26, 0x03	; 3
     aa8:	3c 93       	st	X, r19
     aaa:	2e 93       	st	-X, r18
     aac:	12 97       	sbiw	r26, 0x02	; 2
     aae:	83 e0       	ldi	r24, 0x03	; 3
     ab0:	8c 93       	st	X, r24
     ab2:	87 e0       	ldi	r24, 0x07	; 7
     ab4:	44 0f       	add	r20, r20
     ab6:	55 1f       	adc	r21, r21
     ab8:	66 1f       	adc	r22, r22
     aba:	77 1f       	adc	r23, r23
     abc:	8a 95       	dec	r24
     abe:	d1 f7       	brne	.-12     	; 0xab4 <__unpack_f+0xd4>
     ac0:	70 64       	ori	r23, 0x40	; 64
     ac2:	14 96       	adiw	r26, 0x04	; 4
     ac4:	4d 93       	st	X+, r20
     ac6:	5d 93       	st	X+, r21
     ac8:	6d 93       	st	X+, r22
     aca:	7c 93       	st	X, r23
     acc:	17 97       	sbiw	r26, 0x07	; 7
     ace:	08 95       	ret

00000ad0 <__fpcmp_parts_f>:
     ad0:	1f 93       	push	r17
     ad2:	dc 01       	movw	r26, r24
     ad4:	fb 01       	movw	r30, r22
     ad6:	9c 91       	ld	r25, X
     ad8:	92 30       	cpi	r25, 0x02	; 2
     ada:	08 f4       	brcc	.+2      	; 0xade <__fpcmp_parts_f+0xe>
     adc:	47 c0       	rjmp	.+142    	; 0xb6c <__fpcmp_parts_f+0x9c>
     ade:	80 81       	ld	r24, Z
     ae0:	82 30       	cpi	r24, 0x02	; 2
     ae2:	08 f4       	brcc	.+2      	; 0xae6 <__fpcmp_parts_f+0x16>
     ae4:	43 c0       	rjmp	.+134    	; 0xb6c <__fpcmp_parts_f+0x9c>
     ae6:	94 30       	cpi	r25, 0x04	; 4
     ae8:	51 f4       	brne	.+20     	; 0xafe <__fpcmp_parts_f+0x2e>
     aea:	11 96       	adiw	r26, 0x01	; 1
     aec:	1c 91       	ld	r17, X
     aee:	84 30       	cpi	r24, 0x04	; 4
     af0:	99 f5       	brne	.+102    	; 0xb58 <__fpcmp_parts_f+0x88>
     af2:	81 81       	ldd	r24, Z+1	; 0x01
     af4:	68 2f       	mov	r22, r24
     af6:	70 e0       	ldi	r23, 0x00	; 0
     af8:	61 1b       	sub	r22, r17
     afa:	71 09       	sbc	r23, r1
     afc:	3f c0       	rjmp	.+126    	; 0xb7c <__fpcmp_parts_f+0xac>
     afe:	84 30       	cpi	r24, 0x04	; 4
     b00:	21 f0       	breq	.+8      	; 0xb0a <__fpcmp_parts_f+0x3a>
     b02:	92 30       	cpi	r25, 0x02	; 2
     b04:	31 f4       	brne	.+12     	; 0xb12 <__fpcmp_parts_f+0x42>
     b06:	82 30       	cpi	r24, 0x02	; 2
     b08:	b9 f1       	breq	.+110    	; 0xb78 <__fpcmp_parts_f+0xa8>
     b0a:	81 81       	ldd	r24, Z+1	; 0x01
     b0c:	88 23       	and	r24, r24
     b0e:	89 f1       	breq	.+98     	; 0xb72 <__fpcmp_parts_f+0xa2>
     b10:	2d c0       	rjmp	.+90     	; 0xb6c <__fpcmp_parts_f+0x9c>
     b12:	11 96       	adiw	r26, 0x01	; 1
     b14:	1c 91       	ld	r17, X
     b16:	11 97       	sbiw	r26, 0x01	; 1
     b18:	82 30       	cpi	r24, 0x02	; 2
     b1a:	f1 f0       	breq	.+60     	; 0xb58 <__fpcmp_parts_f+0x88>
     b1c:	81 81       	ldd	r24, Z+1	; 0x01
     b1e:	18 17       	cp	r17, r24
     b20:	d9 f4       	brne	.+54     	; 0xb58 <__fpcmp_parts_f+0x88>
     b22:	12 96       	adiw	r26, 0x02	; 2
     b24:	2d 91       	ld	r18, X+
     b26:	3c 91       	ld	r19, X
     b28:	13 97       	sbiw	r26, 0x03	; 3
     b2a:	82 81       	ldd	r24, Z+2	; 0x02
     b2c:	93 81       	ldd	r25, Z+3	; 0x03
     b2e:	82 17       	cp	r24, r18
     b30:	93 07       	cpc	r25, r19
     b32:	94 f0       	brlt	.+36     	; 0xb58 <__fpcmp_parts_f+0x88>
     b34:	28 17       	cp	r18, r24
     b36:	39 07       	cpc	r19, r25
     b38:	bc f0       	brlt	.+46     	; 0xb68 <__fpcmp_parts_f+0x98>
     b3a:	14 96       	adiw	r26, 0x04	; 4
     b3c:	8d 91       	ld	r24, X+
     b3e:	9d 91       	ld	r25, X+
     b40:	0d 90       	ld	r0, X+
     b42:	bc 91       	ld	r27, X
     b44:	a0 2d       	mov	r26, r0
     b46:	24 81       	ldd	r18, Z+4	; 0x04
     b48:	35 81       	ldd	r19, Z+5	; 0x05
     b4a:	46 81       	ldd	r20, Z+6	; 0x06
     b4c:	57 81       	ldd	r21, Z+7	; 0x07
     b4e:	28 17       	cp	r18, r24
     b50:	39 07       	cpc	r19, r25
     b52:	4a 07       	cpc	r20, r26
     b54:	5b 07       	cpc	r21, r27
     b56:	18 f4       	brcc	.+6      	; 0xb5e <__fpcmp_parts_f+0x8e>
     b58:	11 23       	and	r17, r17
     b5a:	41 f0       	breq	.+16     	; 0xb6c <__fpcmp_parts_f+0x9c>
     b5c:	0a c0       	rjmp	.+20     	; 0xb72 <__fpcmp_parts_f+0xa2>
     b5e:	82 17       	cp	r24, r18
     b60:	93 07       	cpc	r25, r19
     b62:	a4 07       	cpc	r26, r20
     b64:	b5 07       	cpc	r27, r21
     b66:	40 f4       	brcc	.+16     	; 0xb78 <__fpcmp_parts_f+0xa8>
     b68:	11 23       	and	r17, r17
     b6a:	19 f0       	breq	.+6      	; 0xb72 <__fpcmp_parts_f+0xa2>
     b6c:	61 e0       	ldi	r22, 0x01	; 1
     b6e:	70 e0       	ldi	r23, 0x00	; 0
     b70:	05 c0       	rjmp	.+10     	; 0xb7c <__fpcmp_parts_f+0xac>
     b72:	6f ef       	ldi	r22, 0xFF	; 255
     b74:	7f ef       	ldi	r23, 0xFF	; 255
     b76:	02 c0       	rjmp	.+4      	; 0xb7c <__fpcmp_parts_f+0xac>
     b78:	60 e0       	ldi	r22, 0x00	; 0
     b7a:	70 e0       	ldi	r23, 0x00	; 0
     b7c:	cb 01       	movw	r24, r22
     b7e:	1f 91       	pop	r17
     b80:	08 95       	ret

00000b82 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
     b82:	af 92       	push	r10
     b84:	bf 92       	push	r11
     b86:	cf 92       	push	r12
     b88:	df 92       	push	r13
     b8a:	ef 92       	push	r14
     b8c:	ff 92       	push	r15
     b8e:	0f 93       	push	r16
     b90:	df 93       	push	r29
     b92:	cf 93       	push	r28
     b94:	0f 92       	push	r0
     b96:	cd b7       	in	r28, 0x3d	; 61
     b98:	de b7       	in	r29, 0x3e	; 62
     b9a:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
     b9c:	8a e0       	ldi	r24, 0x0A	; 10
     b9e:	62 e0       	ldi	r22, 0x02	; 2
     ba0:	40 e0       	ldi	r20, 0x00	; 0
     ba2:	0e 94 a1 12 	call	0x2542	; 0x2542 <xQueueGenericCreate>
     ba6:	90 93 b7 01 	sts	0x01B7, r25
     baa:	80 93 b6 01 	sts	0x01B6, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     bae:	85 e4       	ldi	r24, 0x45	; 69
     bb0:	96 e0       	ldi	r25, 0x06	; 6
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	31 e0       	ldi	r19, 0x01	; 1
     bb6:	e6 eb       	ldi	r30, 0xB6	; 182
     bb8:	f1 e0       	ldi	r31, 0x01	; 1
     bba:	b9 01       	movw	r22, r18
     bbc:	45 e5       	ldi	r20, 0x55	; 85
     bbe:	50 e0       	ldi	r21, 0x00	; 0
     bc0:	9f 01       	movw	r18, r30
     bc2:	09 81       	ldd	r16, Y+1	; 0x01
     bc4:	ee 24       	eor	r14, r14
     bc6:	ff 24       	eor	r15, r15
     bc8:	cc 24       	eor	r12, r12
     bca:	dd 24       	eor	r13, r13
     bcc:	aa 24       	eor	r10, r10
     bce:	bb 24       	eor	r11, r11
     bd0:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     bd4:	88 e0       	ldi	r24, 0x08	; 8
     bd6:	96 e0       	ldi	r25, 0x06	; 6
     bd8:	28 e0       	ldi	r18, 0x08	; 8
     bda:	31 e0       	ldi	r19, 0x01	; 1
     bdc:	e6 eb       	ldi	r30, 0xB6	; 182
     bde:	f1 e0       	ldi	r31, 0x01	; 1
     be0:	b9 01       	movw	r22, r18
     be2:	45 e5       	ldi	r20, 0x55	; 85
     be4:	50 e0       	ldi	r21, 0x00	; 0
     be6:	9f 01       	movw	r18, r30
     be8:	09 81       	ldd	r16, Y+1	; 0x01
     bea:	ee 24       	eor	r14, r14
     bec:	ff 24       	eor	r15, r15
     bee:	cc 24       	eor	r12, r12
     bf0:	dd 24       	eor	r13, r13
     bf2:	aa 24       	eor	r10, r10
     bf4:	bb 24       	eor	r11, r11
     bf6:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>
}
     bfa:	0f 90       	pop	r0
     bfc:	cf 91       	pop	r28
     bfe:	df 91       	pop	r29
     c00:	0f 91       	pop	r16
     c02:	ff 90       	pop	r15
     c04:	ef 90       	pop	r14
     c06:	df 90       	pop	r13
     c08:	cf 90       	pop	r12
     c0a:	bf 90       	pop	r11
     c0c:	af 90       	pop	r10
     c0e:	08 95       	ret

00000c10 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     c10:	df 93       	push	r29
     c12:	cf 93       	push	r28
     c14:	00 d0       	rcall	.+0      	; 0xc16 <vPolledQueueProducer+0x6>
     c16:	00 d0       	rcall	.+0      	; 0xc18 <vPolledQueueProducer+0x8>
     c18:	00 d0       	rcall	.+0      	; 0xc1a <vPolledQueueProducer+0xa>
     c1a:	cd b7       	in	r28, 0x3d	; 61
     c1c:	de b7       	in	r29, 0x3e	; 62
     c1e:	9e 83       	std	Y+6, r25	; 0x06
     c20:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
     c22:	1c 82       	std	Y+4, r1	; 0x04
     c24:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
     c26:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     c28:	19 82       	std	Y+1, r1	; 0x01
     c2a:	27 c0       	rjmp	.+78     	; 0xc7a <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     c2c:	ed 81       	ldd	r30, Y+5	; 0x05
     c2e:	fe 81       	ldd	r31, Y+6	; 0x06
     c30:	80 81       	ld	r24, Z
     c32:	91 81       	ldd	r25, Z+1	; 0x01
     c34:	9e 01       	movw	r18, r28
     c36:	2d 5f       	subi	r18, 0xFD	; 253
     c38:	3f 4f       	sbci	r19, 0xFF	; 255
     c3a:	b9 01       	movw	r22, r18
     c3c:	40 e0       	ldi	r20, 0x00	; 0
     c3e:	50 e0       	ldi	r21, 0x00	; 0
     c40:	20 e0       	ldi	r18, 0x00	; 0
     c42:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <xQueueGenericSend>
     c46:	81 30       	cpi	r24, 0x01	; 1
     c48:	19 f0       	breq	.+6      	; 0xc50 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     c4a:	81 e0       	ldi	r24, 0x01	; 1
     c4c:	8a 83       	std	Y+2, r24	; 0x02
     c4e:	12 c0       	rjmp	.+36     	; 0xc74 <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
     c50:	8a 81       	ldd	r24, Y+2	; 0x02
     c52:	88 23       	and	r24, r24
     c54:	51 f4       	brne	.+20     	; 0xc6a <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	0f 92       	push	r0
						xPollingProducerCount++;
     c5c:	80 91 b5 01 	lds	r24, 0x01B5
     c60:	8f 5f       	subi	r24, 0xFF	; 255
     c62:	80 93 b5 01 	sts	0x01B5, r24
					portEXIT_CRITICAL();
     c66:	0f 90       	pop	r0
     c68:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     c6a:	8b 81       	ldd	r24, Y+3	; 0x03
     c6c:	9c 81       	ldd	r25, Y+4	; 0x04
     c6e:	01 96       	adiw	r24, 0x01	; 1
     c70:	9c 83       	std	Y+4, r25	; 0x04
     c72:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     c74:	89 81       	ldd	r24, Y+1	; 0x01
     c76:	8f 5f       	subi	r24, 0xFF	; 255
     c78:	89 83       	std	Y+1, r24	; 0x01
     c7a:	89 81       	ldd	r24, Y+1	; 0x01
     c7c:	83 30       	cpi	r24, 0x03	; 3
     c7e:	b4 f2       	brlt	.-84     	; 0xc2c <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     c80:	88 ec       	ldi	r24, 0xC8	; 200
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
     c88:	cf cf       	rjmp	.-98     	; 0xc28 <vPolledQueueProducer+0x18>

00000c8a <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     c8a:	df 93       	push	r29
     c8c:	cf 93       	push	r28
     c8e:	cd b7       	in	r28, 0x3d	; 61
     c90:	de b7       	in	r29, 0x3e	; 62
     c92:	27 97       	sbiw	r28, 0x07	; 7
     c94:	0f b6       	in	r0, 0x3f	; 63
     c96:	f8 94       	cli
     c98:	de bf       	out	0x3e, r29	; 62
     c9a:	0f be       	out	0x3f, r0	; 63
     c9c:	cd bf       	out	0x3d, r28	; 61
     c9e:	9f 83       	std	Y+7, r25	; 0x07
     ca0:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     ca2:	1b 82       	std	Y+3, r1	; 0x03
     ca4:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
     ca6:	19 82       	std	Y+1, r1	; 0x01
     ca8:	2f c0       	rjmp	.+94     	; 0xd08 <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     caa:	ee 81       	ldd	r30, Y+6	; 0x06
     cac:	ff 81       	ldd	r31, Y+7	; 0x07
     cae:	80 81       	ld	r24, Z
     cb0:	91 81       	ldd	r25, Z+1	; 0x01
     cb2:	9e 01       	movw	r18, r28
     cb4:	2c 5f       	subi	r18, 0xFC	; 252
     cb6:	3f 4f       	sbci	r19, 0xFF	; 255
     cb8:	b9 01       	movw	r22, r18
     cba:	40 e0       	ldi	r20, 0x00	; 0
     cbc:	50 e0       	ldi	r21, 0x00	; 0
     cbe:	20 e0       	ldi	r18, 0x00	; 0
     cc0:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <xQueueGenericReceive>
     cc4:	81 30       	cpi	r24, 0x01	; 1
     cc6:	01 f5       	brne	.+64     	; 0xd08 <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
     cc8:	2c 81       	ldd	r18, Y+4	; 0x04
     cca:	3d 81       	ldd	r19, Y+5	; 0x05
     ccc:	8a 81       	ldd	r24, Y+2	; 0x02
     cce:	9b 81       	ldd	r25, Y+3	; 0x03
     cd0:	28 17       	cp	r18, r24
     cd2:	39 07       	cpc	r19, r25
     cd4:	39 f0       	breq	.+14     	; 0xce4 <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     cd6:	81 e0       	ldi	r24, 0x01	; 1
     cd8:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
     cda:	8c 81       	ldd	r24, Y+4	; 0x04
     cdc:	9d 81       	ldd	r25, Y+5	; 0x05
     cde:	9b 83       	std	Y+3, r25	; 0x03
     ce0:	8a 83       	std	Y+2, r24	; 0x02
     ce2:	0d c0       	rjmp	.+26     	; 0xcfe <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
     ce4:	89 81       	ldd	r24, Y+1	; 0x01
     ce6:	88 23       	and	r24, r24
     ce8:	51 f4       	brne	.+20     	; 0xcfe <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	0f 92       	push	r0
							xPollingConsumerCount++;
     cf0:	80 91 b4 01 	lds	r24, 0x01B4
     cf4:	8f 5f       	subi	r24, 0xFF	; 255
     cf6:	80 93 b4 01 	sts	0x01B4, r24
						portEXIT_CRITICAL();
     cfa:	0f 90       	pop	r0
     cfc:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     cfe:	8a 81       	ldd	r24, Y+2	; 0x02
     d00:	9b 81       	ldd	r25, Y+3	; 0x03
     d02:	01 96       	adiw	r24, 0x01	; 1
     d04:	9b 83       	std	Y+3, r25	; 0x03
     d06:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     d08:	ee 81       	ldd	r30, Y+6	; 0x06
     d0a:	ff 81       	ldd	r31, Y+7	; 0x07
     d0c:	80 81       	ld	r24, Z
     d0e:	91 81       	ldd	r25, Z+1	; 0x01
     d10:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <uxQueueMessagesWaiting>
     d14:	88 23       	and	r24, r24
     d16:	49 f6       	brne	.-110    	; 0xcaa <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     d18:	84 eb       	ldi	r24, 0xB4	; 180
     d1a:	90 e0       	ldi	r25, 0x00	; 0
     d1c:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
     d20:	f3 cf       	rjmp	.-26     	; 0xd08 <vPolledQueueConsumer+0x7e>

00000d22 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
     d22:	df 93       	push	r29
     d24:	cf 93       	push	r28
     d26:	0f 92       	push	r0
     d28:	cd b7       	in	r28, 0x3d	; 61
     d2a:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
     d2c:	80 91 b4 01 	lds	r24, 0x01B4
     d30:	88 23       	and	r24, r24
     d32:	21 f0       	breq	.+8      	; 0xd3c <xArePollingQueuesStillRunning+0x1a>
     d34:	80 91 b5 01 	lds	r24, 0x01B5
     d38:	88 23       	and	r24, r24
     d3a:	11 f4       	brne	.+4      	; 0xd40 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
     d3c:	19 82       	std	Y+1, r1	; 0x01
     d3e:	02 c0       	rjmp	.+4      	; 0xd44 <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
     d40:	81 e0       	ldi	r24, 0x01	; 1
     d42:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
     d44:	10 92 b4 01 	sts	0x01B4, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
     d48:	10 92 b5 01 	sts	0x01B5, r1

	return xReturn;
     d4c:	89 81       	ldd	r24, Y+1	; 0x01
}
     d4e:	0f 90       	pop	r0
     d50:	cf 91       	pop	r28
     d52:	df 91       	pop	r29
     d54:	08 95       	ret

00000d56 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     d56:	df 93       	push	r29
     d58:	cf 93       	push	r28
     d5a:	cd b7       	in	r28, 0x3d	; 61
     d5c:	de b7       	in	r29, 0x3e	; 62
     d5e:	27 97       	sbiw	r28, 0x07	; 7
     d60:	0f b6       	in	r0, 0x3f	; 63
     d62:	f8 94       	cli
     d64:	de bf       	out	0x3e, r29	; 62
     d66:	0f be       	out	0x3f, r0	; 63
     d68:	cd bf       	out	0x3d, r28	; 61
     d6a:	9d 83       	std	Y+5, r25	; 0x05
     d6c:	8c 83       	std	Y+4, r24	; 0x04
     d6e:	6e 83       	std	Y+6, r22	; 0x06
     d70:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     d72:	8a e1       	ldi	r24, 0x1A	; 26
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	0e 94 c3 0c 	call	0x1986	; 0x1986 <pvPortMalloc>
     d7a:	9a 83       	std	Y+2, r25	; 0x02
     d7c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     d7e:	89 81       	ldd	r24, Y+1	; 0x01
     d80:	9a 81       	ldd	r25, Y+2	; 0x02
     d82:	00 97       	sbiw	r24, 0x00	; 0
     d84:	09 f4       	brne	.+2      	; 0xd88 <xCoRoutineCreate+0x32>
     d86:	6f c0       	rjmp	.+222    	; 0xe66 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     d88:	80 91 b8 01 	lds	r24, 0x01B8
     d8c:	90 91 b9 01 	lds	r25, 0x01B9
     d90:	00 97       	sbiw	r24, 0x00	; 0
     d92:	41 f4       	brne	.+16     	; 0xda4 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     d94:	89 81       	ldd	r24, Y+1	; 0x01
     d96:	9a 81       	ldd	r25, Y+2	; 0x02
     d98:	90 93 b9 01 	sts	0x01B9, r25
     d9c:	80 93 b8 01 	sts	0x01B8, r24
			prvInitialiseCoRoutineLists();
     da0:	0e 94 12 09 	call	0x1224	; 0x1224 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     da4:	8e 81       	ldd	r24, Y+6	; 0x06
     da6:	82 30       	cpi	r24, 0x02	; 2
     da8:	10 f0       	brcs	.+4      	; 0xdae <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     dae:	e9 81       	ldd	r30, Y+1	; 0x01
     db0:	fa 81       	ldd	r31, Y+2	; 0x02
     db2:	11 8e       	std	Z+25, r1	; 0x19
     db4:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     db6:	e9 81       	ldd	r30, Y+1	; 0x01
     db8:	fa 81       	ldd	r31, Y+2	; 0x02
     dba:	8e 81       	ldd	r24, Y+6	; 0x06
     dbc:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     dbe:	e9 81       	ldd	r30, Y+1	; 0x01
     dc0:	fa 81       	ldd	r31, Y+2	; 0x02
     dc2:	8f 81       	ldd	r24, Y+7	; 0x07
     dc4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     dc6:	e9 81       	ldd	r30, Y+1	; 0x01
     dc8:	fa 81       	ldd	r31, Y+2	; 0x02
     dca:	8c 81       	ldd	r24, Y+4	; 0x04
     dcc:	9d 81       	ldd	r25, Y+5	; 0x05
     dce:	91 83       	std	Z+1, r25	; 0x01
     dd0:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     dd2:	89 81       	ldd	r24, Y+1	; 0x01
     dd4:	9a 81       	ldd	r25, Y+2	; 0x02
     dd6:	02 96       	adiw	r24, 0x02	; 2
     dd8:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     ddc:	89 81       	ldd	r24, Y+1	; 0x01
     dde:	9a 81       	ldd	r25, Y+2	; 0x02
     de0:	0c 96       	adiw	r24, 0x0c	; 12
     de2:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     de6:	e9 81       	ldd	r30, Y+1	; 0x01
     de8:	fa 81       	ldd	r31, Y+2	; 0x02
     dea:	89 81       	ldd	r24, Y+1	; 0x01
     dec:	9a 81       	ldd	r25, Y+2	; 0x02
     dee:	91 87       	std	Z+9, r25	; 0x09
     df0:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     df2:	e9 81       	ldd	r30, Y+1	; 0x01
     df4:	fa 81       	ldd	r31, Y+2	; 0x02
     df6:	89 81       	ldd	r24, Y+1	; 0x01
     df8:	9a 81       	ldd	r25, Y+2	; 0x02
     dfa:	93 8b       	std	Z+19, r25	; 0x13
     dfc:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     dfe:	8e 81       	ldd	r24, Y+6	; 0x06
     e00:	28 2f       	mov	r18, r24
     e02:	30 e0       	ldi	r19, 0x00	; 0
     e04:	82 e0       	ldi	r24, 0x02	; 2
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	82 1b       	sub	r24, r18
     e0a:	93 0b       	sbc	r25, r19
     e0c:	e9 81       	ldd	r30, Y+1	; 0x01
     e0e:	fa 81       	ldd	r31, Y+2	; 0x02
     e10:	95 87       	std	Z+13, r25	; 0x0d
     e12:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     e14:	e9 81       	ldd	r30, Y+1	; 0x01
     e16:	fa 81       	ldd	r31, Y+2	; 0x02
     e18:	96 89       	ldd	r25, Z+22	; 0x16
     e1a:	80 91 ba 01 	lds	r24, 0x01BA
     e1e:	89 17       	cp	r24, r25
     e20:	28 f4       	brcc	.+10     	; 0xe2c <xCoRoutineCreate+0xd6>
     e22:	e9 81       	ldd	r30, Y+1	; 0x01
     e24:	fa 81       	ldd	r31, Y+2	; 0x02
     e26:	86 89       	ldd	r24, Z+22	; 0x16
     e28:	80 93 ba 01 	sts	0x01BA, r24
     e2c:	e9 81       	ldd	r30, Y+1	; 0x01
     e2e:	fa 81       	ldd	r31, Y+2	; 0x02
     e30:	86 89       	ldd	r24, Z+22	; 0x16
     e32:	28 2f       	mov	r18, r24
     e34:	30 e0       	ldi	r19, 0x00	; 0
     e36:	c9 01       	movw	r24, r18
     e38:	88 0f       	add	r24, r24
     e3a:	99 1f       	adc	r25, r25
     e3c:	88 0f       	add	r24, r24
     e3e:	99 1f       	adc	r25, r25
     e40:	88 0f       	add	r24, r24
     e42:	99 1f       	adc	r25, r25
     e44:	82 0f       	add	r24, r18
     e46:	93 1f       	adc	r25, r19
     e48:	ac 01       	movw	r20, r24
     e4a:	4f 53       	subi	r20, 0x3F	; 63
     e4c:	5e 4f       	sbci	r21, 0xFE	; 254
     e4e:	89 81       	ldd	r24, Y+1	; 0x01
     e50:	9a 81       	ldd	r25, Y+2	; 0x02
     e52:	9c 01       	movw	r18, r24
     e54:	2e 5f       	subi	r18, 0xFE	; 254
     e56:	3f 4f       	sbci	r19, 0xFF	; 255
     e58:	ca 01       	movw	r24, r20
     e5a:	b9 01       	movw	r22, r18
     e5c:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

		xReturn = pdPASS;
     e60:	81 e0       	ldi	r24, 0x01	; 1
     e62:	8b 83       	std	Y+3, r24	; 0x03
     e64:	02 c0       	rjmp	.+4      	; 0xe6a <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     e66:	8f ef       	ldi	r24, 0xFF	; 255
     e68:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
     e6a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     e6c:	27 96       	adiw	r28, 0x07	; 7
     e6e:	0f b6       	in	r0, 0x3f	; 63
     e70:	f8 94       	cli
     e72:	de bf       	out	0x3e, r29	; 62
     e74:	0f be       	out	0x3f, r0	; 63
     e76:	cd bf       	out	0x3d, r28	; 61
     e78:	cf 91       	pop	r28
     e7a:	df 91       	pop	r29
     e7c:	08 95       	ret

00000e7e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     e7e:	df 93       	push	r29
     e80:	cf 93       	push	r28
     e82:	00 d0       	rcall	.+0      	; 0xe84 <vCoRoutineAddToDelayedList+0x6>
     e84:	00 d0       	rcall	.+0      	; 0xe86 <vCoRoutineAddToDelayedList+0x8>
     e86:	00 d0       	rcall	.+0      	; 0xe88 <vCoRoutineAddToDelayedList+0xa>
     e88:	cd b7       	in	r28, 0x3d	; 61
     e8a:	de b7       	in	r29, 0x3e	; 62
     e8c:	9c 83       	std	Y+4, r25	; 0x04
     e8e:	8b 83       	std	Y+3, r24	; 0x03
     e90:	7e 83       	std	Y+6, r23	; 0x06
     e92:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     e94:	20 91 bb 01 	lds	r18, 0x01BB
     e98:	30 91 bc 01 	lds	r19, 0x01BC
     e9c:	8b 81       	ldd	r24, Y+3	; 0x03
     e9e:	9c 81       	ldd	r25, Y+4	; 0x04
     ea0:	82 0f       	add	r24, r18
     ea2:	93 1f       	adc	r25, r19
     ea4:	9a 83       	std	Y+2, r25	; 0x02
     ea6:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ea8:	80 91 b8 01 	lds	r24, 0x01B8
     eac:	90 91 b9 01 	lds	r25, 0x01B9
     eb0:	02 96       	adiw	r24, 0x02	; 2
     eb2:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     eb6:	e0 91 b8 01 	lds	r30, 0x01B8
     eba:	f0 91 b9 01 	lds	r31, 0x01B9
     ebe:	89 81       	ldd	r24, Y+1	; 0x01
     ec0:	9a 81       	ldd	r25, Y+2	; 0x02
     ec2:	93 83       	std	Z+3, r25	; 0x03
     ec4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     ec6:	20 91 bb 01 	lds	r18, 0x01BB
     eca:	30 91 bc 01 	lds	r19, 0x01BC
     ece:	89 81       	ldd	r24, Y+1	; 0x01
     ed0:	9a 81       	ldd	r25, Y+2	; 0x02
     ed2:	82 17       	cp	r24, r18
     ed4:	93 07       	cpc	r25, r19
     ed6:	70 f4       	brcc	.+28     	; 0xef4 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ed8:	80 91 e7 01 	lds	r24, 0x01E7
     edc:	90 91 e8 01 	lds	r25, 0x01E8
     ee0:	20 91 b8 01 	lds	r18, 0x01B8
     ee4:	30 91 b9 01 	lds	r19, 0x01B9
     ee8:	2e 5f       	subi	r18, 0xFE	; 254
     eea:	3f 4f       	sbci	r19, 0xFF	; 255
     eec:	b9 01       	movw	r22, r18
     eee:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <vListInsert>
     ef2:	0d c0       	rjmp	.+26     	; 0xf0e <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ef4:	80 91 e5 01 	lds	r24, 0x01E5
     ef8:	90 91 e6 01 	lds	r25, 0x01E6
     efc:	20 91 b8 01 	lds	r18, 0x01B8
     f00:	30 91 b9 01 	lds	r19, 0x01B9
     f04:	2e 5f       	subi	r18, 0xFE	; 254
     f06:	3f 4f       	sbci	r19, 0xFF	; 255
     f08:	b9 01       	movw	r22, r18
     f0a:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <vListInsert>
	}

	if( pxEventList )
     f0e:	8d 81       	ldd	r24, Y+5	; 0x05
     f10:	9e 81       	ldd	r25, Y+6	; 0x06
     f12:	00 97       	sbiw	r24, 0x00	; 0
     f14:	61 f0       	breq	.+24     	; 0xf2e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     f16:	80 91 b8 01 	lds	r24, 0x01B8
     f1a:	90 91 b9 01 	lds	r25, 0x01B9
     f1e:	9c 01       	movw	r18, r24
     f20:	24 5f       	subi	r18, 0xF4	; 244
     f22:	3f 4f       	sbci	r19, 0xFF	; 255
     f24:	8d 81       	ldd	r24, Y+5	; 0x05
     f26:	9e 81       	ldd	r25, Y+6	; 0x06
     f28:	b9 01       	movw	r22, r18
     f2a:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <vListInsert>
	}
}
     f2e:	26 96       	adiw	r28, 0x06	; 6
     f30:	0f b6       	in	r0, 0x3f	; 63
     f32:	f8 94       	cli
     f34:	de bf       	out	0x3e, r29	; 62
     f36:	0f be       	out	0x3f, r0	; 63
     f38:	cd bf       	out	0x3d, r28	; 61
     f3a:	cf 91       	pop	r28
     f3c:	df 91       	pop	r29
     f3e:	08 95       	ret

00000f40 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     f40:	df 93       	push	r29
     f42:	cf 93       	push	r28
     f44:	00 d0       	rcall	.+0      	; 0xf46 <prvCheckPendingReadyList+0x6>
     f46:	cd b7       	in	r28, 0x3d	; 61
     f48:	de b7       	in	r29, 0x3e	; 62
     f4a:	3a c0       	rjmp	.+116    	; 0xfc0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     f4c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     f4e:	e0 91 ee 01 	lds	r30, 0x01EE
     f52:	f0 91 ef 01 	lds	r31, 0x01EF
     f56:	86 81       	ldd	r24, Z+6	; 0x06
     f58:	97 81       	ldd	r25, Z+7	; 0x07
     f5a:	9a 83       	std	Y+2, r25	; 0x02
     f5c:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     f5e:	89 81       	ldd	r24, Y+1	; 0x01
     f60:	9a 81       	ldd	r25, Y+2	; 0x02
     f62:	0c 96       	adiw	r24, 0x0c	; 12
     f64:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     f68:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     f6a:	89 81       	ldd	r24, Y+1	; 0x01
     f6c:	9a 81       	ldd	r25, Y+2	; 0x02
     f6e:	02 96       	adiw	r24, 0x02	; 2
     f70:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     f74:	e9 81       	ldd	r30, Y+1	; 0x01
     f76:	fa 81       	ldd	r31, Y+2	; 0x02
     f78:	96 89       	ldd	r25, Z+22	; 0x16
     f7a:	80 91 ba 01 	lds	r24, 0x01BA
     f7e:	89 17       	cp	r24, r25
     f80:	28 f4       	brcc	.+10     	; 0xf8c <prvCheckPendingReadyList+0x4c>
     f82:	e9 81       	ldd	r30, Y+1	; 0x01
     f84:	fa 81       	ldd	r31, Y+2	; 0x02
     f86:	86 89       	ldd	r24, Z+22	; 0x16
     f88:	80 93 ba 01 	sts	0x01BA, r24
     f8c:	e9 81       	ldd	r30, Y+1	; 0x01
     f8e:	fa 81       	ldd	r31, Y+2	; 0x02
     f90:	86 89       	ldd	r24, Z+22	; 0x16
     f92:	28 2f       	mov	r18, r24
     f94:	30 e0       	ldi	r19, 0x00	; 0
     f96:	c9 01       	movw	r24, r18
     f98:	88 0f       	add	r24, r24
     f9a:	99 1f       	adc	r25, r25
     f9c:	88 0f       	add	r24, r24
     f9e:	99 1f       	adc	r25, r25
     fa0:	88 0f       	add	r24, r24
     fa2:	99 1f       	adc	r25, r25
     fa4:	82 0f       	add	r24, r18
     fa6:	93 1f       	adc	r25, r19
     fa8:	ac 01       	movw	r20, r24
     faa:	4f 53       	subi	r20, 0x3F	; 63
     fac:	5e 4f       	sbci	r21, 0xFE	; 254
     fae:	89 81       	ldd	r24, Y+1	; 0x01
     fb0:	9a 81       	ldd	r25, Y+2	; 0x02
     fb2:	9c 01       	movw	r18, r24
     fb4:	2e 5f       	subi	r18, 0xFE	; 254
     fb6:	3f 4f       	sbci	r19, 0xFF	; 255
     fb8:	ca 01       	movw	r24, r20
     fba:	b9 01       	movw	r22, r18
     fbc:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     fc0:	80 91 e9 01 	lds	r24, 0x01E9
     fc4:	88 23       	and	r24, r24
     fc6:	09 f0       	breq	.+2      	; 0xfca <prvCheckPendingReadyList+0x8a>
     fc8:	c1 cf       	rjmp	.-126    	; 0xf4c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     fca:	0f 90       	pop	r0
     fcc:	0f 90       	pop	r0
     fce:	cf 91       	pop	r28
     fd0:	df 91       	pop	r29
     fd2:	08 95       	ret

00000fd4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     fd4:	df 93       	push	r29
     fd6:	cf 93       	push	r28
     fd8:	00 d0       	rcall	.+0      	; 0xfda <prvCheckDelayedList+0x6>
     fda:	00 d0       	rcall	.+0      	; 0xfdc <prvCheckDelayedList+0x8>
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     fe0:	0e 94 8f 1c 	call	0x391e	; 0x391e <xTaskGetTickCount>
     fe4:	20 91 bd 01 	lds	r18, 0x01BD
     fe8:	30 91 be 01 	lds	r19, 0x01BE
     fec:	82 1b       	sub	r24, r18
     fee:	93 0b       	sbc	r25, r19
     ff0:	90 93 c0 01 	sts	0x01C0, r25
     ff4:	80 93 bf 01 	sts	0x01BF, r24
     ff8:	85 c0       	rjmp	.+266    	; 0x1104 <__stack+0x5>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     ffa:	80 91 bb 01 	lds	r24, 0x01BB
     ffe:	90 91 bc 01 	lds	r25, 0x01BC
    1002:	01 96       	adiw	r24, 0x01	; 1
    1004:	90 93 bc 01 	sts	0x01BC, r25
    1008:	80 93 bb 01 	sts	0x01BB, r24
		xPassedTicks--;
    100c:	80 91 bf 01 	lds	r24, 0x01BF
    1010:	90 91 c0 01 	lds	r25, 0x01C0
    1014:	01 97       	sbiw	r24, 0x01	; 1
    1016:	90 93 c0 01 	sts	0x01C0, r25
    101a:	80 93 bf 01 	sts	0x01BF, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    101e:	80 91 bb 01 	lds	r24, 0x01BB
    1022:	90 91 bc 01 	lds	r25, 0x01BC
    1026:	00 97       	sbiw	r24, 0x00	; 0
    1028:	09 f0       	breq	.+2      	; 0x102c <prvCheckDelayedList+0x58>
    102a:	64 c0       	rjmp	.+200    	; 0x10f4 <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    102c:	80 91 e5 01 	lds	r24, 0x01E5
    1030:	90 91 e6 01 	lds	r25, 0x01E6
    1034:	9a 83       	std	Y+2, r25	; 0x02
    1036:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1038:	80 91 e7 01 	lds	r24, 0x01E7
    103c:	90 91 e8 01 	lds	r25, 0x01E8
    1040:	90 93 e6 01 	sts	0x01E6, r25
    1044:	80 93 e5 01 	sts	0x01E5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1048:	89 81       	ldd	r24, Y+1	; 0x01
    104a:	9a 81       	ldd	r25, Y+2	; 0x02
    104c:	90 93 e8 01 	sts	0x01E8, r25
    1050:	80 93 e7 01 	sts	0x01E7, r24
    1054:	4f c0       	rjmp	.+158    	; 0x10f4 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1056:	e0 91 e5 01 	lds	r30, 0x01E5
    105a:	f0 91 e6 01 	lds	r31, 0x01E6
    105e:	05 80       	ldd	r0, Z+5	; 0x05
    1060:	f6 81       	ldd	r31, Z+6	; 0x06
    1062:	e0 2d       	mov	r30, r0
    1064:	86 81       	ldd	r24, Z+6	; 0x06
    1066:	97 81       	ldd	r25, Z+7	; 0x07
    1068:	9c 83       	std	Y+4, r25	; 0x04
    106a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    106c:	eb 81       	ldd	r30, Y+3	; 0x03
    106e:	fc 81       	ldd	r31, Y+4	; 0x04
    1070:	22 81       	ldd	r18, Z+2	; 0x02
    1072:	33 81       	ldd	r19, Z+3	; 0x03
    1074:	80 91 bb 01 	lds	r24, 0x01BB
    1078:	90 91 bc 01 	lds	r25, 0x01BC
    107c:	82 17       	cp	r24, r18
    107e:	93 07       	cpc	r25, r19
    1080:	08 f4       	brcc	.+2      	; 0x1084 <prvCheckDelayedList+0xb0>
    1082:	40 c0       	rjmp	.+128    	; 0x1104 <__stack+0x5>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1084:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	9c 81       	ldd	r25, Y+4	; 0x04
    108a:	02 96       	adiw	r24, 0x02	; 2
    108c:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    1090:	eb 81       	ldd	r30, Y+3	; 0x03
    1092:	fc 81       	ldd	r31, Y+4	; 0x04
    1094:	84 89       	ldd	r24, Z+20	; 0x14
    1096:	95 89       	ldd	r25, Z+21	; 0x15
    1098:	00 97       	sbiw	r24, 0x00	; 0
    109a:	29 f0       	breq	.+10     	; 0x10a6 <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    109c:	8b 81       	ldd	r24, Y+3	; 0x03
    109e:	9c 81       	ldd	r25, Y+4	; 0x04
    10a0:	0c 96       	adiw	r24, 0x0c	; 12
    10a2:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    10a6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    10a8:	eb 81       	ldd	r30, Y+3	; 0x03
    10aa:	fc 81       	ldd	r31, Y+4	; 0x04
    10ac:	96 89       	ldd	r25, Z+22	; 0x16
    10ae:	80 91 ba 01 	lds	r24, 0x01BA
    10b2:	89 17       	cp	r24, r25
    10b4:	28 f4       	brcc	.+10     	; 0x10c0 <prvCheckDelayedList+0xec>
    10b6:	eb 81       	ldd	r30, Y+3	; 0x03
    10b8:	fc 81       	ldd	r31, Y+4	; 0x04
    10ba:	86 89       	ldd	r24, Z+22	; 0x16
    10bc:	80 93 ba 01 	sts	0x01BA, r24
    10c0:	eb 81       	ldd	r30, Y+3	; 0x03
    10c2:	fc 81       	ldd	r31, Y+4	; 0x04
    10c4:	86 89       	ldd	r24, Z+22	; 0x16
    10c6:	28 2f       	mov	r18, r24
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	c9 01       	movw	r24, r18
    10cc:	88 0f       	add	r24, r24
    10ce:	99 1f       	adc	r25, r25
    10d0:	88 0f       	add	r24, r24
    10d2:	99 1f       	adc	r25, r25
    10d4:	88 0f       	add	r24, r24
    10d6:	99 1f       	adc	r25, r25
    10d8:	82 0f       	add	r24, r18
    10da:	93 1f       	adc	r25, r19
    10dc:	ac 01       	movw	r20, r24
    10de:	4f 53       	subi	r20, 0x3F	; 63
    10e0:	5e 4f       	sbci	r21, 0xFE	; 254
    10e2:	8b 81       	ldd	r24, Y+3	; 0x03
    10e4:	9c 81       	ldd	r25, Y+4	; 0x04
    10e6:	9c 01       	movw	r18, r24
    10e8:	2e 5f       	subi	r18, 0xFE	; 254
    10ea:	3f 4f       	sbci	r19, 0xFF	; 255
    10ec:	ca 01       	movw	r24, r20
    10ee:	b9 01       	movw	r22, r18
    10f0:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    10f4:	e0 91 e5 01 	lds	r30, 0x01E5
    10f8:	f0 91 e6 01 	lds	r31, 0x01E6
    10fc:	80 81       	ld	r24, Z
    10fe:	88 23       	and	r24, r24
    1100:	09 f0       	breq	.+2      	; 0x1104 <__stack+0x5>
    1102:	a9 cf       	rjmp	.-174    	; 0x1056 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1104:	80 91 bf 01 	lds	r24, 0x01BF
    1108:	90 91 c0 01 	lds	r25, 0x01C0
    110c:	00 97       	sbiw	r24, 0x00	; 0
    110e:	09 f0       	breq	.+2      	; 0x1112 <__stack+0x13>
    1110:	74 cf       	rjmp	.-280    	; 0xffa <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1112:	80 91 bb 01 	lds	r24, 0x01BB
    1116:	90 91 bc 01 	lds	r25, 0x01BC
    111a:	90 93 be 01 	sts	0x01BE, r25
    111e:	80 93 bd 01 	sts	0x01BD, r24
}
    1122:	0f 90       	pop	r0
    1124:	0f 90       	pop	r0
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	cf 91       	pop	r28
    112c:	df 91       	pop	r29
    112e:	08 95       	ret

00001130 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1130:	df 93       	push	r29
    1132:	cf 93       	push	r28
    1134:	00 d0       	rcall	.+0      	; 0x1136 <vCoRoutineSchedule+0x6>
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    113a:	0e 94 a0 07 	call	0xf40	; 0xf40 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    113e:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <prvCheckDelayedList>
    1142:	0a c0       	rjmp	.+20     	; 0x1158 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1144:	80 91 ba 01 	lds	r24, 0x01BA
    1148:	88 23       	and	r24, r24
    114a:	09 f4       	brne	.+2      	; 0x114e <vCoRoutineSchedule+0x1e>
    114c:	66 c0       	rjmp	.+204    	; 0x121a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    114e:	80 91 ba 01 	lds	r24, 0x01BA
    1152:	81 50       	subi	r24, 0x01	; 1
    1154:	80 93 ba 01 	sts	0x01BA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1158:	80 91 ba 01 	lds	r24, 0x01BA
    115c:	28 2f       	mov	r18, r24
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	c9 01       	movw	r24, r18
    1162:	88 0f       	add	r24, r24
    1164:	99 1f       	adc	r25, r25
    1166:	88 0f       	add	r24, r24
    1168:	99 1f       	adc	r25, r25
    116a:	88 0f       	add	r24, r24
    116c:	99 1f       	adc	r25, r25
    116e:	82 0f       	add	r24, r18
    1170:	93 1f       	adc	r25, r19
    1172:	fc 01       	movw	r30, r24
    1174:	ef 53       	subi	r30, 0x3F	; 63
    1176:	fe 4f       	sbci	r31, 0xFE	; 254
    1178:	80 81       	ld	r24, Z
    117a:	88 23       	and	r24, r24
    117c:	19 f3       	breq	.-58     	; 0x1144 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    117e:	80 91 ba 01 	lds	r24, 0x01BA
    1182:	28 2f       	mov	r18, r24
    1184:	30 e0       	ldi	r19, 0x00	; 0
    1186:	c9 01       	movw	r24, r18
    1188:	88 0f       	add	r24, r24
    118a:	99 1f       	adc	r25, r25
    118c:	88 0f       	add	r24, r24
    118e:	99 1f       	adc	r25, r25
    1190:	88 0f       	add	r24, r24
    1192:	99 1f       	adc	r25, r25
    1194:	82 0f       	add	r24, r18
    1196:	93 1f       	adc	r25, r19
    1198:	8f 53       	subi	r24, 0x3F	; 63
    119a:	9e 4f       	sbci	r25, 0xFE	; 254
    119c:	9a 83       	std	Y+2, r25	; 0x02
    119e:	89 83       	std	Y+1, r24	; 0x01
    11a0:	e9 81       	ldd	r30, Y+1	; 0x01
    11a2:	fa 81       	ldd	r31, Y+2	; 0x02
    11a4:	01 80       	ldd	r0, Z+1	; 0x01
    11a6:	f2 81       	ldd	r31, Z+2	; 0x02
    11a8:	e0 2d       	mov	r30, r0
    11aa:	82 81       	ldd	r24, Z+2	; 0x02
    11ac:	93 81       	ldd	r25, Z+3	; 0x03
    11ae:	e9 81       	ldd	r30, Y+1	; 0x01
    11b0:	fa 81       	ldd	r31, Y+2	; 0x02
    11b2:	92 83       	std	Z+2, r25	; 0x02
    11b4:	81 83       	std	Z+1, r24	; 0x01
    11b6:	e9 81       	ldd	r30, Y+1	; 0x01
    11b8:	fa 81       	ldd	r31, Y+2	; 0x02
    11ba:	21 81       	ldd	r18, Z+1	; 0x01
    11bc:	32 81       	ldd	r19, Z+2	; 0x02
    11be:	89 81       	ldd	r24, Y+1	; 0x01
    11c0:	9a 81       	ldd	r25, Y+2	; 0x02
    11c2:	03 96       	adiw	r24, 0x03	; 3
    11c4:	28 17       	cp	r18, r24
    11c6:	39 07       	cpc	r19, r25
    11c8:	59 f4       	brne	.+22     	; 0x11e0 <vCoRoutineSchedule+0xb0>
    11ca:	e9 81       	ldd	r30, Y+1	; 0x01
    11cc:	fa 81       	ldd	r31, Y+2	; 0x02
    11ce:	01 80       	ldd	r0, Z+1	; 0x01
    11d0:	f2 81       	ldd	r31, Z+2	; 0x02
    11d2:	e0 2d       	mov	r30, r0
    11d4:	82 81       	ldd	r24, Z+2	; 0x02
    11d6:	93 81       	ldd	r25, Z+3	; 0x03
    11d8:	e9 81       	ldd	r30, Y+1	; 0x01
    11da:	fa 81       	ldd	r31, Y+2	; 0x02
    11dc:	92 83       	std	Z+2, r25	; 0x02
    11de:	81 83       	std	Z+1, r24	; 0x01
    11e0:	e9 81       	ldd	r30, Y+1	; 0x01
    11e2:	fa 81       	ldd	r31, Y+2	; 0x02
    11e4:	01 80       	ldd	r0, Z+1	; 0x01
    11e6:	f2 81       	ldd	r31, Z+2	; 0x02
    11e8:	e0 2d       	mov	r30, r0
    11ea:	86 81       	ldd	r24, Z+6	; 0x06
    11ec:	97 81       	ldd	r25, Z+7	; 0x07
    11ee:	90 93 b9 01 	sts	0x01B9, r25
    11f2:	80 93 b8 01 	sts	0x01B8, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    11f6:	e0 91 b8 01 	lds	r30, 0x01B8
    11fa:	f0 91 b9 01 	lds	r31, 0x01B9
    11fe:	40 81       	ld	r20, Z
    1200:	51 81       	ldd	r21, Z+1	; 0x01
    1202:	80 91 b8 01 	lds	r24, 0x01B8
    1206:	90 91 b9 01 	lds	r25, 0x01B9
    120a:	e0 91 b8 01 	lds	r30, 0x01B8
    120e:	f0 91 b9 01 	lds	r31, 0x01B9
    1212:	27 89       	ldd	r18, Z+23	; 0x17
    1214:	62 2f       	mov	r22, r18
    1216:	fa 01       	movw	r30, r20
    1218:	09 95       	icall

	return;
}
    121a:	0f 90       	pop	r0
    121c:	0f 90       	pop	r0
    121e:	cf 91       	pop	r28
    1220:	df 91       	pop	r29
    1222:	08 95       	ret

00001224 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    1224:	df 93       	push	r29
    1226:	cf 93       	push	r28
    1228:	0f 92       	push	r0
    122a:	cd b7       	in	r28, 0x3d	; 61
    122c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    122e:	19 82       	std	Y+1, r1	; 0x01
    1230:	13 c0       	rjmp	.+38     	; 0x1258 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1232:	89 81       	ldd	r24, Y+1	; 0x01
    1234:	28 2f       	mov	r18, r24
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	c9 01       	movw	r24, r18
    123a:	88 0f       	add	r24, r24
    123c:	99 1f       	adc	r25, r25
    123e:	88 0f       	add	r24, r24
    1240:	99 1f       	adc	r25, r25
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	82 0f       	add	r24, r18
    1248:	93 1f       	adc	r25, r19
    124a:	8f 53       	subi	r24, 0x3F	; 63
    124c:	9e 4f       	sbci	r25, 0xFE	; 254
    124e:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1252:	89 81       	ldd	r24, Y+1	; 0x01
    1254:	8f 5f       	subi	r24, 0xFF	; 255
    1256:	89 83       	std	Y+1, r24	; 0x01
    1258:	89 81       	ldd	r24, Y+1	; 0x01
    125a:	82 30       	cpi	r24, 0x02	; 2
    125c:	50 f3       	brcs	.-44     	; 0x1232 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    125e:	83 ed       	ldi	r24, 0xD3	; 211
    1260:	91 e0       	ldi	r25, 0x01	; 1
    1262:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1266:	8c ed       	ldi	r24, 0xDC	; 220
    1268:	91 e0       	ldi	r25, 0x01	; 1
    126a:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    126e:	89 ee       	ldi	r24, 0xE9	; 233
    1270:	91 e0       	ldi	r25, 0x01	; 1
    1272:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1276:	83 ed       	ldi	r24, 0xD3	; 211
    1278:	91 e0       	ldi	r25, 0x01	; 1
    127a:	90 93 e6 01 	sts	0x01E6, r25
    127e:	80 93 e5 01 	sts	0x01E5, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1282:	8c ed       	ldi	r24, 0xDC	; 220
    1284:	91 e0       	ldi	r25, 0x01	; 1
    1286:	90 93 e8 01 	sts	0x01E8, r25
    128a:	80 93 e7 01 	sts	0x01E7, r24
}
    128e:	0f 90       	pop	r0
    1290:	cf 91       	pop	r28
    1292:	df 91       	pop	r29
    1294:	08 95       	ret

00001296 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1296:	df 93       	push	r29
    1298:	cf 93       	push	r28
    129a:	00 d0       	rcall	.+0      	; 0x129c <xCoRoutineRemoveFromEventList+0x6>
    129c:	00 d0       	rcall	.+0      	; 0x129e <xCoRoutineRemoveFromEventList+0x8>
    129e:	0f 92       	push	r0
    12a0:	cd b7       	in	r28, 0x3d	; 61
    12a2:	de b7       	in	r29, 0x3e	; 62
    12a4:	9d 83       	std	Y+5, r25	; 0x05
    12a6:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    12a8:	ec 81       	ldd	r30, Y+4	; 0x04
    12aa:	fd 81       	ldd	r31, Y+5	; 0x05
    12ac:	05 80       	ldd	r0, Z+5	; 0x05
    12ae:	f6 81       	ldd	r31, Z+6	; 0x06
    12b0:	e0 2d       	mov	r30, r0
    12b2:	86 81       	ldd	r24, Z+6	; 0x06
    12b4:	97 81       	ldd	r25, Z+7	; 0x07
    12b6:	9b 83       	std	Y+3, r25	; 0x03
    12b8:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    12ba:	8a 81       	ldd	r24, Y+2	; 0x02
    12bc:	9b 81       	ldd	r25, Y+3	; 0x03
    12be:	0c 96       	adiw	r24, 0x0c	; 12
    12c0:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    12c4:	8a 81       	ldd	r24, Y+2	; 0x02
    12c6:	9b 81       	ldd	r25, Y+3	; 0x03
    12c8:	9c 01       	movw	r18, r24
    12ca:	24 5f       	subi	r18, 0xF4	; 244
    12cc:	3f 4f       	sbci	r19, 0xFF	; 255
    12ce:	89 ee       	ldi	r24, 0xE9	; 233
    12d0:	91 e0       	ldi	r25, 0x01	; 1
    12d2:	b9 01       	movw	r22, r18
    12d4:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    12d8:	ea 81       	ldd	r30, Y+2	; 0x02
    12da:	fb 81       	ldd	r31, Y+3	; 0x03
    12dc:	96 89       	ldd	r25, Z+22	; 0x16
    12de:	e0 91 b8 01 	lds	r30, 0x01B8
    12e2:	f0 91 b9 01 	lds	r31, 0x01B9
    12e6:	86 89       	ldd	r24, Z+22	; 0x16
    12e8:	98 17       	cp	r25, r24
    12ea:	18 f0       	brcs	.+6      	; 0x12f2 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	89 83       	std	Y+1, r24	; 0x01
    12f0:	01 c0       	rjmp	.+2      	; 0x12f4 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    12f2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    12f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    12f6:	0f 90       	pop	r0
    12f8:	0f 90       	pop	r0
    12fa:	0f 90       	pop	r0
    12fc:	0f 90       	pop	r0
    12fe:	0f 90       	pop	r0
    1300:	cf 91       	pop	r28
    1302:	df 91       	pop	r29
    1304:	08 95       	ret

00001306 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    1306:	df 93       	push	r29
    1308:	cf 93       	push	r28
    130a:	00 d0       	rcall	.+0      	; 0x130c <xEventGroupCreate+0x6>
    130c:	cd b7       	in	r28, 0x3d	; 61
    130e:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    1310:	8b e0       	ldi	r24, 0x0B	; 11
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	0e 94 c3 0c 	call	0x1986	; 0x1986 <pvPortMalloc>
    1318:	9a 83       	std	Y+2, r25	; 0x02
    131a:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    131c:	89 81       	ldd	r24, Y+1	; 0x01
    131e:	9a 81       	ldd	r25, Y+2	; 0x02
    1320:	00 97       	sbiw	r24, 0x00	; 0
    1322:	49 f0       	breq	.+18     	; 0x1336 <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    1324:	e9 81       	ldd	r30, Y+1	; 0x01
    1326:	fa 81       	ldd	r31, Y+2	; 0x02
    1328:	11 82       	std	Z+1, r1	; 0x01
    132a:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    132c:	89 81       	ldd	r24, Y+1	; 0x01
    132e:	9a 81       	ldd	r25, Y+2	; 0x02
    1330:	02 96       	adiw	r24, 0x02	; 2
    1332:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    1336:	89 81       	ldd	r24, Y+1	; 0x01
    1338:	9a 81       	ldd	r25, Y+2	; 0x02
}
    133a:	0f 90       	pop	r0
    133c:	0f 90       	pop	r0
    133e:	cf 91       	pop	r28
    1340:	df 91       	pop	r29
    1342:	08 95       	ret

00001344 <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1344:	df 93       	push	r29
    1346:	cf 93       	push	r28
    1348:	cd b7       	in	r28, 0x3d	; 61
    134a:	de b7       	in	r29, 0x3e	; 62
    134c:	60 97       	sbiw	r28, 0x10	; 16
    134e:	0f b6       	in	r0, 0x3f	; 63
    1350:	f8 94       	cli
    1352:	de bf       	out	0x3e, r29	; 62
    1354:	0f be       	out	0x3f, r0	; 63
    1356:	cd bf       	out	0x3d, r28	; 61
    1358:	9a 87       	std	Y+10, r25	; 0x0a
    135a:	89 87       	std	Y+9, r24	; 0x09
    135c:	7c 87       	std	Y+12, r23	; 0x0c
    135e:	6b 87       	std	Y+11, r22	; 0x0b
    1360:	5e 87       	std	Y+14, r21	; 0x0e
    1362:	4d 87       	std	Y+13, r20	; 0x0d
    1364:	38 8b       	std	Y+16, r19	; 0x10
    1366:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1368:	89 85       	ldd	r24, Y+9	; 0x09
    136a:	9a 85       	ldd	r25, Y+10	; 0x0a
    136c:	9c 83       	std	Y+4, r25	; 0x04
    136e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1370:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1372:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1376:	eb 81       	ldd	r30, Y+3	; 0x03
    1378:	fc 81       	ldd	r31, Y+4	; 0x04
    137a:	80 81       	ld	r24, Z
    137c:	91 81       	ldd	r25, Z+1	; 0x01
    137e:	98 87       	std	Y+8, r25	; 0x08
    1380:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1382:	89 85       	ldd	r24, Y+9	; 0x09
    1384:	9a 85       	ldd	r25, Y+10	; 0x0a
    1386:	2b 85       	ldd	r18, Y+11	; 0x0b
    1388:	3c 85       	ldd	r19, Y+12	; 0x0c
    138a:	b9 01       	movw	r22, r18
    138c:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1390:	2f 81       	ldd	r18, Y+7	; 0x07
    1392:	38 85       	ldd	r19, Y+8	; 0x08
    1394:	8b 85       	ldd	r24, Y+11	; 0x0b
    1396:	9c 85       	ldd	r25, Y+12	; 0x0c
    1398:	28 2b       	or	r18, r24
    139a:	39 2b       	or	r19, r25
    139c:	8d 85       	ldd	r24, Y+13	; 0x0d
    139e:	9e 85       	ldd	r25, Y+14	; 0x0e
    13a0:	28 23       	and	r18, r24
    13a2:	39 23       	and	r19, r25
    13a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    13a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    13a8:	28 17       	cp	r18, r24
    13aa:	39 07       	cpc	r19, r25
    13ac:	c9 f4       	brne	.+50     	; 0x13e0 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    13ae:	2f 81       	ldd	r18, Y+7	; 0x07
    13b0:	38 85       	ldd	r19, Y+8	; 0x08
    13b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    13b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    13b6:	82 2b       	or	r24, r18
    13b8:	93 2b       	or	r25, r19
    13ba:	9e 83       	std	Y+6, r25	; 0x06
    13bc:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    13be:	eb 81       	ldd	r30, Y+3	; 0x03
    13c0:	fc 81       	ldd	r31, Y+4	; 0x04
    13c2:	20 81       	ld	r18, Z
    13c4:	31 81       	ldd	r19, Z+1	; 0x01
    13c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    13c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    13ca:	80 95       	com	r24
    13cc:	90 95       	com	r25
    13ce:	82 23       	and	r24, r18
    13d0:	93 23       	and	r25, r19
    13d2:	eb 81       	ldd	r30, Y+3	; 0x03
    13d4:	fc 81       	ldd	r31, Y+4	; 0x04
    13d6:	91 83       	std	Z+1, r25	; 0x01
    13d8:	80 83       	st	Z, r24

			xTicksToWait = 0;
    13da:	18 8a       	std	Y+16, r1	; 0x10
    13dc:	1f 86       	std	Y+15, r1	; 0x0f
    13de:	1c c0       	rjmp	.+56     	; 0x1418 <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    13e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    13e2:	98 89       	ldd	r25, Y+16	; 0x10
    13e4:	00 97       	sbiw	r24, 0x00	; 0
    13e6:	91 f0       	breq	.+36     	; 0x140c <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    13e8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ea:	9c 81       	ldd	r25, Y+4	; 0x04
    13ec:	bc 01       	movw	r22, r24
    13ee:	6e 5f       	subi	r22, 0xFE	; 254
    13f0:	7f 4f       	sbci	r23, 0xFF	; 255
    13f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    13f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    13f6:	9c 01       	movw	r18, r24
    13f8:	35 60       	ori	r19, 0x05	; 5
    13fa:	4f 85       	ldd	r20, Y+15	; 0x0f
    13fc:	58 89       	ldd	r21, Y+16	; 0x10
    13fe:	cb 01       	movw	r24, r22
    1400:	b9 01       	movw	r22, r18
    1402:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1406:	1e 82       	std	Y+6, r1	; 0x06
    1408:	1d 82       	std	Y+5, r1	; 0x05
    140a:	06 c0       	rjmp	.+12     	; 0x1418 <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    140c:	eb 81       	ldd	r30, Y+3	; 0x03
    140e:	fc 81       	ldd	r31, Y+4	; 0x04
    1410:	80 81       	ld	r24, Z
    1412:	91 81       	ldd	r25, Z+1	; 0x01
    1414:	9e 83       	std	Y+6, r25	; 0x06
    1416:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1418:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    141c:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    141e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1420:	98 89       	ldd	r25, Y+16	; 0x10
    1422:	00 97       	sbiw	r24, 0x00	; 0
    1424:	09 f4       	brne	.+2      	; 0x1428 <xEventGroupSync+0xe4>
    1426:	3a c0       	rjmp	.+116    	; 0x149c <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    1428:	8a 81       	ldd	r24, Y+2	; 0x02
    142a:	88 23       	and	r24, r24
    142c:	11 f4       	brne	.+4      	; 0x1432 <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    142e:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1432:	0e 94 c5 22 	call	0x458a	; 0x458a <uxTaskResetEventItemValue>
    1436:	9e 83       	std	Y+6, r25	; 0x06
    1438:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    143a:	8d 81       	ldd	r24, Y+5	; 0x05
    143c:	9e 81       	ldd	r25, Y+6	; 0x06
    143e:	80 70       	andi	r24, 0x00	; 0
    1440:	92 70       	andi	r25, 0x02	; 2
    1442:	00 97       	sbiw	r24, 0x00	; 0
    1444:	31 f5       	brne	.+76     	; 0x1492 <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1446:	0f b6       	in	r0, 0x3f	; 63
    1448:	f8 94       	cli
    144a:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    144c:	eb 81       	ldd	r30, Y+3	; 0x03
    144e:	fc 81       	ldd	r31, Y+4	; 0x04
    1450:	80 81       	ld	r24, Z
    1452:	91 81       	ldd	r25, Z+1	; 0x01
    1454:	9e 83       	std	Y+6, r25	; 0x06
    1456:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1458:	2d 81       	ldd	r18, Y+5	; 0x05
    145a:	3e 81       	ldd	r19, Y+6	; 0x06
    145c:	8d 85       	ldd	r24, Y+13	; 0x0d
    145e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1460:	28 23       	and	r18, r24
    1462:	39 23       	and	r19, r25
    1464:	8d 85       	ldd	r24, Y+13	; 0x0d
    1466:	9e 85       	ldd	r25, Y+14	; 0x0e
    1468:	28 17       	cp	r18, r24
    146a:	39 07       	cpc	r19, r25
    146c:	71 f4       	brne	.+28     	; 0x148a <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    146e:	eb 81       	ldd	r30, Y+3	; 0x03
    1470:	fc 81       	ldd	r31, Y+4	; 0x04
    1472:	20 81       	ld	r18, Z
    1474:	31 81       	ldd	r19, Z+1	; 0x01
    1476:	8d 85       	ldd	r24, Y+13	; 0x0d
    1478:	9e 85       	ldd	r25, Y+14	; 0x0e
    147a:	80 95       	com	r24
    147c:	90 95       	com	r25
    147e:	82 23       	and	r24, r18
    1480:	93 23       	and	r25, r19
    1482:	eb 81       	ldd	r30, Y+3	; 0x03
    1484:	fc 81       	ldd	r31, Y+4	; 0x04
    1486:	91 83       	std	Z+1, r25	; 0x01
    1488:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    148a:	0f 90       	pop	r0
    148c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1492:	8d 81       	ldd	r24, Y+5	; 0x05
    1494:	9e 81       	ldd	r25, Y+6	; 0x06
    1496:	90 70       	andi	r25, 0x00	; 0
    1498:	9e 83       	std	Y+6, r25	; 0x06
    149a:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    149c:	8d 81       	ldd	r24, Y+5	; 0x05
    149e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    14a0:	60 96       	adiw	r28, 0x10	; 16
    14a2:	0f b6       	in	r0, 0x3f	; 63
    14a4:	f8 94       	cli
    14a6:	de bf       	out	0x3e, r29	; 62
    14a8:	0f be       	out	0x3f, r0	; 63
    14aa:	cd bf       	out	0x3d, r28	; 61
    14ac:	cf 91       	pop	r28
    14ae:	df 91       	pop	r29
    14b0:	08 95       	ret

000014b2 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    14b2:	0f 93       	push	r16
    14b4:	1f 93       	push	r17
    14b6:	df 93       	push	r29
    14b8:	cf 93       	push	r28
    14ba:	cd b7       	in	r28, 0x3d	; 61
    14bc:	de b7       	in	r29, 0x3e	; 62
    14be:	63 97       	sbiw	r28, 0x13	; 19
    14c0:	0f b6       	in	r0, 0x3f	; 63
    14c2:	f8 94       	cli
    14c4:	de bf       	out	0x3e, r29	; 62
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	cd bf       	out	0x3d, r28	; 61
    14ca:	9d 87       	std	Y+13, r25	; 0x0d
    14cc:	8c 87       	std	Y+12, r24	; 0x0c
    14ce:	7f 87       	std	Y+15, r23	; 0x0f
    14d0:	6e 87       	std	Y+14, r22	; 0x0e
    14d2:	48 8b       	std	Y+16, r20	; 0x10
    14d4:	29 8b       	std	Y+17, r18	; 0x11
    14d6:	1b 8b       	std	Y+19, r17	; 0x13
    14d8:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    14da:	8c 85       	ldd	r24, Y+12	; 0x0c
    14dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    14de:	9b 87       	std	Y+11, r25	; 0x0b
    14e0:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    14e2:	1f 82       	std	Y+7, r1	; 0x07
    14e4:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    14e6:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    14e8:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    14ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    14ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    14f0:	80 81       	ld	r24, Z
    14f2:	91 81       	ldd	r25, Z+1	; 0x01
    14f4:	9a 83       	std	Y+2, r25	; 0x02
    14f6:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    14f8:	89 81       	ldd	r24, Y+1	; 0x01
    14fa:	9a 81       	ldd	r25, Y+2	; 0x02
    14fc:	2e 85       	ldd	r18, Y+14	; 0x0e
    14fe:	3f 85       	ldd	r19, Y+15	; 0x0f
    1500:	b9 01       	movw	r22, r18
    1502:	49 89       	ldd	r20, Y+17	; 0x11
    1504:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvTestWaitCondition>
    1508:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    150a:	8d 81       	ldd	r24, Y+5	; 0x05
    150c:	88 23       	and	r24, r24
    150e:	c1 f0       	breq	.+48     	; 0x1540 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    1510:	89 81       	ldd	r24, Y+1	; 0x01
    1512:	9a 81       	ldd	r25, Y+2	; 0x02
    1514:	99 87       	std	Y+9, r25	; 0x09
    1516:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    1518:	1b 8a       	std	Y+19, r1	; 0x13
    151a:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    151c:	88 89       	ldd	r24, Y+16	; 0x10
    151e:	88 23       	and	r24, r24
    1520:	d9 f1       	breq	.+118    	; 0x1598 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1522:	ea 85       	ldd	r30, Y+10	; 0x0a
    1524:	fb 85       	ldd	r31, Y+11	; 0x0b
    1526:	20 81       	ld	r18, Z
    1528:	31 81       	ldd	r19, Z+1	; 0x01
    152a:	8e 85       	ldd	r24, Y+14	; 0x0e
    152c:	9f 85       	ldd	r25, Y+15	; 0x0f
    152e:	80 95       	com	r24
    1530:	90 95       	com	r25
    1532:	82 23       	and	r24, r18
    1534:	93 23       	and	r25, r19
    1536:	ea 85       	ldd	r30, Y+10	; 0x0a
    1538:	fb 85       	ldd	r31, Y+11	; 0x0b
    153a:	91 83       	std	Z+1, r25	; 0x01
    153c:	80 83       	st	Z, r24
    153e:	2c c0       	rjmp	.+88     	; 0x1598 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1540:	8a 89       	ldd	r24, Y+18	; 0x12
    1542:	9b 89       	ldd	r25, Y+19	; 0x13
    1544:	00 97       	sbiw	r24, 0x00	; 0
    1546:	29 f4       	brne	.+10     	; 0x1552 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    1548:	89 81       	ldd	r24, Y+1	; 0x01
    154a:	9a 81       	ldd	r25, Y+2	; 0x02
    154c:	99 87       	std	Y+9, r25	; 0x09
    154e:	88 87       	std	Y+8, r24	; 0x08
    1550:	23 c0       	rjmp	.+70     	; 0x1598 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1552:	88 89       	ldd	r24, Y+16	; 0x10
    1554:	88 23       	and	r24, r24
    1556:	29 f0       	breq	.+10     	; 0x1562 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1558:	8e 81       	ldd	r24, Y+6	; 0x06
    155a:	9f 81       	ldd	r25, Y+7	; 0x07
    155c:	91 60       	ori	r25, 0x01	; 1
    155e:	9f 83       	std	Y+7, r25	; 0x07
    1560:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1562:	89 89       	ldd	r24, Y+17	; 0x11
    1564:	88 23       	and	r24, r24
    1566:	29 f0       	breq	.+10     	; 0x1572 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1568:	8e 81       	ldd	r24, Y+6	; 0x06
    156a:	9f 81       	ldd	r25, Y+7	; 0x07
    156c:	94 60       	ori	r25, 0x04	; 4
    156e:	9f 83       	std	Y+7, r25	; 0x07
    1570:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1572:	8a 85       	ldd	r24, Y+10	; 0x0a
    1574:	9b 85       	ldd	r25, Y+11	; 0x0b
    1576:	bc 01       	movw	r22, r24
    1578:	6e 5f       	subi	r22, 0xFE	; 254
    157a:	7f 4f       	sbci	r23, 0xFF	; 255
    157c:	2e 85       	ldd	r18, Y+14	; 0x0e
    157e:	3f 85       	ldd	r19, Y+15	; 0x0f
    1580:	8e 81       	ldd	r24, Y+6	; 0x06
    1582:	9f 81       	ldd	r25, Y+7	; 0x07
    1584:	28 2b       	or	r18, r24
    1586:	39 2b       	or	r19, r25
    1588:	4a 89       	ldd	r20, Y+18	; 0x12
    158a:	5b 89       	ldd	r21, Y+19	; 0x13
    158c:	cb 01       	movw	r24, r22
    158e:	b9 01       	movw	r22, r18
    1590:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    1594:	19 86       	std	Y+9, r1	; 0x09
    1596:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1598:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    159c:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    159e:	8a 89       	ldd	r24, Y+18	; 0x12
    15a0:	9b 89       	ldd	r25, Y+19	; 0x13
    15a2:	00 97       	sbiw	r24, 0x00	; 0
    15a4:	09 f4       	brne	.+2      	; 0x15a8 <xEventGroupWaitBits+0xf6>
    15a6:	3b c0       	rjmp	.+118    	; 0x161e <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    15a8:	8c 81       	ldd	r24, Y+4	; 0x04
    15aa:	88 23       	and	r24, r24
    15ac:	11 f4       	brne	.+4      	; 0x15b2 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    15ae:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    15b2:	0e 94 c5 22 	call	0x458a	; 0x458a <uxTaskResetEventItemValue>
    15b6:	99 87       	std	Y+9, r25	; 0x09
    15b8:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    15ba:	88 85       	ldd	r24, Y+8	; 0x08
    15bc:	99 85       	ldd	r25, Y+9	; 0x09
    15be:	80 70       	andi	r24, 0x00	; 0
    15c0:	92 70       	andi	r25, 0x02	; 2
    15c2:	00 97       	sbiw	r24, 0x00	; 0
    15c4:	39 f5       	brne	.+78     	; 0x1614 <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    15cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    15ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    15d0:	80 81       	ld	r24, Z
    15d2:	91 81       	ldd	r25, Z+1	; 0x01
    15d4:	99 87       	std	Y+9, r25	; 0x09
    15d6:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    15d8:	88 85       	ldd	r24, Y+8	; 0x08
    15da:	99 85       	ldd	r25, Y+9	; 0x09
    15dc:	2e 85       	ldd	r18, Y+14	; 0x0e
    15de:	3f 85       	ldd	r19, Y+15	; 0x0f
    15e0:	b9 01       	movw	r22, r18
    15e2:	49 89       	ldd	r20, Y+17	; 0x11
    15e4:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvTestWaitCondition>
    15e8:	88 23       	and	r24, r24
    15ea:	89 f0       	breq	.+34     	; 0x160e <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    15ec:	88 89       	ldd	r24, Y+16	; 0x10
    15ee:	88 23       	and	r24, r24
    15f0:	71 f0       	breq	.+28     	; 0x160e <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    15f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    15f6:	20 81       	ld	r18, Z
    15f8:	31 81       	ldd	r19, Z+1	; 0x01
    15fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    15fc:	9f 85       	ldd	r25, Y+15	; 0x0f
    15fe:	80 95       	com	r24
    1600:	90 95       	com	r25
    1602:	82 23       	and	r24, r18
    1604:	93 23       	and	r25, r19
    1606:	ea 85       	ldd	r30, Y+10	; 0x0a
    1608:	fb 85       	ldd	r31, Y+11	; 0x0b
    160a:	91 83       	std	Z+1, r25	; 0x01
    160c:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    160e:	0f 90       	pop	r0
    1610:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    1612:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1614:	88 85       	ldd	r24, Y+8	; 0x08
    1616:	99 85       	ldd	r25, Y+9	; 0x09
    1618:	90 70       	andi	r25, 0x00	; 0
    161a:	99 87       	std	Y+9, r25	; 0x09
    161c:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    161e:	88 85       	ldd	r24, Y+8	; 0x08
    1620:	99 85       	ldd	r25, Y+9	; 0x09
}
    1622:	63 96       	adiw	r28, 0x13	; 19
    1624:	0f b6       	in	r0, 0x3f	; 63
    1626:	f8 94       	cli
    1628:	de bf       	out	0x3e, r29	; 62
    162a:	0f be       	out	0x3f, r0	; 63
    162c:	cd bf       	out	0x3d, r28	; 61
    162e:	cf 91       	pop	r28
    1630:	df 91       	pop	r29
    1632:	1f 91       	pop	r17
    1634:	0f 91       	pop	r16
    1636:	08 95       	ret

00001638 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1638:	df 93       	push	r29
    163a:	cf 93       	push	r28
    163c:	cd b7       	in	r28, 0x3d	; 61
    163e:	de b7       	in	r29, 0x3e	; 62
    1640:	28 97       	sbiw	r28, 0x08	; 8
    1642:	0f b6       	in	r0, 0x3f	; 63
    1644:	f8 94       	cli
    1646:	de bf       	out	0x3e, r29	; 62
    1648:	0f be       	out	0x3f, r0	; 63
    164a:	cd bf       	out	0x3d, r28	; 61
    164c:	9e 83       	std	Y+6, r25	; 0x06
    164e:	8d 83       	std	Y+5, r24	; 0x05
    1650:	78 87       	std	Y+8, r23	; 0x08
    1652:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1654:	8d 81       	ldd	r24, Y+5	; 0x05
    1656:	9e 81       	ldd	r25, Y+6	; 0x06
    1658:	9c 83       	std	Y+4, r25	; 0x04
    165a:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    165c:	0f b6       	in	r0, 0x3f	; 63
    165e:	f8 94       	cli
    1660:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1662:	eb 81       	ldd	r30, Y+3	; 0x03
    1664:	fc 81       	ldd	r31, Y+4	; 0x04
    1666:	80 81       	ld	r24, Z
    1668:	91 81       	ldd	r25, Z+1	; 0x01
    166a:	9a 83       	std	Y+2, r25	; 0x02
    166c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    166e:	eb 81       	ldd	r30, Y+3	; 0x03
    1670:	fc 81       	ldd	r31, Y+4	; 0x04
    1672:	20 81       	ld	r18, Z
    1674:	31 81       	ldd	r19, Z+1	; 0x01
    1676:	8f 81       	ldd	r24, Y+7	; 0x07
    1678:	98 85       	ldd	r25, Y+8	; 0x08
    167a:	80 95       	com	r24
    167c:	90 95       	com	r25
    167e:	82 23       	and	r24, r18
    1680:	93 23       	and	r25, r19
    1682:	eb 81       	ldd	r30, Y+3	; 0x03
    1684:	fc 81       	ldd	r31, Y+4	; 0x04
    1686:	91 83       	std	Z+1, r25	; 0x01
    1688:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    168a:	0f 90       	pop	r0
    168c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    168e:	89 81       	ldd	r24, Y+1	; 0x01
    1690:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1692:	28 96       	adiw	r28, 0x08	; 8
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	de bf       	out	0x3e, r29	; 62
    169a:	0f be       	out	0x3f, r0	; 63
    169c:	cd bf       	out	0x3d, r28	; 61
    169e:	cf 91       	pop	r28
    16a0:	df 91       	pop	r29
    16a2:	08 95       	ret

000016a4 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    16a4:	df 93       	push	r29
    16a6:	cf 93       	push	r28
    16a8:	cd b7       	in	r28, 0x3d	; 61
    16aa:	de b7       	in	r29, 0x3e	; 62
    16ac:	27 97       	sbiw	r28, 0x07	; 7
    16ae:	0f b6       	in	r0, 0x3f	; 63
    16b0:	f8 94       	cli
    16b2:	de bf       	out	0x3e, r29	; 62
    16b4:	0f be       	out	0x3f, r0	; 63
    16b6:	cd bf       	out	0x3d, r28	; 61
    16b8:	9f 83       	std	Y+7, r25	; 0x07
    16ba:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    16bc:	8e 81       	ldd	r24, Y+6	; 0x06
    16be:	9f 81       	ldd	r25, Y+7	; 0x07
    16c0:	9c 83       	std	Y+4, r25	; 0x04
    16c2:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    16c4:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    16c6:	eb 81       	ldd	r30, Y+3	; 0x03
    16c8:	fc 81       	ldd	r31, Y+4	; 0x04
    16ca:	80 81       	ld	r24, Z
    16cc:	91 81       	ldd	r25, Z+1	; 0x01
    16ce:	9a 83       	std	Y+2, r25	; 0x02
    16d0:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    16d2:	89 81       	ldd	r24, Y+1	; 0x01
    16d4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    16d6:	27 96       	adiw	r28, 0x07	; 7
    16d8:	0f b6       	in	r0, 0x3f	; 63
    16da:	f8 94       	cli
    16dc:	de bf       	out	0x3e, r29	; 62
    16de:	0f be       	out	0x3f, r0	; 63
    16e0:	cd bf       	out	0x3d, r28	; 61
    16e2:	cf 91       	pop	r28
    16e4:	df 91       	pop	r29
    16e6:	08 95       	ret

000016e8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    16e8:	df 93       	push	r29
    16ea:	cf 93       	push	r28
    16ec:	cd b7       	in	r28, 0x3d	; 61
    16ee:	de b7       	in	r29, 0x3e	; 62
    16f0:	65 97       	sbiw	r28, 0x15	; 21
    16f2:	0f b6       	in	r0, 0x3f	; 63
    16f4:	f8 94       	cli
    16f6:	de bf       	out	0x3e, r29	; 62
    16f8:	0f be       	out	0x3f, r0	; 63
    16fa:	cd bf       	out	0x3d, r28	; 61
    16fc:	9b 8b       	std	Y+19, r25	; 0x13
    16fe:	8a 8b       	std	Y+18, r24	; 0x12
    1700:	7d 8b       	std	Y+21, r23	; 0x15
    1702:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1704:	19 86       	std	Y+9, r1	; 0x09
    1706:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1708:	8a 89       	ldd	r24, Y+18	; 0x12
    170a:	9b 89       	ldd	r25, Y+19	; 0x13
    170c:	9b 83       	std	Y+3, r25	; 0x03
    170e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    1710:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    1712:	8a 81       	ldd	r24, Y+2	; 0x02
    1714:	9b 81       	ldd	r25, Y+3	; 0x03
    1716:	02 96       	adiw	r24, 0x02	; 2
    1718:	9b 87       	std	Y+11, r25	; 0x0b
    171a:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    171c:	8a 85       	ldd	r24, Y+10	; 0x0a
    171e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1720:	03 96       	adiw	r24, 0x03	; 3
    1722:	9d 87       	std	Y+13, r25	; 0x0d
    1724:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1726:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    172a:	ea 85       	ldd	r30, Y+10	; 0x0a
    172c:	fb 85       	ldd	r31, Y+11	; 0x0b
    172e:	85 81       	ldd	r24, Z+5	; 0x05
    1730:	96 81       	ldd	r25, Z+6	; 0x06
    1732:	99 8b       	std	Y+17, r25	; 0x11
    1734:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1736:	ea 81       	ldd	r30, Y+2	; 0x02
    1738:	fb 81       	ldd	r31, Y+3	; 0x03
    173a:	20 81       	ld	r18, Z
    173c:	31 81       	ldd	r19, Z+1	; 0x01
    173e:	8c 89       	ldd	r24, Y+20	; 0x14
    1740:	9d 89       	ldd	r25, Y+21	; 0x15
    1742:	82 2b       	or	r24, r18
    1744:	93 2b       	or	r25, r19
    1746:	ea 81       	ldd	r30, Y+2	; 0x02
    1748:	fb 81       	ldd	r31, Y+3	; 0x03
    174a:	91 83       	std	Z+1, r25	; 0x01
    174c:	80 83       	st	Z, r24
    174e:	59 c0       	rjmp	.+178    	; 0x1802 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1750:	e8 89       	ldd	r30, Y+16	; 0x10
    1752:	f9 89       	ldd	r31, Y+17	; 0x11
    1754:	82 81       	ldd	r24, Z+2	; 0x02
    1756:	93 81       	ldd	r25, Z+3	; 0x03
    1758:	9f 87       	std	Y+15, r25	; 0x0f
    175a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    175c:	e8 89       	ldd	r30, Y+16	; 0x10
    175e:	f9 89       	ldd	r31, Y+17	; 0x11
    1760:	80 81       	ld	r24, Z
    1762:	91 81       	ldd	r25, Z+1	; 0x01
    1764:	9f 83       	std	Y+7, r25	; 0x07
    1766:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1768:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    176a:	8e 81       	ldd	r24, Y+6	; 0x06
    176c:	9f 81       	ldd	r25, Y+7	; 0x07
    176e:	80 70       	andi	r24, 0x00	; 0
    1770:	9d 83       	std	Y+5, r25	; 0x05
    1772:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1774:	8e 81       	ldd	r24, Y+6	; 0x06
    1776:	9f 81       	ldd	r25, Y+7	; 0x07
    1778:	90 70       	andi	r25, 0x00	; 0
    177a:	9f 83       	std	Y+7, r25	; 0x07
    177c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    177e:	8c 81       	ldd	r24, Y+4	; 0x04
    1780:	9d 81       	ldd	r25, Y+5	; 0x05
    1782:	80 70       	andi	r24, 0x00	; 0
    1784:	94 70       	andi	r25, 0x04	; 4
    1786:	00 97       	sbiw	r24, 0x00	; 0
    1788:	69 f4       	brne	.+26     	; 0x17a4 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    178a:	ea 81       	ldd	r30, Y+2	; 0x02
    178c:	fb 81       	ldd	r31, Y+3	; 0x03
    178e:	20 81       	ld	r18, Z
    1790:	31 81       	ldd	r19, Z+1	; 0x01
    1792:	8e 81       	ldd	r24, Y+6	; 0x06
    1794:	9f 81       	ldd	r25, Y+7	; 0x07
    1796:	82 23       	and	r24, r18
    1798:	93 23       	and	r25, r19
    179a:	00 97       	sbiw	r24, 0x00	; 0
    179c:	91 f0       	breq	.+36     	; 0x17c2 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    179e:	81 e0       	ldi	r24, 0x01	; 1
    17a0:	89 83       	std	Y+1, r24	; 0x01
    17a2:	0f c0       	rjmp	.+30     	; 0x17c2 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    17a4:	ea 81       	ldd	r30, Y+2	; 0x02
    17a6:	fb 81       	ldd	r31, Y+3	; 0x03
    17a8:	20 81       	ld	r18, Z
    17aa:	31 81       	ldd	r19, Z+1	; 0x01
    17ac:	8e 81       	ldd	r24, Y+6	; 0x06
    17ae:	9f 81       	ldd	r25, Y+7	; 0x07
    17b0:	28 23       	and	r18, r24
    17b2:	39 23       	and	r19, r25
    17b4:	8e 81       	ldd	r24, Y+6	; 0x06
    17b6:	9f 81       	ldd	r25, Y+7	; 0x07
    17b8:	28 17       	cp	r18, r24
    17ba:	39 07       	cpc	r19, r25
    17bc:	11 f4       	brne	.+4      	; 0x17c2 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    17be:	81 e0       	ldi	r24, 0x01	; 1
    17c0:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    17c2:	89 81       	ldd	r24, Y+1	; 0x01
    17c4:	88 23       	and	r24, r24
    17c6:	c9 f0       	breq	.+50     	; 0x17fa <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    17c8:	8c 81       	ldd	r24, Y+4	; 0x04
    17ca:	9d 81       	ldd	r25, Y+5	; 0x05
    17cc:	80 70       	andi	r24, 0x00	; 0
    17ce:	91 70       	andi	r25, 0x01	; 1
    17d0:	00 97       	sbiw	r24, 0x00	; 0
    17d2:	41 f0       	breq	.+16     	; 0x17e4 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    17d4:	88 85       	ldd	r24, Y+8	; 0x08
    17d6:	99 85       	ldd	r25, Y+9	; 0x09
    17d8:	2e 81       	ldd	r18, Y+6	; 0x06
    17da:	3f 81       	ldd	r19, Y+7	; 0x07
    17dc:	82 2b       	or	r24, r18
    17de:	93 2b       	or	r25, r19
    17e0:	99 87       	std	Y+9, r25	; 0x09
    17e2:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    17e4:	ea 81       	ldd	r30, Y+2	; 0x02
    17e6:	fb 81       	ldd	r31, Y+3	; 0x03
    17e8:	80 81       	ld	r24, Z
    17ea:	91 81       	ldd	r25, Z+1	; 0x01
    17ec:	9c 01       	movw	r18, r24
    17ee:	32 60       	ori	r19, 0x02	; 2
    17f0:	88 89       	ldd	r24, Y+16	; 0x10
    17f2:	99 89       	ldd	r25, Y+17	; 0x11
    17f4:	b9 01       	movw	r22, r18
    17f6:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    17fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    17fc:	9f 85       	ldd	r25, Y+15	; 0x0f
    17fe:	99 8b       	std	Y+17, r25	; 0x11
    1800:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1802:	28 89       	ldd	r18, Y+16	; 0x10
    1804:	39 89       	ldd	r19, Y+17	; 0x11
    1806:	8c 85       	ldd	r24, Y+12	; 0x0c
    1808:	9d 85       	ldd	r25, Y+13	; 0x0d
    180a:	28 17       	cp	r18, r24
    180c:	39 07       	cpc	r19, r25
    180e:	09 f0       	breq	.+2      	; 0x1812 <xEventGroupSetBits+0x12a>
    1810:	9f cf       	rjmp	.-194    	; 0x1750 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1812:	ea 81       	ldd	r30, Y+2	; 0x02
    1814:	fb 81       	ldd	r31, Y+3	; 0x03
    1816:	20 81       	ld	r18, Z
    1818:	31 81       	ldd	r19, Z+1	; 0x01
    181a:	88 85       	ldd	r24, Y+8	; 0x08
    181c:	99 85       	ldd	r25, Y+9	; 0x09
    181e:	80 95       	com	r24
    1820:	90 95       	com	r25
    1822:	82 23       	and	r24, r18
    1824:	93 23       	and	r25, r19
    1826:	ea 81       	ldd	r30, Y+2	; 0x02
    1828:	fb 81       	ldd	r31, Y+3	; 0x03
    182a:	91 83       	std	Z+1, r25	; 0x01
    182c:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    182e:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1832:	ea 81       	ldd	r30, Y+2	; 0x02
    1834:	fb 81       	ldd	r31, Y+3	; 0x03
    1836:	80 81       	ld	r24, Z
    1838:	91 81       	ldd	r25, Z+1	; 0x01
}
    183a:	65 96       	adiw	r28, 0x15	; 21
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	cd bf       	out	0x3d, r28	; 61
    1846:	cf 91       	pop	r28
    1848:	df 91       	pop	r29
    184a:	08 95       	ret

0000184c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    184c:	df 93       	push	r29
    184e:	cf 93       	push	r28
    1850:	00 d0       	rcall	.+0      	; 0x1852 <vEventGroupDelete+0x6>
    1852:	00 d0       	rcall	.+0      	; 0x1854 <vEventGroupDelete+0x8>
    1854:	00 d0       	rcall	.+0      	; 0x1856 <vEventGroupDelete+0xa>
    1856:	cd b7       	in	r28, 0x3d	; 61
    1858:	de b7       	in	r29, 0x3e	; 62
    185a:	9e 83       	std	Y+6, r25	; 0x06
    185c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    185e:	8d 81       	ldd	r24, Y+5	; 0x05
    1860:	9e 81       	ldd	r25, Y+6	; 0x06
    1862:	9c 83       	std	Y+4, r25	; 0x04
    1864:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1866:	8b 81       	ldd	r24, Y+3	; 0x03
    1868:	9c 81       	ldd	r25, Y+4	; 0x04
    186a:	02 96       	adiw	r24, 0x02	; 2
    186c:	9a 83       	std	Y+2, r25	; 0x02
    186e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    1870:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
    1874:	08 c0       	rjmp	.+16     	; 0x1886 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1876:	e9 81       	ldd	r30, Y+1	; 0x01
    1878:	fa 81       	ldd	r31, Y+2	; 0x02
    187a:	85 81       	ldd	r24, Z+5	; 0x05
    187c:	96 81       	ldd	r25, Z+6	; 0x06
    187e:	60 e0       	ldi	r22, 0x00	; 0
    1880:	72 e0       	ldi	r23, 0x02	; 2
    1882:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1886:	e9 81       	ldd	r30, Y+1	; 0x01
    1888:	fa 81       	ldd	r31, Y+2	; 0x02
    188a:	80 81       	ld	r24, Z
    188c:	88 23       	and	r24, r24
    188e:	99 f7       	brne	.-26     	; 0x1876 <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    1890:	8b 81       	ldd	r24, Y+3	; 0x03
    1892:	9c 81       	ldd	r25, Y+4	; 0x04
    1894:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vPortFree>
	}
	( void ) xTaskResumeAll();
    1898:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
}
    189c:	26 96       	adiw	r28, 0x06	; 6
    189e:	0f b6       	in	r0, 0x3f	; 63
    18a0:	f8 94       	cli
    18a2:	de bf       	out	0x3e, r29	; 62
    18a4:	0f be       	out	0x3f, r0	; 63
    18a6:	cd bf       	out	0x3d, r28	; 61
    18a8:	cf 91       	pop	r28
    18aa:	df 91       	pop	r29
    18ac:	08 95       	ret

000018ae <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    18ae:	df 93       	push	r29
    18b0:	cf 93       	push	r28
    18b2:	00 d0       	rcall	.+0      	; 0x18b4 <vEventGroupSetBitsCallback+0x6>
    18b4:	00 d0       	rcall	.+0      	; 0x18b6 <vEventGroupSetBitsCallback+0x8>
    18b6:	00 d0       	rcall	.+0      	; 0x18b8 <vEventGroupSetBitsCallback+0xa>
    18b8:	cd b7       	in	r28, 0x3d	; 61
    18ba:	de b7       	in	r29, 0x3e	; 62
    18bc:	9a 83       	std	Y+2, r25	; 0x02
    18be:	89 83       	std	Y+1, r24	; 0x01
    18c0:	4b 83       	std	Y+3, r20	; 0x03
    18c2:	5c 83       	std	Y+4, r21	; 0x04
    18c4:	6d 83       	std	Y+5, r22	; 0x05
    18c6:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    18c8:	2b 81       	ldd	r18, Y+3	; 0x03
    18ca:	3c 81       	ldd	r19, Y+4	; 0x04
    18cc:	89 81       	ldd	r24, Y+1	; 0x01
    18ce:	9a 81       	ldd	r25, Y+2	; 0x02
    18d0:	b9 01       	movw	r22, r18
    18d2:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <xEventGroupSetBits>
}
    18d6:	26 96       	adiw	r28, 0x06	; 6
    18d8:	0f b6       	in	r0, 0x3f	; 63
    18da:	f8 94       	cli
    18dc:	de bf       	out	0x3e, r29	; 62
    18de:	0f be       	out	0x3f, r0	; 63
    18e0:	cd bf       	out	0x3d, r28	; 61
    18e2:	cf 91       	pop	r28
    18e4:	df 91       	pop	r29
    18e6:	08 95       	ret

000018e8 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    18e8:	df 93       	push	r29
    18ea:	cf 93       	push	r28
    18ec:	00 d0       	rcall	.+0      	; 0x18ee <vEventGroupClearBitsCallback+0x6>
    18ee:	00 d0       	rcall	.+0      	; 0x18f0 <vEventGroupClearBitsCallback+0x8>
    18f0:	00 d0       	rcall	.+0      	; 0x18f2 <vEventGroupClearBitsCallback+0xa>
    18f2:	cd b7       	in	r28, 0x3d	; 61
    18f4:	de b7       	in	r29, 0x3e	; 62
    18f6:	9a 83       	std	Y+2, r25	; 0x02
    18f8:	89 83       	std	Y+1, r24	; 0x01
    18fa:	4b 83       	std	Y+3, r20	; 0x03
    18fc:	5c 83       	std	Y+4, r21	; 0x04
    18fe:	6d 83       	std	Y+5, r22	; 0x05
    1900:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    1902:	2b 81       	ldd	r18, Y+3	; 0x03
    1904:	3c 81       	ldd	r19, Y+4	; 0x04
    1906:	89 81       	ldd	r24, Y+1	; 0x01
    1908:	9a 81       	ldd	r25, Y+2	; 0x02
    190a:	b9 01       	movw	r22, r18
    190c:	0e 94 1c 0b 	call	0x1638	; 0x1638 <xEventGroupClearBits>
}
    1910:	26 96       	adiw	r28, 0x06	; 6
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	de bf       	out	0x3e, r29	; 62
    1918:	0f be       	out	0x3f, r0	; 63
    191a:	cd bf       	out	0x3d, r28	; 61
    191c:	cf 91       	pop	r28
    191e:	df 91       	pop	r29
    1920:	08 95       	ret

00001922 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1922:	df 93       	push	r29
    1924:	cf 93       	push	r28
    1926:	00 d0       	rcall	.+0      	; 0x1928 <prvTestWaitCondition+0x6>
    1928:	00 d0       	rcall	.+0      	; 0x192a <prvTestWaitCondition+0x8>
    192a:	00 d0       	rcall	.+0      	; 0x192c <prvTestWaitCondition+0xa>
    192c:	cd b7       	in	r28, 0x3d	; 61
    192e:	de b7       	in	r29, 0x3e	; 62
    1930:	9b 83       	std	Y+3, r25	; 0x03
    1932:	8a 83       	std	Y+2, r24	; 0x02
    1934:	7d 83       	std	Y+5, r23	; 0x05
    1936:	6c 83       	std	Y+4, r22	; 0x04
    1938:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    193a:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    193c:	8e 81       	ldd	r24, Y+6	; 0x06
    193e:	88 23       	and	r24, r24
    1940:	59 f4       	brne	.+22     	; 0x1958 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1942:	8a 81       	ldd	r24, Y+2	; 0x02
    1944:	9b 81       	ldd	r25, Y+3	; 0x03
    1946:	2c 81       	ldd	r18, Y+4	; 0x04
    1948:	3d 81       	ldd	r19, Y+5	; 0x05
    194a:	82 23       	and	r24, r18
    194c:	93 23       	and	r25, r19
    194e:	00 97       	sbiw	r24, 0x00	; 0
    1950:	81 f0       	breq	.+32     	; 0x1972 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1952:	81 e0       	ldi	r24, 0x01	; 1
    1954:	89 83       	std	Y+1, r24	; 0x01
    1956:	0d c0       	rjmp	.+26     	; 0x1972 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1958:	2a 81       	ldd	r18, Y+2	; 0x02
    195a:	3b 81       	ldd	r19, Y+3	; 0x03
    195c:	8c 81       	ldd	r24, Y+4	; 0x04
    195e:	9d 81       	ldd	r25, Y+5	; 0x05
    1960:	28 23       	and	r18, r24
    1962:	39 23       	and	r19, r25
    1964:	8c 81       	ldd	r24, Y+4	; 0x04
    1966:	9d 81       	ldd	r25, Y+5	; 0x05
    1968:	28 17       	cp	r18, r24
    196a:	39 07       	cpc	r19, r25
    196c:	11 f4       	brne	.+4      	; 0x1972 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    196e:	81 e0       	ldi	r24, 0x01	; 1
    1970:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1972:	89 81       	ldd	r24, Y+1	; 0x01
}
    1974:	26 96       	adiw	r28, 0x06	; 6
    1976:	0f b6       	in	r0, 0x3f	; 63
    1978:	f8 94       	cli
    197a:	de bf       	out	0x3e, r29	; 62
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	cd bf       	out	0x3d, r28	; 61
    1980:	cf 91       	pop	r28
    1982:	df 91       	pop	r29
    1984:	08 95       	ret

00001986 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1986:	df 93       	push	r29
    1988:	cf 93       	push	r28
    198a:	00 d0       	rcall	.+0      	; 0x198c <pvPortMalloc+0x6>
    198c:	00 d0       	rcall	.+0      	; 0x198e <pvPortMalloc+0x8>
    198e:	cd b7       	in	r28, 0x3d	; 61
    1990:	de b7       	in	r29, 0x3e	; 62
    1992:	9c 83       	std	Y+4, r25	; 0x04
    1994:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1996:	1a 82       	std	Y+2, r1	; 0x02
    1998:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    199a:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    199e:	80 91 f4 01 	lds	r24, 0x01F4
    19a2:	90 91 f5 01 	lds	r25, 0x01F5
    19a6:	00 97       	sbiw	r24, 0x00	; 0
    19a8:	31 f4       	brne	.+12     	; 0x19b6 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    19aa:	87 ef       	ldi	r24, 0xF7	; 247
    19ac:	91 e0       	ldi	r25, 0x01	; 1
    19ae:	90 93 f5 01 	sts	0x01F5, r25
    19b2:	80 93 f4 01 	sts	0x01F4, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    19b6:	80 91 f2 01 	lds	r24, 0x01F2
    19ba:	90 91 f3 01 	lds	r25, 0x01F3
    19be:	2b 81       	ldd	r18, Y+3	; 0x03
    19c0:	3c 81       	ldd	r19, Y+4	; 0x04
    19c2:	82 0f       	add	r24, r18
    19c4:	93 1f       	adc	r25, r19
    19c6:	29 e0       	ldi	r18, 0x09	; 9
    19c8:	83 3c       	cpi	r24, 0xC3	; 195
    19ca:	92 07       	cpc	r25, r18
    19cc:	38 f5       	brcc	.+78     	; 0x1a1c <pvPortMalloc+0x96>
    19ce:	20 91 f2 01 	lds	r18, 0x01F2
    19d2:	30 91 f3 01 	lds	r19, 0x01F3
    19d6:	8b 81       	ldd	r24, Y+3	; 0x03
    19d8:	9c 81       	ldd	r25, Y+4	; 0x04
    19da:	28 0f       	add	r18, r24
    19dc:	39 1f       	adc	r19, r25
    19de:	80 91 f2 01 	lds	r24, 0x01F2
    19e2:	90 91 f3 01 	lds	r25, 0x01F3
    19e6:	82 17       	cp	r24, r18
    19e8:	93 07       	cpc	r25, r19
    19ea:	c0 f4       	brcc	.+48     	; 0x1a1c <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    19ec:	20 91 f4 01 	lds	r18, 0x01F4
    19f0:	30 91 f5 01 	lds	r19, 0x01F5
    19f4:	80 91 f2 01 	lds	r24, 0x01F2
    19f8:	90 91 f3 01 	lds	r25, 0x01F3
    19fc:	82 0f       	add	r24, r18
    19fe:	93 1f       	adc	r25, r19
    1a00:	9a 83       	std	Y+2, r25	; 0x02
    1a02:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1a04:	20 91 f2 01 	lds	r18, 0x01F2
    1a08:	30 91 f3 01 	lds	r19, 0x01F3
    1a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a10:	82 0f       	add	r24, r18
    1a12:	93 1f       	adc	r25, r19
    1a14:	90 93 f3 01 	sts	0x01F3, r25
    1a18:	80 93 f2 01 	sts	0x01F2, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1a1c:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1a20:	89 81       	ldd	r24, Y+1	; 0x01
    1a22:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1a24:	0f 90       	pop	r0
    1a26:	0f 90       	pop	r0
    1a28:	0f 90       	pop	r0
    1a2a:	0f 90       	pop	r0
    1a2c:	cf 91       	pop	r28
    1a2e:	df 91       	pop	r29
    1a30:	08 95       	ret

00001a32 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a32:	df 93       	push	r29
    1a34:	cf 93       	push	r28
    1a36:	00 d0       	rcall	.+0      	; 0x1a38 <vPortFree+0x6>
    1a38:	cd b7       	in	r28, 0x3d	; 61
    1a3a:	de b7       	in	r29, 0x3e	; 62
    1a3c:	9a 83       	std	Y+2, r25	; 0x02
    1a3e:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1a40:	0f 90       	pop	r0
    1a42:	0f 90       	pop	r0
    1a44:	cf 91       	pop	r28
    1a46:	df 91       	pop	r29
    1a48:	08 95       	ret

00001a4a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1a4a:	df 93       	push	r29
    1a4c:	cf 93       	push	r28
    1a4e:	cd b7       	in	r28, 0x3d	; 61
    1a50:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1a52:	10 92 f3 01 	sts	0x01F3, r1
    1a56:	10 92 f2 01 	sts	0x01F2, r1
}
    1a5a:	cf 91       	pop	r28
    1a5c:	df 91       	pop	r29
    1a5e:	08 95       	ret

00001a60 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1a60:	df 93       	push	r29
    1a62:	cf 93       	push	r28
    1a64:	cd b7       	in	r28, 0x3d	; 61
    1a66:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1a68:	20 91 f2 01 	lds	r18, 0x01F2
    1a6c:	30 91 f3 01 	lds	r19, 0x01F3
    1a70:	83 ec       	ldi	r24, 0xC3	; 195
    1a72:	99 e0       	ldi	r25, 0x09	; 9
    1a74:	82 1b       	sub	r24, r18
    1a76:	93 0b       	sbc	r25, r19
}
    1a78:	cf 91       	pop	r28
    1a7a:	df 91       	pop	r29
    1a7c:	08 95       	ret

00001a7e <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    1a7e:	af 92       	push	r10
    1a80:	bf 92       	push	r11
    1a82:	cf 92       	push	r12
    1a84:	df 92       	push	r13
    1a86:	ef 92       	push	r14
    1a88:	ff 92       	push	r15
    1a8a:	0f 93       	push	r16
    1a8c:	df 93       	push	r29
    1a8e:	cf 93       	push	r28
    1a90:	00 d0       	rcall	.+0      	; 0x1a92 <vStartIntegerMathTasks+0x14>
    1a92:	0f 92       	push	r0
    1a94:	cd b7       	in	r28, 0x3d	; 61
    1a96:	de b7       	in	r29, 0x3e	; 62
    1a98:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1a9a:	1a 82       	std	Y+2, r1	; 0x02
    1a9c:	19 82       	std	Y+1, r1	; 0x01
    1a9e:	1b c0       	rjmp	.+54     	; 0x1ad6 <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    1aa0:	89 81       	ldd	r24, Y+1	; 0x01
    1aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa4:	fc 01       	movw	r30, r24
    1aa6:	e6 54       	subi	r30, 0x46	; 70
    1aa8:	f4 4f       	sbci	r31, 0xF4	; 244
    1aaa:	8d e7       	ldi	r24, 0x7D	; 125
    1aac:	9d e0       	ldi	r25, 0x0D	; 13
    1aae:	20 e1       	ldi	r18, 0x10	; 16
    1ab0:	31 e0       	ldi	r19, 0x01	; 1
    1ab2:	b9 01       	movw	r22, r18
    1ab4:	45 e5       	ldi	r20, 0x55	; 85
    1ab6:	50 e0       	ldi	r21, 0x00	; 0
    1ab8:	9f 01       	movw	r18, r30
    1aba:	0b 81       	ldd	r16, Y+3	; 0x03
    1abc:	ee 24       	eor	r14, r14
    1abe:	ff 24       	eor	r15, r15
    1ac0:	cc 24       	eor	r12, r12
    1ac2:	dd 24       	eor	r13, r13
    1ac4:	aa 24       	eor	r10, r10
    1ac6:	bb 24       	eor	r11, r11
    1ac8:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1acc:	89 81       	ldd	r24, Y+1	; 0x01
    1ace:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad0:	01 96       	adiw	r24, 0x01	; 1
    1ad2:	9a 83       	std	Y+2, r25	; 0x02
    1ad4:	89 83       	std	Y+1, r24	; 0x01
    1ad6:	89 81       	ldd	r24, Y+1	; 0x01
    1ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    1ada:	18 16       	cp	r1, r24
    1adc:	19 06       	cpc	r1, r25
    1ade:	04 f7       	brge	.-64     	; 0x1aa0 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    1ae0:	0f 90       	pop	r0
    1ae2:	0f 90       	pop	r0
    1ae4:	0f 90       	pop	r0
    1ae6:	cf 91       	pop	r28
    1ae8:	df 91       	pop	r29
    1aea:	0f 91       	pop	r16
    1aec:	ff 90       	pop	r15
    1aee:	ef 90       	pop	r14
    1af0:	df 90       	pop	r13
    1af2:	cf 90       	pop	r12
    1af4:	bf 90       	pop	r11
    1af6:	af 90       	pop	r10
    1af8:	08 95       	ret

00001afa <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    1afa:	df 93       	push	r29
    1afc:	cf 93       	push	r28
    1afe:	cd b7       	in	r28, 0x3d	; 61
    1b00:	de b7       	in	r29, 0x3e	; 62
    1b02:	2a 97       	sbiw	r28, 0x0a	; 10
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	de bf       	out	0x3e, r29	; 62
    1b0a:	0f be       	out	0x3f, r0	; 63
    1b0c:	cd bf       	out	0x3d, r28	; 61
    1b0e:	9a 87       	std	Y+10, r25	; 0x0a
    1b10:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    1b12:	1c 82       	std	Y+4, r1	; 0x04
    1b14:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1b16:	89 85       	ldd	r24, Y+9	; 0x09
    1b18:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b1a:	9a 83       	std	Y+2, r25	; 0x02
    1b1c:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1b1e:	8b e7       	ldi	r24, 0x7B	; 123
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	a0 e0       	ldi	r26, 0x00	; 0
    1b24:	b0 e0       	ldi	r27, 0x00	; 0
    1b26:	8d 83       	std	Y+5, r24	; 0x05
    1b28:	9e 83       	std	Y+6, r25	; 0x06
    1b2a:	af 83       	std	Y+7, r26	; 0x07
    1b2c:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    1b2e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b30:	9e 81       	ldd	r25, Y+6	; 0x06
    1b32:	af 81       	ldd	r26, Y+7	; 0x07
    1b34:	b8 85       	ldd	r27, Y+8	; 0x08
    1b36:	89 5b       	subi	r24, 0xB9	; 185
    1b38:	9b 46       	sbci	r25, 0x6B	; 107
    1b3a:	ac 4f       	sbci	r26, 0xFC	; 252
    1b3c:	bf 4f       	sbci	r27, 0xFF	; 255
    1b3e:	8d 83       	std	Y+5, r24	; 0x05
    1b40:	9e 83       	std	Y+6, r25	; 0x06
    1b42:	af 83       	std	Y+7, r26	; 0x07
    1b44:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1b46:	8d 81       	ldd	r24, Y+5	; 0x05
    1b48:	9e 81       	ldd	r25, Y+6	; 0x06
    1b4a:	af 81       	ldd	r26, Y+7	; 0x07
    1b4c:	b8 85       	ldd	r27, Y+8	; 0x08
    1b4e:	2d ef       	ldi	r18, 0xFD	; 253
    1b50:	3f ef       	ldi	r19, 0xFF	; 255
    1b52:	4f ef       	ldi	r20, 0xFF	; 255
    1b54:	5f ef       	ldi	r21, 0xFF	; 255
    1b56:	bc 01       	movw	r22, r24
    1b58:	cd 01       	movw	r24, r26
    1b5a:	0e 94 56 2d 	call	0x5aac	; 0x5aac <__mulsi3>
    1b5e:	dc 01       	movw	r26, r24
    1b60:	cb 01       	movw	r24, r22
    1b62:	8d 83       	std	Y+5, r24	; 0x05
    1b64:	9e 83       	std	Y+6, r25	; 0x06
    1b66:	af 83       	std	Y+7, r26	; 0x07
    1b68:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    1b6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b6e:	af 81       	ldd	r26, Y+7	; 0x07
    1b70:	b8 85       	ldd	r27, Y+8	; 0x08
    1b72:	27 e0       	ldi	r18, 0x07	; 7
    1b74:	30 e0       	ldi	r19, 0x00	; 0
    1b76:	40 e0       	ldi	r20, 0x00	; 0
    1b78:	50 e0       	ldi	r21, 0x00	; 0
    1b7a:	bc 01       	movw	r22, r24
    1b7c:	cd 01       	movw	r24, r26
    1b7e:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <__divmodsi4>
    1b82:	da 01       	movw	r26, r20
    1b84:	c9 01       	movw	r24, r18
    1b86:	8d 83       	std	Y+5, r24	; 0x05
    1b88:	9e 83       	std	Y+6, r25	; 0x06
    1b8a:	af 83       	std	Y+7, r26	; 0x07
    1b8c:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    1b8e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b90:	9e 81       	ldd	r25, Y+6	; 0x06
    1b92:	af 81       	ldd	r26, Y+7	; 0x07
    1b94:	b8 85       	ldd	r27, Y+8	; 0x08
    1b96:	8b 31       	cpi	r24, 0x1B	; 27
    1b98:	27 e7       	ldi	r18, 0x77	; 119
    1b9a:	92 07       	cpc	r25, r18
    1b9c:	2e ef       	ldi	r18, 0xFE	; 254
    1b9e:	a2 07       	cpc	r26, r18
    1ba0:	2f ef       	ldi	r18, 0xFF	; 255
    1ba2:	b2 07       	cpc	r27, r18
    1ba4:	21 f0       	breq	.+8      	; 0x1bae <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	9c 83       	std	Y+4, r25	; 0x04
    1bac:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    1bae:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb2:	00 97       	sbiw	r24, 0x00	; 0
    1bb4:	09 f0       	breq	.+2      	; 0x1bb8 <vCompeteingIntMathTask+0xbe>
    1bb6:	b3 cf       	rjmp	.-154    	; 0x1b1e <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    1bb8:	0f b6       	in	r0, 0x3f	; 63
    1bba:	f8 94       	cli
    1bbc:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    1bbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1bc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    1bc6:	0f 90       	pop	r0
    1bc8:	0f be       	out	0x3f, r0	; 63
    1bca:	a9 cf       	rjmp	.-174    	; 0x1b1e <vCompeteingIntMathTask+0x24>

00001bcc <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    1bcc:	df 93       	push	r29
    1bce:	cf 93       	push	r28
    1bd0:	00 d0       	rcall	.+0      	; 0x1bd2 <xAreIntegerMathsTaskStillRunning+0x6>
    1bd2:	0f 92       	push	r0
    1bd4:	cd b7       	in	r28, 0x3d	; 61
    1bd6:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    1bd8:	81 e0       	ldi	r24, 0x01	; 1
    1bda:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1bdc:	1a 82       	std	Y+2, r1	; 0x02
    1bde:	19 82       	std	Y+1, r1	; 0x01
    1be0:	14 c0       	rjmp	.+40     	; 0x1c0a <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    1be2:	89 81       	ldd	r24, Y+1	; 0x01
    1be4:	9a 81       	ldd	r25, Y+2	; 0x02
    1be6:	fc 01       	movw	r30, r24
    1be8:	e6 54       	subi	r30, 0x46	; 70
    1bea:	f4 4f       	sbci	r31, 0xF4	; 244
    1bec:	80 81       	ld	r24, Z
    1bee:	88 23       	and	r24, r24
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    1bf2:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf8:	fc 01       	movw	r30, r24
    1bfa:	e6 54       	subi	r30, 0x46	; 70
    1bfc:	f4 4f       	sbci	r31, 0xF4	; 244
    1bfe:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1c00:	89 81       	ldd	r24, Y+1	; 0x01
    1c02:	9a 81       	ldd	r25, Y+2	; 0x02
    1c04:	01 96       	adiw	r24, 0x01	; 1
    1c06:	9a 83       	std	Y+2, r25	; 0x02
    1c08:	89 83       	std	Y+1, r24	; 0x01
    1c0a:	89 81       	ldd	r24, Y+1	; 0x01
    1c0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c0e:	18 16       	cp	r1, r24
    1c10:	19 06       	cpc	r1, r25
    1c12:	3c f7       	brge	.-50     	; 0x1be2 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    1c14:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1c16:	0f 90       	pop	r0
    1c18:	0f 90       	pop	r0
    1c1a:	0f 90       	pop	r0
    1c1c:	cf 91       	pop	r28
    1c1e:	df 91       	pop	r29
    1c20:	08 95       	ret

00001c22 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1c22:	df 93       	push	r29
    1c24:	cf 93       	push	r28
    1c26:	00 d0       	rcall	.+0      	; 0x1c28 <vListInitialise+0x6>
    1c28:	cd b7       	in	r28, 0x3d	; 61
    1c2a:	de b7       	in	r29, 0x3e	; 62
    1c2c:	9a 83       	std	Y+2, r25	; 0x02
    1c2e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c30:	89 81       	ldd	r24, Y+1	; 0x01
    1c32:	9a 81       	ldd	r25, Y+2	; 0x02
    1c34:	03 96       	adiw	r24, 0x03	; 3
    1c36:	e9 81       	ldd	r30, Y+1	; 0x01
    1c38:	fa 81       	ldd	r31, Y+2	; 0x02
    1c3a:	92 83       	std	Z+2, r25	; 0x02
    1c3c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c40:	fa 81       	ldd	r31, Y+2	; 0x02
    1c42:	8f ef       	ldi	r24, 0xFF	; 255
    1c44:	9f ef       	ldi	r25, 0xFF	; 255
    1c46:	94 83       	std	Z+4, r25	; 0x04
    1c48:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c4a:	89 81       	ldd	r24, Y+1	; 0x01
    1c4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c4e:	03 96       	adiw	r24, 0x03	; 3
    1c50:	e9 81       	ldd	r30, Y+1	; 0x01
    1c52:	fa 81       	ldd	r31, Y+2	; 0x02
    1c54:	96 83       	std	Z+6, r25	; 0x06
    1c56:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c58:	89 81       	ldd	r24, Y+1	; 0x01
    1c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5c:	03 96       	adiw	r24, 0x03	; 3
    1c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c60:	fa 81       	ldd	r31, Y+2	; 0x02
    1c62:	90 87       	std	Z+8, r25	; 0x08
    1c64:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c66:	e9 81       	ldd	r30, Y+1	; 0x01
    1c68:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6a:	10 82       	st	Z, r1
}
    1c6c:	0f 90       	pop	r0
    1c6e:	0f 90       	pop	r0
    1c70:	cf 91       	pop	r28
    1c72:	df 91       	pop	r29
    1c74:	08 95       	ret

00001c76 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1c76:	df 93       	push	r29
    1c78:	cf 93       	push	r28
    1c7a:	00 d0       	rcall	.+0      	; 0x1c7c <vListInitialiseItem+0x6>
    1c7c:	cd b7       	in	r28, 0x3d	; 61
    1c7e:	de b7       	in	r29, 0x3e	; 62
    1c80:	9a 83       	std	Y+2, r25	; 0x02
    1c82:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c84:	e9 81       	ldd	r30, Y+1	; 0x01
    1c86:	fa 81       	ldd	r31, Y+2	; 0x02
    1c88:	11 86       	std	Z+9, r1	; 0x09
    1c8a:	10 86       	std	Z+8, r1	; 0x08
}
    1c8c:	0f 90       	pop	r0
    1c8e:	0f 90       	pop	r0
    1c90:	cf 91       	pop	r28
    1c92:	df 91       	pop	r29
    1c94:	08 95       	ret

00001c96 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c96:	df 93       	push	r29
    1c98:	cf 93       	push	r28
    1c9a:	00 d0       	rcall	.+0      	; 0x1c9c <vListInsertEnd+0x6>
    1c9c:	00 d0       	rcall	.+0      	; 0x1c9e <vListInsertEnd+0x8>
    1c9e:	00 d0       	rcall	.+0      	; 0x1ca0 <vListInsertEnd+0xa>
    1ca0:	cd b7       	in	r28, 0x3d	; 61
    1ca2:	de b7       	in	r29, 0x3e	; 62
    1ca4:	9c 83       	std	Y+4, r25	; 0x04
    1ca6:	8b 83       	std	Y+3, r24	; 0x03
    1ca8:	7e 83       	std	Y+6, r23	; 0x06
    1caa:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1cac:	eb 81       	ldd	r30, Y+3	; 0x03
    1cae:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb0:	81 81       	ldd	r24, Z+1	; 0x01
    1cb2:	92 81       	ldd	r25, Z+2	; 0x02
    1cb4:	9a 83       	std	Y+2, r25	; 0x02
    1cb6:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1cb8:	ed 81       	ldd	r30, Y+5	; 0x05
    1cba:	fe 81       	ldd	r31, Y+6	; 0x06
    1cbc:	89 81       	ldd	r24, Y+1	; 0x01
    1cbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc0:	93 83       	std	Z+3, r25	; 0x03
    1cc2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1cc4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cc6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cc8:	84 81       	ldd	r24, Z+4	; 0x04
    1cca:	95 81       	ldd	r25, Z+5	; 0x05
    1ccc:	ed 81       	ldd	r30, Y+5	; 0x05
    1cce:	fe 81       	ldd	r31, Y+6	; 0x06
    1cd0:	95 83       	std	Z+5, r25	; 0x05
    1cd2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1cd4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cd6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cd8:	04 80       	ldd	r0, Z+4	; 0x04
    1cda:	f5 81       	ldd	r31, Z+5	; 0x05
    1cdc:	e0 2d       	mov	r30, r0
    1cde:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ce2:	93 83       	std	Z+3, r25	; 0x03
    1ce4:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cea:	8d 81       	ldd	r24, Y+5	; 0x05
    1cec:	9e 81       	ldd	r25, Y+6	; 0x06
    1cee:	95 83       	std	Z+5, r25	; 0x05
    1cf0:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1cf2:	ed 81       	ldd	r30, Y+5	; 0x05
    1cf4:	fe 81       	ldd	r31, Y+6	; 0x06
    1cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfa:	91 87       	std	Z+9, r25	; 0x09
    1cfc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    1d00:	fc 81       	ldd	r31, Y+4	; 0x04
    1d02:	80 81       	ld	r24, Z
    1d04:	8f 5f       	subi	r24, 0xFF	; 255
    1d06:	eb 81       	ldd	r30, Y+3	; 0x03
    1d08:	fc 81       	ldd	r31, Y+4	; 0x04
    1d0a:	80 83       	st	Z, r24
}
    1d0c:	26 96       	adiw	r28, 0x06	; 6
    1d0e:	0f b6       	in	r0, 0x3f	; 63
    1d10:	f8 94       	cli
    1d12:	de bf       	out	0x3e, r29	; 62
    1d14:	0f be       	out	0x3f, r0	; 63
    1d16:	cd bf       	out	0x3d, r28	; 61
    1d18:	cf 91       	pop	r28
    1d1a:	df 91       	pop	r29
    1d1c:	08 95       	ret

00001d1e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1d1e:	df 93       	push	r29
    1d20:	cf 93       	push	r28
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	28 97       	sbiw	r28, 0x08	; 8
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	de bf       	out	0x3e, r29	; 62
    1d2e:	0f be       	out	0x3f, r0	; 63
    1d30:	cd bf       	out	0x3d, r28	; 61
    1d32:	9e 83       	std	Y+6, r25	; 0x06
    1d34:	8d 83       	std	Y+5, r24	; 0x05
    1d36:	78 87       	std	Y+8, r23	; 0x08
    1d38:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1d3a:	ef 81       	ldd	r30, Y+7	; 0x07
    1d3c:	f8 85       	ldd	r31, Y+8	; 0x08
    1d3e:	80 81       	ld	r24, Z
    1d40:	91 81       	ldd	r25, Z+1	; 0x01
    1d42:	9a 83       	std	Y+2, r25	; 0x02
    1d44:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1d46:	89 81       	ldd	r24, Y+1	; 0x01
    1d48:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4a:	2f ef       	ldi	r18, 0xFF	; 255
    1d4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4e:	92 07       	cpc	r25, r18
    1d50:	39 f4       	brne	.+14     	; 0x1d60 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1d52:	ed 81       	ldd	r30, Y+5	; 0x05
    1d54:	fe 81       	ldd	r31, Y+6	; 0x06
    1d56:	87 81       	ldd	r24, Z+7	; 0x07
    1d58:	90 85       	ldd	r25, Z+8	; 0x08
    1d5a:	9c 83       	std	Y+4, r25	; 0x04
    1d5c:	8b 83       	std	Y+3, r24	; 0x03
    1d5e:	18 c0       	rjmp	.+48     	; 0x1d90 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d60:	8d 81       	ldd	r24, Y+5	; 0x05
    1d62:	9e 81       	ldd	r25, Y+6	; 0x06
    1d64:	03 96       	adiw	r24, 0x03	; 3
    1d66:	9c 83       	std	Y+4, r25	; 0x04
    1d68:	8b 83       	std	Y+3, r24	; 0x03
    1d6a:	06 c0       	rjmp	.+12     	; 0x1d78 <vListInsert+0x5a>
    1d6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d70:	82 81       	ldd	r24, Z+2	; 0x02
    1d72:	93 81       	ldd	r25, Z+3	; 0x03
    1d74:	9c 83       	std	Y+4, r25	; 0x04
    1d76:	8b 83       	std	Y+3, r24	; 0x03
    1d78:	eb 81       	ldd	r30, Y+3	; 0x03
    1d7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d7c:	02 80       	ldd	r0, Z+2	; 0x02
    1d7e:	f3 81       	ldd	r31, Z+3	; 0x03
    1d80:	e0 2d       	mov	r30, r0
    1d82:	20 81       	ld	r18, Z
    1d84:	31 81       	ldd	r19, Z+1	; 0x01
    1d86:	89 81       	ldd	r24, Y+1	; 0x01
    1d88:	9a 81       	ldd	r25, Y+2	; 0x02
    1d8a:	82 17       	cp	r24, r18
    1d8c:	93 07       	cpc	r25, r19
    1d8e:	70 f7       	brcc	.-36     	; 0x1d6c <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d90:	eb 81       	ldd	r30, Y+3	; 0x03
    1d92:	fc 81       	ldd	r31, Y+4	; 0x04
    1d94:	82 81       	ldd	r24, Z+2	; 0x02
    1d96:	93 81       	ldd	r25, Z+3	; 0x03
    1d98:	ef 81       	ldd	r30, Y+7	; 0x07
    1d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d9c:	93 83       	std	Z+3, r25	; 0x03
    1d9e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1da0:	ef 81       	ldd	r30, Y+7	; 0x07
    1da2:	f8 85       	ldd	r31, Y+8	; 0x08
    1da4:	02 80       	ldd	r0, Z+2	; 0x02
    1da6:	f3 81       	ldd	r31, Z+3	; 0x03
    1da8:	e0 2d       	mov	r30, r0
    1daa:	8f 81       	ldd	r24, Y+7	; 0x07
    1dac:	98 85       	ldd	r25, Y+8	; 0x08
    1dae:	95 83       	std	Z+5, r25	; 0x05
    1db0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1db2:	ef 81       	ldd	r30, Y+7	; 0x07
    1db4:	f8 85       	ldd	r31, Y+8	; 0x08
    1db6:	8b 81       	ldd	r24, Y+3	; 0x03
    1db8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dba:	95 83       	std	Z+5, r25	; 0x05
    1dbc:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1dbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc2:	8f 81       	ldd	r24, Y+7	; 0x07
    1dc4:	98 85       	ldd	r25, Y+8	; 0x08
    1dc6:	93 83       	std	Z+3, r25	; 0x03
    1dc8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1dca:	ef 81       	ldd	r30, Y+7	; 0x07
    1dcc:	f8 85       	ldd	r31, Y+8	; 0x08
    1dce:	8d 81       	ldd	r24, Y+5	; 0x05
    1dd0:	9e 81       	ldd	r25, Y+6	; 0x06
    1dd2:	91 87       	std	Z+9, r25	; 0x09
    1dd4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1dd6:	ed 81       	ldd	r30, Y+5	; 0x05
    1dd8:	fe 81       	ldd	r31, Y+6	; 0x06
    1dda:	80 81       	ld	r24, Z
    1ddc:	8f 5f       	subi	r24, 0xFF	; 255
    1dde:	ed 81       	ldd	r30, Y+5	; 0x05
    1de0:	fe 81       	ldd	r31, Y+6	; 0x06
    1de2:	80 83       	st	Z, r24
}
    1de4:	28 96       	adiw	r28, 0x08	; 8
    1de6:	0f b6       	in	r0, 0x3f	; 63
    1de8:	f8 94       	cli
    1dea:	de bf       	out	0x3e, r29	; 62
    1dec:	0f be       	out	0x3f, r0	; 63
    1dee:	cd bf       	out	0x3d, r28	; 61
    1df0:	cf 91       	pop	r28
    1df2:	df 91       	pop	r29
    1df4:	08 95       	ret

00001df6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1df6:	df 93       	push	r29
    1df8:	cf 93       	push	r28
    1dfa:	00 d0       	rcall	.+0      	; 0x1dfc <uxListRemove+0x6>
    1dfc:	00 d0       	rcall	.+0      	; 0x1dfe <uxListRemove+0x8>
    1dfe:	cd b7       	in	r28, 0x3d	; 61
    1e00:	de b7       	in	r29, 0x3e	; 62
    1e02:	9c 83       	std	Y+4, r25	; 0x04
    1e04:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1e06:	eb 81       	ldd	r30, Y+3	; 0x03
    1e08:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0a:	80 85       	ldd	r24, Z+8	; 0x08
    1e0c:	91 85       	ldd	r25, Z+9	; 0x09
    1e0e:	9a 83       	std	Y+2, r25	; 0x02
    1e10:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e12:	eb 81       	ldd	r30, Y+3	; 0x03
    1e14:	fc 81       	ldd	r31, Y+4	; 0x04
    1e16:	a2 81       	ldd	r26, Z+2	; 0x02
    1e18:	b3 81       	ldd	r27, Z+3	; 0x03
    1e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1e:	84 81       	ldd	r24, Z+4	; 0x04
    1e20:	95 81       	ldd	r25, Z+5	; 0x05
    1e22:	15 96       	adiw	r26, 0x05	; 5
    1e24:	9c 93       	st	X, r25
    1e26:	8e 93       	st	-X, r24
    1e28:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2e:	a4 81       	ldd	r26, Z+4	; 0x04
    1e30:	b5 81       	ldd	r27, Z+5	; 0x05
    1e32:	eb 81       	ldd	r30, Y+3	; 0x03
    1e34:	fc 81       	ldd	r31, Y+4	; 0x04
    1e36:	82 81       	ldd	r24, Z+2	; 0x02
    1e38:	93 81       	ldd	r25, Z+3	; 0x03
    1e3a:	13 96       	adiw	r26, 0x03	; 3
    1e3c:	9c 93       	st	X, r25
    1e3e:	8e 93       	st	-X, r24
    1e40:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1e42:	e9 81       	ldd	r30, Y+1	; 0x01
    1e44:	fa 81       	ldd	r31, Y+2	; 0x02
    1e46:	21 81       	ldd	r18, Z+1	; 0x01
    1e48:	32 81       	ldd	r19, Z+2	; 0x02
    1e4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e4e:	28 17       	cp	r18, r24
    1e50:	39 07       	cpc	r19, r25
    1e52:	41 f4       	brne	.+16     	; 0x1e64 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e54:	eb 81       	ldd	r30, Y+3	; 0x03
    1e56:	fc 81       	ldd	r31, Y+4	; 0x04
    1e58:	84 81       	ldd	r24, Z+4	; 0x04
    1e5a:	95 81       	ldd	r25, Z+5	; 0x05
    1e5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e60:	92 83       	std	Z+2, r25	; 0x02
    1e62:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1e64:	eb 81       	ldd	r30, Y+3	; 0x03
    1e66:	fc 81       	ldd	r31, Y+4	; 0x04
    1e68:	11 86       	std	Z+9, r1	; 0x09
    1e6a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1e6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e70:	80 81       	ld	r24, Z
    1e72:	81 50       	subi	r24, 0x01	; 1
    1e74:	e9 81       	ldd	r30, Y+1	; 0x01
    1e76:	fa 81       	ldd	r31, Y+2	; 0x02
    1e78:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1e7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e7e:	80 81       	ld	r24, Z
}
    1e80:	0f 90       	pop	r0
    1e82:	0f 90       	pop	r0
    1e84:	0f 90       	pop	r0
    1e86:	0f 90       	pop	r0
    1e88:	cf 91       	pop	r28
    1e8a:	df 91       	pop	r29
    1e8c:	08 95       	ret

00001e8e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1e8e:	df 93       	push	r29
    1e90:	cf 93       	push	r28
    1e92:	cd b7       	in	r28, 0x3d	; 61
    1e94:	de b7       	in	r29, 0x3e	; 62
    1e96:	28 97       	sbiw	r28, 0x08	; 8
    1e98:	0f b6       	in	r0, 0x3f	; 63
    1e9a:	f8 94       	cli
    1e9c:	de bf       	out	0x3e, r29	; 62
    1e9e:	0f be       	out	0x3f, r0	; 63
    1ea0:	cd bf       	out	0x3d, r28	; 61
    1ea2:	9c 83       	std	Y+4, r25	; 0x04
    1ea4:	8b 83       	std	Y+3, r24	; 0x03
    1ea6:	7e 83       	std	Y+6, r23	; 0x06
    1ea8:	6d 83       	std	Y+5, r22	; 0x05
    1eaa:	58 87       	std	Y+8, r21	; 0x08
    1eac:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1eae:	eb 81       	ldd	r30, Y+3	; 0x03
    1eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    1eb2:	81 e1       	ldi	r24, 0x11	; 17
    1eb4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1eb6:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eba:	01 97       	sbiw	r24, 0x01	; 1
    1ebc:	9c 83       	std	Y+4, r25	; 0x04
    1ebe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1ec0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ec2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ec4:	82 e2       	ldi	r24, 0x22	; 34
    1ec6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ec8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eca:	9c 81       	ldd	r25, Y+4	; 0x04
    1ecc:	01 97       	sbiw	r24, 0x01	; 1
    1ece:	9c 83       	std	Y+4, r25	; 0x04
    1ed0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1ed2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ed4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed6:	83 e3       	ldi	r24, 0x33	; 51
    1ed8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1eda:	8b 81       	ldd	r24, Y+3	; 0x03
    1edc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ede:	01 97       	sbiw	r24, 0x01	; 1
    1ee0:	9c 83       	std	Y+4, r25	; 0x04
    1ee2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1ee4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ee6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ee8:	9a 83       	std	Y+2, r25	; 0x02
    1eea:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1eec:	89 81       	ldd	r24, Y+1	; 0x01
    1eee:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef8:	01 97       	sbiw	r24, 0x01	; 1
    1efa:	9c 83       	std	Y+4, r25	; 0x04
    1efc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1efe:	89 81       	ldd	r24, Y+1	; 0x01
    1f00:	9a 81       	ldd	r25, Y+2	; 0x02
    1f02:	89 2f       	mov	r24, r25
    1f04:	99 27       	eor	r25, r25
    1f06:	9a 83       	std	Y+2, r25	; 0x02
    1f08:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1f0a:	89 81       	ldd	r24, Y+1	; 0x01
    1f0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f10:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f12:	8b 81       	ldd	r24, Y+3	; 0x03
    1f14:	9c 81       	ldd	r25, Y+4	; 0x04
    1f16:	01 97       	sbiw	r24, 0x01	; 1
    1f18:	9c 83       	std	Y+4, r25	; 0x04
    1f1a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f20:	10 82       	st	Z, r1
	pxTopOfStack--;
    1f22:	8b 81       	ldd	r24, Y+3	; 0x03
    1f24:	9c 81       	ldd	r25, Y+4	; 0x04
    1f26:	01 97       	sbiw	r24, 0x01	; 1
    1f28:	9c 83       	std	Y+4, r25	; 0x04
    1f2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1f2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f30:	80 e8       	ldi	r24, 0x80	; 128
    1f32:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f34:	8b 81       	ldd	r24, Y+3	; 0x03
    1f36:	9c 81       	ldd	r25, Y+4	; 0x04
    1f38:	01 97       	sbiw	r24, 0x01	; 1
    1f3a:	9c 83       	std	Y+4, r25	; 0x04
    1f3c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1f3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f40:	fc 81       	ldd	r31, Y+4	; 0x04
    1f42:	10 82       	st	Z, r1
	pxTopOfStack--;
    1f44:	8b 81       	ldd	r24, Y+3	; 0x03
    1f46:	9c 81       	ldd	r25, Y+4	; 0x04
    1f48:	01 97       	sbiw	r24, 0x01	; 1
    1f4a:	9c 83       	std	Y+4, r25	; 0x04
    1f4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f50:	fc 81       	ldd	r31, Y+4	; 0x04
    1f52:	82 e0       	ldi	r24, 0x02	; 2
    1f54:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f56:	8b 81       	ldd	r24, Y+3	; 0x03
    1f58:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5a:	01 97       	sbiw	r24, 0x01	; 1
    1f5c:	9c 83       	std	Y+4, r25	; 0x04
    1f5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1f60:	eb 81       	ldd	r30, Y+3	; 0x03
    1f62:	fc 81       	ldd	r31, Y+4	; 0x04
    1f64:	83 e0       	ldi	r24, 0x03	; 3
    1f66:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f68:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f6c:	01 97       	sbiw	r24, 0x01	; 1
    1f6e:	9c 83       	std	Y+4, r25	; 0x04
    1f70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1f72:	eb 81       	ldd	r30, Y+3	; 0x03
    1f74:	fc 81       	ldd	r31, Y+4	; 0x04
    1f76:	84 e0       	ldi	r24, 0x04	; 4
    1f78:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f7e:	01 97       	sbiw	r24, 0x01	; 1
    1f80:	9c 83       	std	Y+4, r25	; 0x04
    1f82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1f84:	eb 81       	ldd	r30, Y+3	; 0x03
    1f86:	fc 81       	ldd	r31, Y+4	; 0x04
    1f88:	85 e0       	ldi	r24, 0x05	; 5
    1f8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f90:	01 97       	sbiw	r24, 0x01	; 1
    1f92:	9c 83       	std	Y+4, r25	; 0x04
    1f94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1f96:	eb 81       	ldd	r30, Y+3	; 0x03
    1f98:	fc 81       	ldd	r31, Y+4	; 0x04
    1f9a:	86 e0       	ldi	r24, 0x06	; 6
    1f9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa2:	01 97       	sbiw	r24, 0x01	; 1
    1fa4:	9c 83       	std	Y+4, r25	; 0x04
    1fa6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1fa8:	eb 81       	ldd	r30, Y+3	; 0x03
    1faa:	fc 81       	ldd	r31, Y+4	; 0x04
    1fac:	87 e0       	ldi	r24, 0x07	; 7
    1fae:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb4:	01 97       	sbiw	r24, 0x01	; 1
    1fb6:	9c 83       	std	Y+4, r25	; 0x04
    1fb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1fba:	eb 81       	ldd	r30, Y+3	; 0x03
    1fbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fbe:	88 e0       	ldi	r24, 0x08	; 8
    1fc0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc6:	01 97       	sbiw	r24, 0x01	; 1
    1fc8:	9c 83       	std	Y+4, r25	; 0x04
    1fca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1fcc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fce:	fc 81       	ldd	r31, Y+4	; 0x04
    1fd0:	89 e0       	ldi	r24, 0x09	; 9
    1fd2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fd4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd8:	01 97       	sbiw	r24, 0x01	; 1
    1fda:	9c 83       	std	Y+4, r25	; 0x04
    1fdc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1fde:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe2:	80 e1       	ldi	r24, 0x10	; 16
    1fe4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe8:	9c 81       	ldd	r25, Y+4	; 0x04
    1fea:	01 97       	sbiw	r24, 0x01	; 1
    1fec:	9c 83       	std	Y+4, r25	; 0x04
    1fee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff4:	81 e1       	ldi	r24, 0x11	; 17
    1ff6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffc:	01 97       	sbiw	r24, 0x01	; 1
    1ffe:	9c 83       	std	Y+4, r25	; 0x04
    2000:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2002:	eb 81       	ldd	r30, Y+3	; 0x03
    2004:	fc 81       	ldd	r31, Y+4	; 0x04
    2006:	82 e1       	ldi	r24, 0x12	; 18
    2008:	80 83       	st	Z, r24
	pxTopOfStack--;
    200a:	8b 81       	ldd	r24, Y+3	; 0x03
    200c:	9c 81       	ldd	r25, Y+4	; 0x04
    200e:	01 97       	sbiw	r24, 0x01	; 1
    2010:	9c 83       	std	Y+4, r25	; 0x04
    2012:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2014:	eb 81       	ldd	r30, Y+3	; 0x03
    2016:	fc 81       	ldd	r31, Y+4	; 0x04
    2018:	83 e1       	ldi	r24, 0x13	; 19
    201a:	80 83       	st	Z, r24
	pxTopOfStack--;
    201c:	8b 81       	ldd	r24, Y+3	; 0x03
    201e:	9c 81       	ldd	r25, Y+4	; 0x04
    2020:	01 97       	sbiw	r24, 0x01	; 1
    2022:	9c 83       	std	Y+4, r25	; 0x04
    2024:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2026:	eb 81       	ldd	r30, Y+3	; 0x03
    2028:	fc 81       	ldd	r31, Y+4	; 0x04
    202a:	84 e1       	ldi	r24, 0x14	; 20
    202c:	80 83       	st	Z, r24
	pxTopOfStack--;
    202e:	8b 81       	ldd	r24, Y+3	; 0x03
    2030:	9c 81       	ldd	r25, Y+4	; 0x04
    2032:	01 97       	sbiw	r24, 0x01	; 1
    2034:	9c 83       	std	Y+4, r25	; 0x04
    2036:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2038:	eb 81       	ldd	r30, Y+3	; 0x03
    203a:	fc 81       	ldd	r31, Y+4	; 0x04
    203c:	85 e1       	ldi	r24, 0x15	; 21
    203e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2040:	8b 81       	ldd	r24, Y+3	; 0x03
    2042:	9c 81       	ldd	r25, Y+4	; 0x04
    2044:	01 97       	sbiw	r24, 0x01	; 1
    2046:	9c 83       	std	Y+4, r25	; 0x04
    2048:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    204a:	eb 81       	ldd	r30, Y+3	; 0x03
    204c:	fc 81       	ldd	r31, Y+4	; 0x04
    204e:	86 e1       	ldi	r24, 0x16	; 22
    2050:	80 83       	st	Z, r24
	pxTopOfStack--;
    2052:	8b 81       	ldd	r24, Y+3	; 0x03
    2054:	9c 81       	ldd	r25, Y+4	; 0x04
    2056:	01 97       	sbiw	r24, 0x01	; 1
    2058:	9c 83       	std	Y+4, r25	; 0x04
    205a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    205c:	eb 81       	ldd	r30, Y+3	; 0x03
    205e:	fc 81       	ldd	r31, Y+4	; 0x04
    2060:	87 e1       	ldi	r24, 0x17	; 23
    2062:	80 83       	st	Z, r24
	pxTopOfStack--;
    2064:	8b 81       	ldd	r24, Y+3	; 0x03
    2066:	9c 81       	ldd	r25, Y+4	; 0x04
    2068:	01 97       	sbiw	r24, 0x01	; 1
    206a:	9c 83       	std	Y+4, r25	; 0x04
    206c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    206e:	eb 81       	ldd	r30, Y+3	; 0x03
    2070:	fc 81       	ldd	r31, Y+4	; 0x04
    2072:	88 e1       	ldi	r24, 0x18	; 24
    2074:	80 83       	st	Z, r24
	pxTopOfStack--;
    2076:	8b 81       	ldd	r24, Y+3	; 0x03
    2078:	9c 81       	ldd	r25, Y+4	; 0x04
    207a:	01 97       	sbiw	r24, 0x01	; 1
    207c:	9c 83       	std	Y+4, r25	; 0x04
    207e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2080:	eb 81       	ldd	r30, Y+3	; 0x03
    2082:	fc 81       	ldd	r31, Y+4	; 0x04
    2084:	89 e1       	ldi	r24, 0x19	; 25
    2086:	80 83       	st	Z, r24
	pxTopOfStack--;
    2088:	8b 81       	ldd	r24, Y+3	; 0x03
    208a:	9c 81       	ldd	r25, Y+4	; 0x04
    208c:	01 97       	sbiw	r24, 0x01	; 1
    208e:	9c 83       	std	Y+4, r25	; 0x04
    2090:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2092:	eb 81       	ldd	r30, Y+3	; 0x03
    2094:	fc 81       	ldd	r31, Y+4	; 0x04
    2096:	80 e2       	ldi	r24, 0x20	; 32
    2098:	80 83       	st	Z, r24
	pxTopOfStack--;
    209a:	8b 81       	ldd	r24, Y+3	; 0x03
    209c:	9c 81       	ldd	r25, Y+4	; 0x04
    209e:	01 97       	sbiw	r24, 0x01	; 1
    20a0:	9c 83       	std	Y+4, r25	; 0x04
    20a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    20a4:	eb 81       	ldd	r30, Y+3	; 0x03
    20a6:	fc 81       	ldd	r31, Y+4	; 0x04
    20a8:	81 e2       	ldi	r24, 0x21	; 33
    20aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ac:	8b 81       	ldd	r24, Y+3	; 0x03
    20ae:	9c 81       	ldd	r25, Y+4	; 0x04
    20b0:	01 97       	sbiw	r24, 0x01	; 1
    20b2:	9c 83       	std	Y+4, r25	; 0x04
    20b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    20b6:	eb 81       	ldd	r30, Y+3	; 0x03
    20b8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ba:	82 e2       	ldi	r24, 0x22	; 34
    20bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    20be:	8b 81       	ldd	r24, Y+3	; 0x03
    20c0:	9c 81       	ldd	r25, Y+4	; 0x04
    20c2:	01 97       	sbiw	r24, 0x01	; 1
    20c4:	9c 83       	std	Y+4, r25	; 0x04
    20c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    20c8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ca:	fc 81       	ldd	r31, Y+4	; 0x04
    20cc:	83 e2       	ldi	r24, 0x23	; 35
    20ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    20d0:	8b 81       	ldd	r24, Y+3	; 0x03
    20d2:	9c 81       	ldd	r25, Y+4	; 0x04
    20d4:	01 97       	sbiw	r24, 0x01	; 1
    20d6:	9c 83       	std	Y+4, r25	; 0x04
    20d8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    20da:	8f 81       	ldd	r24, Y+7	; 0x07
    20dc:	98 85       	ldd	r25, Y+8	; 0x08
    20de:	9a 83       	std	Y+2, r25	; 0x02
    20e0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20e2:	89 81       	ldd	r24, Y+1	; 0x01
    20e4:	eb 81       	ldd	r30, Y+3	; 0x03
    20e6:	fc 81       	ldd	r31, Y+4	; 0x04
    20e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ea:	8b 81       	ldd	r24, Y+3	; 0x03
    20ec:	9c 81       	ldd	r25, Y+4	; 0x04
    20ee:	01 97       	sbiw	r24, 0x01	; 1
    20f0:	9c 83       	std	Y+4, r25	; 0x04
    20f2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    20f4:	89 81       	ldd	r24, Y+1	; 0x01
    20f6:	9a 81       	ldd	r25, Y+2	; 0x02
    20f8:	89 2f       	mov	r24, r25
    20fa:	99 27       	eor	r25, r25
    20fc:	9a 83       	std	Y+2, r25	; 0x02
    20fe:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2100:	89 81       	ldd	r24, Y+1	; 0x01
    2102:	eb 81       	ldd	r30, Y+3	; 0x03
    2104:	fc 81       	ldd	r31, Y+4	; 0x04
    2106:	80 83       	st	Z, r24
	pxTopOfStack--;
    2108:	8b 81       	ldd	r24, Y+3	; 0x03
    210a:	9c 81       	ldd	r25, Y+4	; 0x04
    210c:	01 97       	sbiw	r24, 0x01	; 1
    210e:	9c 83       	std	Y+4, r25	; 0x04
    2110:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2112:	eb 81       	ldd	r30, Y+3	; 0x03
    2114:	fc 81       	ldd	r31, Y+4	; 0x04
    2116:	86 e2       	ldi	r24, 0x26	; 38
    2118:	80 83       	st	Z, r24
	pxTopOfStack--;
    211a:	8b 81       	ldd	r24, Y+3	; 0x03
    211c:	9c 81       	ldd	r25, Y+4	; 0x04
    211e:	01 97       	sbiw	r24, 0x01	; 1
    2120:	9c 83       	std	Y+4, r25	; 0x04
    2122:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2124:	eb 81       	ldd	r30, Y+3	; 0x03
    2126:	fc 81       	ldd	r31, Y+4	; 0x04
    2128:	87 e2       	ldi	r24, 0x27	; 39
    212a:	80 83       	st	Z, r24
	pxTopOfStack--;
    212c:	8b 81       	ldd	r24, Y+3	; 0x03
    212e:	9c 81       	ldd	r25, Y+4	; 0x04
    2130:	01 97       	sbiw	r24, 0x01	; 1
    2132:	9c 83       	std	Y+4, r25	; 0x04
    2134:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2136:	eb 81       	ldd	r30, Y+3	; 0x03
    2138:	fc 81       	ldd	r31, Y+4	; 0x04
    213a:	88 e2       	ldi	r24, 0x28	; 40
    213c:	80 83       	st	Z, r24
	pxTopOfStack--;
    213e:	8b 81       	ldd	r24, Y+3	; 0x03
    2140:	9c 81       	ldd	r25, Y+4	; 0x04
    2142:	01 97       	sbiw	r24, 0x01	; 1
    2144:	9c 83       	std	Y+4, r25	; 0x04
    2146:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2148:	eb 81       	ldd	r30, Y+3	; 0x03
    214a:	fc 81       	ldd	r31, Y+4	; 0x04
    214c:	89 e2       	ldi	r24, 0x29	; 41
    214e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2150:	8b 81       	ldd	r24, Y+3	; 0x03
    2152:	9c 81       	ldd	r25, Y+4	; 0x04
    2154:	01 97       	sbiw	r24, 0x01	; 1
    2156:	9c 83       	std	Y+4, r25	; 0x04
    2158:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    215a:	eb 81       	ldd	r30, Y+3	; 0x03
    215c:	fc 81       	ldd	r31, Y+4	; 0x04
    215e:	80 e3       	ldi	r24, 0x30	; 48
    2160:	80 83       	st	Z, r24
	pxTopOfStack--;
    2162:	8b 81       	ldd	r24, Y+3	; 0x03
    2164:	9c 81       	ldd	r25, Y+4	; 0x04
    2166:	01 97       	sbiw	r24, 0x01	; 1
    2168:	9c 83       	std	Y+4, r25	; 0x04
    216a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    216c:	eb 81       	ldd	r30, Y+3	; 0x03
    216e:	fc 81       	ldd	r31, Y+4	; 0x04
    2170:	81 e3       	ldi	r24, 0x31	; 49
    2172:	80 83       	st	Z, r24
	pxTopOfStack--;
    2174:	8b 81       	ldd	r24, Y+3	; 0x03
    2176:	9c 81       	ldd	r25, Y+4	; 0x04
    2178:	01 97       	sbiw	r24, 0x01	; 1
    217a:	9c 83       	std	Y+4, r25	; 0x04
    217c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    217e:	8b 81       	ldd	r24, Y+3	; 0x03
    2180:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2182:	28 96       	adiw	r28, 0x08	; 8
    2184:	0f b6       	in	r0, 0x3f	; 63
    2186:	f8 94       	cli
    2188:	de bf       	out	0x3e, r29	; 62
    218a:	0f be       	out	0x3f, r0	; 63
    218c:	cd bf       	out	0x3d, r28	; 61
    218e:	cf 91       	pop	r28
    2190:	df 91       	pop	r29
    2192:	08 95       	ret

00002194 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2194:	df 93       	push	r29
    2196:	cf 93       	push	r28
    2198:	cd b7       	in	r28, 0x3d	; 61
    219a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    219c:	0e 94 bc 11 	call	0x2378	; 0x2378 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    21a0:	a0 91 bb 0b 	lds	r26, 0x0BBB
    21a4:	b0 91 bc 0b 	lds	r27, 0x0BBC
    21a8:	cd 91       	ld	r28, X+
    21aa:	cd bf       	out	0x3d, r28	; 61
    21ac:	dd 91       	ld	r29, X+
    21ae:	de bf       	out	0x3e, r29	; 62
    21b0:	ff 91       	pop	r31
    21b2:	ef 91       	pop	r30
    21b4:	df 91       	pop	r29
    21b6:	cf 91       	pop	r28
    21b8:	bf 91       	pop	r27
    21ba:	af 91       	pop	r26
    21bc:	9f 91       	pop	r25
    21be:	8f 91       	pop	r24
    21c0:	7f 91       	pop	r23
    21c2:	6f 91       	pop	r22
    21c4:	5f 91       	pop	r21
    21c6:	4f 91       	pop	r20
    21c8:	3f 91       	pop	r19
    21ca:	2f 91       	pop	r18
    21cc:	1f 91       	pop	r17
    21ce:	0f 91       	pop	r16
    21d0:	ff 90       	pop	r15
    21d2:	ef 90       	pop	r14
    21d4:	df 90       	pop	r13
    21d6:	cf 90       	pop	r12
    21d8:	bf 90       	pop	r11
    21da:	af 90       	pop	r10
    21dc:	9f 90       	pop	r9
    21de:	8f 90       	pop	r8
    21e0:	7f 90       	pop	r7
    21e2:	6f 90       	pop	r6
    21e4:	5f 90       	pop	r5
    21e6:	4f 90       	pop	r4
    21e8:	3f 90       	pop	r3
    21ea:	2f 90       	pop	r2
    21ec:	1f 90       	pop	r1
    21ee:	0f 90       	pop	r0
    21f0:	0f be       	out	0x3f, r0	; 63
    21f2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    21f4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    21f6:	81 e0       	ldi	r24, 0x01	; 1
}
    21f8:	cf 91       	pop	r28
    21fa:	df 91       	pop	r29
    21fc:	08 95       	ret

000021fe <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    21fe:	df 93       	push	r29
    2200:	cf 93       	push	r28
    2202:	cd b7       	in	r28, 0x3d	; 61
    2204:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2206:	cf 91       	pop	r28
    2208:	df 91       	pop	r29
    220a:	08 95       	ret

0000220c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    220c:	0f 92       	push	r0
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	0f 92       	push	r0
    2214:	1f 92       	push	r1
    2216:	11 24       	eor	r1, r1
    2218:	2f 92       	push	r2
    221a:	3f 92       	push	r3
    221c:	4f 92       	push	r4
    221e:	5f 92       	push	r5
    2220:	6f 92       	push	r6
    2222:	7f 92       	push	r7
    2224:	8f 92       	push	r8
    2226:	9f 92       	push	r9
    2228:	af 92       	push	r10
    222a:	bf 92       	push	r11
    222c:	cf 92       	push	r12
    222e:	df 92       	push	r13
    2230:	ef 92       	push	r14
    2232:	ff 92       	push	r15
    2234:	0f 93       	push	r16
    2236:	1f 93       	push	r17
    2238:	2f 93       	push	r18
    223a:	3f 93       	push	r19
    223c:	4f 93       	push	r20
    223e:	5f 93       	push	r21
    2240:	6f 93       	push	r22
    2242:	7f 93       	push	r23
    2244:	8f 93       	push	r24
    2246:	9f 93       	push	r25
    2248:	af 93       	push	r26
    224a:	bf 93       	push	r27
    224c:	cf 93       	push	r28
    224e:	df 93       	push	r29
    2250:	ef 93       	push	r30
    2252:	ff 93       	push	r31
    2254:	a0 91 bb 0b 	lds	r26, 0x0BBB
    2258:	b0 91 bc 0b 	lds	r27, 0x0BBC
    225c:	0d b6       	in	r0, 0x3d	; 61
    225e:	0d 92       	st	X+, r0
    2260:	0e b6       	in	r0, 0x3e	; 62
    2262:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2264:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2268:	a0 91 bb 0b 	lds	r26, 0x0BBB
    226c:	b0 91 bc 0b 	lds	r27, 0x0BBC
    2270:	cd 91       	ld	r28, X+
    2272:	cd bf       	out	0x3d, r28	; 61
    2274:	dd 91       	ld	r29, X+
    2276:	de bf       	out	0x3e, r29	; 62
    2278:	ff 91       	pop	r31
    227a:	ef 91       	pop	r30
    227c:	df 91       	pop	r29
    227e:	cf 91       	pop	r28
    2280:	bf 91       	pop	r27
    2282:	af 91       	pop	r26
    2284:	9f 91       	pop	r25
    2286:	8f 91       	pop	r24
    2288:	7f 91       	pop	r23
    228a:	6f 91       	pop	r22
    228c:	5f 91       	pop	r21
    228e:	4f 91       	pop	r20
    2290:	3f 91       	pop	r19
    2292:	2f 91       	pop	r18
    2294:	1f 91       	pop	r17
    2296:	0f 91       	pop	r16
    2298:	ff 90       	pop	r15
    229a:	ef 90       	pop	r14
    229c:	df 90       	pop	r13
    229e:	cf 90       	pop	r12
    22a0:	bf 90       	pop	r11
    22a2:	af 90       	pop	r10
    22a4:	9f 90       	pop	r9
    22a6:	8f 90       	pop	r8
    22a8:	7f 90       	pop	r7
    22aa:	6f 90       	pop	r6
    22ac:	5f 90       	pop	r5
    22ae:	4f 90       	pop	r4
    22b0:	3f 90       	pop	r3
    22b2:	2f 90       	pop	r2
    22b4:	1f 90       	pop	r1
    22b6:	0f 90       	pop	r0
    22b8:	0f be       	out	0x3f, r0	; 63
    22ba:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22bc:	08 95       	ret

000022be <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22be:	0f 92       	push	r0
    22c0:	0f b6       	in	r0, 0x3f	; 63
    22c2:	f8 94       	cli
    22c4:	0f 92       	push	r0
    22c6:	1f 92       	push	r1
    22c8:	11 24       	eor	r1, r1
    22ca:	2f 92       	push	r2
    22cc:	3f 92       	push	r3
    22ce:	4f 92       	push	r4
    22d0:	5f 92       	push	r5
    22d2:	6f 92       	push	r6
    22d4:	7f 92       	push	r7
    22d6:	8f 92       	push	r8
    22d8:	9f 92       	push	r9
    22da:	af 92       	push	r10
    22dc:	bf 92       	push	r11
    22de:	cf 92       	push	r12
    22e0:	df 92       	push	r13
    22e2:	ef 92       	push	r14
    22e4:	ff 92       	push	r15
    22e6:	0f 93       	push	r16
    22e8:	1f 93       	push	r17
    22ea:	2f 93       	push	r18
    22ec:	3f 93       	push	r19
    22ee:	4f 93       	push	r20
    22f0:	5f 93       	push	r21
    22f2:	6f 93       	push	r22
    22f4:	7f 93       	push	r23
    22f6:	8f 93       	push	r24
    22f8:	9f 93       	push	r25
    22fa:	af 93       	push	r26
    22fc:	bf 93       	push	r27
    22fe:	cf 93       	push	r28
    2300:	df 93       	push	r29
    2302:	ef 93       	push	r30
    2304:	ff 93       	push	r31
    2306:	a0 91 bb 0b 	lds	r26, 0x0BBB
    230a:	b0 91 bc 0b 	lds	r27, 0x0BBC
    230e:	0d b6       	in	r0, 0x3d	; 61
    2310:	0d 92       	st	X+, r0
    2312:	0e b6       	in	r0, 0x3e	; 62
    2314:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2316:	0e 94 c4 1c 	call	0x3988	; 0x3988 <xTaskIncrementTick>
    231a:	88 23       	and	r24, r24
    231c:	11 f0       	breq	.+4      	; 0x2322 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    231e:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2322:	a0 91 bb 0b 	lds	r26, 0x0BBB
    2326:	b0 91 bc 0b 	lds	r27, 0x0BBC
    232a:	cd 91       	ld	r28, X+
    232c:	cd bf       	out	0x3d, r28	; 61
    232e:	dd 91       	ld	r29, X+
    2330:	de bf       	out	0x3e, r29	; 62
    2332:	ff 91       	pop	r31
    2334:	ef 91       	pop	r30
    2336:	df 91       	pop	r29
    2338:	cf 91       	pop	r28
    233a:	bf 91       	pop	r27
    233c:	af 91       	pop	r26
    233e:	9f 91       	pop	r25
    2340:	8f 91       	pop	r24
    2342:	7f 91       	pop	r23
    2344:	6f 91       	pop	r22
    2346:	5f 91       	pop	r21
    2348:	4f 91       	pop	r20
    234a:	3f 91       	pop	r19
    234c:	2f 91       	pop	r18
    234e:	1f 91       	pop	r17
    2350:	0f 91       	pop	r16
    2352:	ff 90       	pop	r15
    2354:	ef 90       	pop	r14
    2356:	df 90       	pop	r13
    2358:	cf 90       	pop	r12
    235a:	bf 90       	pop	r11
    235c:	af 90       	pop	r10
    235e:	9f 90       	pop	r9
    2360:	8f 90       	pop	r8
    2362:	7f 90       	pop	r7
    2364:	6f 90       	pop	r6
    2366:	5f 90       	pop	r5
    2368:	4f 90       	pop	r4
    236a:	3f 90       	pop	r3
    236c:	2f 90       	pop	r2
    236e:	1f 90       	pop	r1
    2370:	0f 90       	pop	r0
    2372:	0f be       	out	0x3f, r0	; 63
    2374:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2376:	08 95       	ret

00002378 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2378:	df 93       	push	r29
    237a:	cf 93       	push	r28
    237c:	00 d0       	rcall	.+0      	; 0x237e <prvSetupTimerInterrupt+0x6>
    237e:	00 d0       	rcall	.+0      	; 0x2380 <prvSetupTimerInterrupt+0x8>
    2380:	00 d0       	rcall	.+0      	; 0x2382 <prvSetupTimerInterrupt+0xa>
    2382:	cd b7       	in	r28, 0x3d	; 61
    2384:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2386:	80 e4       	ldi	r24, 0x40	; 64
    2388:	9f e1       	ldi	r25, 0x1F	; 31
    238a:	a0 e0       	ldi	r26, 0x00	; 0
    238c:	b0 e0       	ldi	r27, 0x00	; 0
    238e:	8b 83       	std	Y+3, r24	; 0x03
    2390:	9c 83       	std	Y+4, r25	; 0x04
    2392:	ad 83       	std	Y+5, r26	; 0x05
    2394:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2396:	8b 81       	ldd	r24, Y+3	; 0x03
    2398:	9c 81       	ldd	r25, Y+4	; 0x04
    239a:	ad 81       	ldd	r26, Y+5	; 0x05
    239c:	be 81       	ldd	r27, Y+6	; 0x06
    239e:	68 94       	set
    23a0:	15 f8       	bld	r1, 5
    23a2:	b6 95       	lsr	r27
    23a4:	a7 95       	ror	r26
    23a6:	97 95       	ror	r25
    23a8:	87 95       	ror	r24
    23aa:	16 94       	lsr	r1
    23ac:	d1 f7       	brne	.-12     	; 0x23a2 <prvSetupTimerInterrupt+0x2a>
    23ae:	8b 83       	std	Y+3, r24	; 0x03
    23b0:	9c 83       	std	Y+4, r25	; 0x04
    23b2:	ad 83       	std	Y+5, r26	; 0x05
    23b4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    23b6:	8b 81       	ldd	r24, Y+3	; 0x03
    23b8:	9c 81       	ldd	r25, Y+4	; 0x04
    23ba:	ad 81       	ldd	r26, Y+5	; 0x05
    23bc:	be 81       	ldd	r27, Y+6	; 0x06
    23be:	01 97       	sbiw	r24, 0x01	; 1
    23c0:	a1 09       	sbc	r26, r1
    23c2:	b1 09       	sbc	r27, r1
    23c4:	8b 83       	std	Y+3, r24	; 0x03
    23c6:	9c 83       	std	Y+4, r25	; 0x04
    23c8:	ad 83       	std	Y+5, r26	; 0x05
    23ca:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    23cc:	8b 81       	ldd	r24, Y+3	; 0x03
    23ce:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    23d0:	8b 81       	ldd	r24, Y+3	; 0x03
    23d2:	9c 81       	ldd	r25, Y+4	; 0x04
    23d4:	ad 81       	ldd	r26, Y+5	; 0x05
    23d6:	be 81       	ldd	r27, Y+6	; 0x06
    23d8:	89 2f       	mov	r24, r25
    23da:	9a 2f       	mov	r25, r26
    23dc:	ab 2f       	mov	r26, r27
    23de:	bb 27       	eor	r27, r27
    23e0:	8b 83       	std	Y+3, r24	; 0x03
    23e2:	9c 83       	std	Y+4, r25	; 0x04
    23e4:	ad 83       	std	Y+5, r26	; 0x05
    23e6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    23e8:	8b 81       	ldd	r24, Y+3	; 0x03
    23ea:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    23ec:	eb e4       	ldi	r30, 0x4B	; 75
    23ee:	f0 e0       	ldi	r31, 0x00	; 0
    23f0:	8a 81       	ldd	r24, Y+2	; 0x02
    23f2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    23f4:	ea e4       	ldi	r30, 0x4A	; 74
    23f6:	f0 e0       	ldi	r31, 0x00	; 0
    23f8:	89 81       	ldd	r24, Y+1	; 0x01
    23fa:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    23fc:	8b e0       	ldi	r24, 0x0B	; 11
    23fe:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2400:	ee e4       	ldi	r30, 0x4E	; 78
    2402:	f0 e0       	ldi	r31, 0x00	; 0
    2404:	89 81       	ldd	r24, Y+1	; 0x01
    2406:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2408:	e7 e5       	ldi	r30, 0x57	; 87
    240a:	f0 e0       	ldi	r31, 0x00	; 0
    240c:	80 81       	ld	r24, Z
    240e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2410:	89 81       	ldd	r24, Y+1	; 0x01
    2412:	80 61       	ori	r24, 0x10	; 16
    2414:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2416:	e7 e5       	ldi	r30, 0x57	; 87
    2418:	f0 e0       	ldi	r31, 0x00	; 0
    241a:	89 81       	ldd	r24, Y+1	; 0x01
    241c:	80 83       	st	Z, r24
}
    241e:	26 96       	adiw	r28, 0x06	; 6
    2420:	0f b6       	in	r0, 0x3f	; 63
    2422:	f8 94       	cli
    2424:	de bf       	out	0x3e, r29	; 62
    2426:	0f be       	out	0x3f, r0	; 63
    2428:	cd bf       	out	0x3d, r28	; 61
    242a:	cf 91       	pop	r28
    242c:	df 91       	pop	r29
    242e:	08 95       	ret

00002430 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2430:	0e 94 5f 11 	call	0x22be	; 0x22be <vPortYieldFromTick>
		asm volatile ( "reti" );
    2434:	18 95       	reti

00002436 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2436:	df 93       	push	r29
    2438:	cf 93       	push	r28
    243a:	00 d0       	rcall	.+0      	; 0x243c <xQueueGenericReset+0x6>
    243c:	00 d0       	rcall	.+0      	; 0x243e <xQueueGenericReset+0x8>
    243e:	0f 92       	push	r0
    2440:	cd b7       	in	r28, 0x3d	; 61
    2442:	de b7       	in	r29, 0x3e	; 62
    2444:	9c 83       	std	Y+4, r25	; 0x04
    2446:	8b 83       	std	Y+3, r24	; 0x03
    2448:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	9a 83       	std	Y+2, r25	; 0x02
    2450:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2452:	0f b6       	in	r0, 0x3f	; 63
    2454:	f8 94       	cli
    2456:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2458:	e9 81       	ldd	r30, Y+1	; 0x01
    245a:	fa 81       	ldd	r31, Y+2	; 0x02
    245c:	40 81       	ld	r20, Z
    245e:	51 81       	ldd	r21, Z+1	; 0x01
    2460:	e9 81       	ldd	r30, Y+1	; 0x01
    2462:	fa 81       	ldd	r31, Y+2	; 0x02
    2464:	83 8d       	ldd	r24, Z+27	; 0x1b
    2466:	28 2f       	mov	r18, r24
    2468:	30 e0       	ldi	r19, 0x00	; 0
    246a:	e9 81       	ldd	r30, Y+1	; 0x01
    246c:	fa 81       	ldd	r31, Y+2	; 0x02
    246e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2470:	88 2f       	mov	r24, r24
    2472:	90 e0       	ldi	r25, 0x00	; 0
    2474:	bc 01       	movw	r22, r24
    2476:	26 9f       	mul	r18, r22
    2478:	c0 01       	movw	r24, r0
    247a:	27 9f       	mul	r18, r23
    247c:	90 0d       	add	r25, r0
    247e:	36 9f       	mul	r19, r22
    2480:	90 0d       	add	r25, r0
    2482:	11 24       	eor	r1, r1
    2484:	84 0f       	add	r24, r20
    2486:	95 1f       	adc	r25, r21
    2488:	e9 81       	ldd	r30, Y+1	; 0x01
    248a:	fa 81       	ldd	r31, Y+2	; 0x02
    248c:	93 83       	std	Z+3, r25	; 0x03
    248e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2490:	e9 81       	ldd	r30, Y+1	; 0x01
    2492:	fa 81       	ldd	r31, Y+2	; 0x02
    2494:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2496:	e9 81       	ldd	r30, Y+1	; 0x01
    2498:	fa 81       	ldd	r31, Y+2	; 0x02
    249a:	80 81       	ld	r24, Z
    249c:	91 81       	ldd	r25, Z+1	; 0x01
    249e:	e9 81       	ldd	r30, Y+1	; 0x01
    24a0:	fa 81       	ldd	r31, Y+2	; 0x02
    24a2:	95 83       	std	Z+5, r25	; 0x05
    24a4:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    24a6:	e9 81       	ldd	r30, Y+1	; 0x01
    24a8:	fa 81       	ldd	r31, Y+2	; 0x02
    24aa:	40 81       	ld	r20, Z
    24ac:	51 81       	ldd	r21, Z+1	; 0x01
    24ae:	e9 81       	ldd	r30, Y+1	; 0x01
    24b0:	fa 81       	ldd	r31, Y+2	; 0x02
    24b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    24b4:	88 2f       	mov	r24, r24
    24b6:	90 e0       	ldi	r25, 0x00	; 0
    24b8:	9c 01       	movw	r18, r24
    24ba:	21 50       	subi	r18, 0x01	; 1
    24bc:	30 40       	sbci	r19, 0x00	; 0
    24be:	e9 81       	ldd	r30, Y+1	; 0x01
    24c0:	fa 81       	ldd	r31, Y+2	; 0x02
    24c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    24c4:	88 2f       	mov	r24, r24
    24c6:	90 e0       	ldi	r25, 0x00	; 0
    24c8:	bc 01       	movw	r22, r24
    24ca:	26 9f       	mul	r18, r22
    24cc:	c0 01       	movw	r24, r0
    24ce:	27 9f       	mul	r18, r23
    24d0:	90 0d       	add	r25, r0
    24d2:	36 9f       	mul	r19, r22
    24d4:	90 0d       	add	r25, r0
    24d6:	11 24       	eor	r1, r1
    24d8:	84 0f       	add	r24, r20
    24da:	95 1f       	adc	r25, r21
    24dc:	e9 81       	ldd	r30, Y+1	; 0x01
    24de:	fa 81       	ldd	r31, Y+2	; 0x02
    24e0:	97 83       	std	Z+7, r25	; 0x07
    24e2:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    24e4:	e9 81       	ldd	r30, Y+1	; 0x01
    24e6:	fa 81       	ldd	r31, Y+2	; 0x02
    24e8:	8f ef       	ldi	r24, 0xFF	; 255
    24ea:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    24ec:	e9 81       	ldd	r30, Y+1	; 0x01
    24ee:	fa 81       	ldd	r31, Y+2	; 0x02
    24f0:	8f ef       	ldi	r24, 0xFF	; 255
    24f2:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    24f4:	8d 81       	ldd	r24, Y+5	; 0x05
    24f6:	88 23       	and	r24, r24
    24f8:	79 f4       	brne	.+30     	; 0x2518 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24fa:	e9 81       	ldd	r30, Y+1	; 0x01
    24fc:	fa 81       	ldd	r31, Y+2	; 0x02
    24fe:	80 85       	ldd	r24, Z+8	; 0x08
    2500:	88 23       	and	r24, r24
    2502:	a1 f0       	breq	.+40     	; 0x252c <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2504:	89 81       	ldd	r24, Y+1	; 0x01
    2506:	9a 81       	ldd	r25, Y+2	; 0x02
    2508:	08 96       	adiw	r24, 0x08	; 8
    250a:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    250e:	81 30       	cpi	r24, 0x01	; 1
    2510:	69 f4       	brne	.+26     	; 0x252c <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2512:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
    2516:	0a c0       	rjmp	.+20     	; 0x252c <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2518:	89 81       	ldd	r24, Y+1	; 0x01
    251a:	9a 81       	ldd	r25, Y+2	; 0x02
    251c:	08 96       	adiw	r24, 0x08	; 8
    251e:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2522:	89 81       	ldd	r24, Y+1	; 0x01
    2524:	9a 81       	ldd	r25, Y+2	; 0x02
    2526:	41 96       	adiw	r24, 0x11	; 17
    2528:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    252c:	0f 90       	pop	r0
    252e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2530:	81 e0       	ldi	r24, 0x01	; 1
}
    2532:	0f 90       	pop	r0
    2534:	0f 90       	pop	r0
    2536:	0f 90       	pop	r0
    2538:	0f 90       	pop	r0
    253a:	0f 90       	pop	r0
    253c:	cf 91       	pop	r28
    253e:	df 91       	pop	r29
    2540:	08 95       	ret

00002542 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2542:	df 93       	push	r29
    2544:	cf 93       	push	r28
    2546:	cd b7       	in	r28, 0x3d	; 61
    2548:	de b7       	in	r29, 0x3e	; 62
    254a:	29 97       	sbiw	r28, 0x09	; 9
    254c:	0f b6       	in	r0, 0x3f	; 63
    254e:	f8 94       	cli
    2550:	de bf       	out	0x3e, r29	; 62
    2552:	0f be       	out	0x3f, r0	; 63
    2554:	cd bf       	out	0x3d, r28	; 61
    2556:	8f 83       	std	Y+7, r24	; 0x07
    2558:	68 87       	std	Y+8, r22	; 0x08
    255a:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    255c:	1a 82       	std	Y+2, r1	; 0x02
    255e:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    2560:	8f 81       	ldd	r24, Y+7	; 0x07
    2562:	88 23       	and	r24, r24
    2564:	09 f4       	brne	.+2      	; 0x2568 <xQueueGenericCreate+0x26>
    2566:	3f c0       	rjmp	.+126    	; 0x25e6 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    2568:	8f e1       	ldi	r24, 0x1F	; 31
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	0e 94 c3 0c 	call	0x1986	; 0x1986 <pvPortMalloc>
    2570:	9e 83       	std	Y+6, r25	; 0x06
    2572:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2574:	8d 81       	ldd	r24, Y+5	; 0x05
    2576:	9e 81       	ldd	r25, Y+6	; 0x06
    2578:	00 97       	sbiw	r24, 0x00	; 0
    257a:	a9 f1       	breq	.+106    	; 0x25e6 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    257c:	8f 81       	ldd	r24, Y+7	; 0x07
    257e:	28 2f       	mov	r18, r24
    2580:	30 e0       	ldi	r19, 0x00	; 0
    2582:	88 85       	ldd	r24, Y+8	; 0x08
    2584:	88 2f       	mov	r24, r24
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	ac 01       	movw	r20, r24
    258a:	24 9f       	mul	r18, r20
    258c:	c0 01       	movw	r24, r0
    258e:	25 9f       	mul	r18, r21
    2590:	90 0d       	add	r25, r0
    2592:	34 9f       	mul	r19, r20
    2594:	90 0d       	add	r25, r0
    2596:	11 24       	eor	r1, r1
    2598:	01 96       	adiw	r24, 0x01	; 1
    259a:	9c 83       	std	Y+4, r25	; 0x04
    259c:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    259e:	8b 81       	ldd	r24, Y+3	; 0x03
    25a0:	9c 81       	ldd	r25, Y+4	; 0x04
    25a2:	0e 94 c3 0c 	call	0x1986	; 0x1986 <pvPortMalloc>
    25a6:	ed 81       	ldd	r30, Y+5	; 0x05
    25a8:	fe 81       	ldd	r31, Y+6	; 0x06
    25aa:	91 83       	std	Z+1, r25	; 0x01
    25ac:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    25ae:	ed 81       	ldd	r30, Y+5	; 0x05
    25b0:	fe 81       	ldd	r31, Y+6	; 0x06
    25b2:	80 81       	ld	r24, Z
    25b4:	91 81       	ldd	r25, Z+1	; 0x01
    25b6:	00 97       	sbiw	r24, 0x00	; 0
    25b8:	91 f0       	breq	.+36     	; 0x25de <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    25ba:	ed 81       	ldd	r30, Y+5	; 0x05
    25bc:	fe 81       	ldd	r31, Y+6	; 0x06
    25be:	8f 81       	ldd	r24, Y+7	; 0x07
    25c0:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    25c2:	ed 81       	ldd	r30, Y+5	; 0x05
    25c4:	fe 81       	ldd	r31, Y+6	; 0x06
    25c6:	88 85       	ldd	r24, Y+8	; 0x08
    25c8:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    25ca:	8d 81       	ldd	r24, Y+5	; 0x05
    25cc:	9e 81       	ldd	r25, Y+6	; 0x06
    25ce:	61 e0       	ldi	r22, 0x01	; 1
    25d0:	0e 94 1b 12 	call	0x2436	; 0x2436 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    25d4:	8d 81       	ldd	r24, Y+5	; 0x05
    25d6:	9e 81       	ldd	r25, Y+6	; 0x06
    25d8:	9a 83       	std	Y+2, r25	; 0x02
    25da:	89 83       	std	Y+1, r24	; 0x01
    25dc:	04 c0       	rjmp	.+8      	; 0x25e6 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    25de:	8d 81       	ldd	r24, Y+5	; 0x05
    25e0:	9e 81       	ldd	r25, Y+6	; 0x06
    25e2:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    25e6:	89 81       	ldd	r24, Y+1	; 0x01
    25e8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    25ea:	29 96       	adiw	r28, 0x09	; 9
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	de bf       	out	0x3e, r29	; 62
    25f2:	0f be       	out	0x3f, r0	; 63
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	08 95       	ret

000025fc <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    25fc:	df 93       	push	r29
    25fe:	cf 93       	push	r28
    2600:	00 d0       	rcall	.+0      	; 0x2602 <xQueueCreateMutex+0x6>
    2602:	0f 92       	push	r0
    2604:	cd b7       	in	r28, 0x3d	; 61
    2606:	de b7       	in	r29, 0x3e	; 62
    2608:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    260a:	8f e1       	ldi	r24, 0x1F	; 31
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	0e 94 c3 0c 	call	0x1986	; 0x1986 <pvPortMalloc>
    2612:	9a 83       	std	Y+2, r25	; 0x02
    2614:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    2616:	89 81       	ldd	r24, Y+1	; 0x01
    2618:	9a 81       	ldd	r25, Y+2	; 0x02
    261a:	00 97       	sbiw	r24, 0x00	; 0
    261c:	a9 f1       	breq	.+106    	; 0x2688 <xQueueCreateMutex+0x8c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    261e:	e9 81       	ldd	r30, Y+1	; 0x01
    2620:	fa 81       	ldd	r31, Y+2	; 0x02
    2622:	13 82       	std	Z+3, r1	; 0x03
    2624:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    2626:	e9 81       	ldd	r30, Y+1	; 0x01
    2628:	fa 81       	ldd	r31, Y+2	; 0x02
    262a:	11 82       	std	Z+1, r1	; 0x01
    262c:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    262e:	e9 81       	ldd	r30, Y+1	; 0x01
    2630:	fa 81       	ldd	r31, Y+2	; 0x02
    2632:	15 82       	std	Z+5, r1	; 0x05
    2634:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    2636:	e9 81       	ldd	r30, Y+1	; 0x01
    2638:	fa 81       	ldd	r31, Y+2	; 0x02
    263a:	17 82       	std	Z+7, r1	; 0x07
    263c:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    2644:	e9 81       	ldd	r30, Y+1	; 0x01
    2646:	fa 81       	ldd	r31, Y+2	; 0x02
    2648:	81 e0       	ldi	r24, 0x01	; 1
    264a:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    264c:	e9 81       	ldd	r30, Y+1	; 0x01
    264e:	fa 81       	ldd	r31, Y+2	; 0x02
    2650:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    2652:	e9 81       	ldd	r30, Y+1	; 0x01
    2654:	fa 81       	ldd	r31, Y+2	; 0x02
    2656:	8f ef       	ldi	r24, 0xFF	; 255
    2658:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    265a:	e9 81       	ldd	r30, Y+1	; 0x01
    265c:	fa 81       	ldd	r31, Y+2	; 0x02
    265e:	8f ef       	ldi	r24, 0xFF	; 255
    2660:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2662:	89 81       	ldd	r24, Y+1	; 0x01
    2664:	9a 81       	ldd	r25, Y+2	; 0x02
    2666:	08 96       	adiw	r24, 0x08	; 8
    2668:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    266c:	89 81       	ldd	r24, Y+1	; 0x01
    266e:	9a 81       	ldd	r25, Y+2	; 0x02
    2670:	41 96       	adiw	r24, 0x11	; 17
    2672:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    2676:	89 81       	ldd	r24, Y+1	; 0x01
    2678:	9a 81       	ldd	r25, Y+2	; 0x02
    267a:	60 e0       	ldi	r22, 0x00	; 0
    267c:	70 e0       	ldi	r23, 0x00	; 0
    267e:	40 e0       	ldi	r20, 0x00	; 0
    2680:	50 e0       	ldi	r21, 0x00	; 0
    2682:	20 e0       	ldi	r18, 0x00	; 0
    2684:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    2688:	89 81       	ldd	r24, Y+1	; 0x01
    268a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    268c:	0f 90       	pop	r0
    268e:	0f 90       	pop	r0
    2690:	0f 90       	pop	r0
    2692:	cf 91       	pop	r28
    2694:	df 91       	pop	r29
    2696:	08 95       	ret

00002698 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    2698:	df 93       	push	r29
    269a:	cf 93       	push	r28
    269c:	00 d0       	rcall	.+0      	; 0x269e <xQueueCreateCountingSemaphore+0x6>
    269e:	00 d0       	rcall	.+0      	; 0x26a0 <xQueueCreateCountingSemaphore+0x8>
    26a0:	cd b7       	in	r28, 0x3d	; 61
    26a2:	de b7       	in	r29, 0x3e	; 62
    26a4:	8b 83       	std	Y+3, r24	; 0x03
    26a6:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    26a8:	8b 81       	ldd	r24, Y+3	; 0x03
    26aa:	60 e0       	ldi	r22, 0x00	; 0
    26ac:	42 e0       	ldi	r20, 0x02	; 2
    26ae:	0e 94 a1 12 	call	0x2542	; 0x2542 <xQueueGenericCreate>
    26b2:	9a 83       	std	Y+2, r25	; 0x02
    26b4:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    26b6:	89 81       	ldd	r24, Y+1	; 0x01
    26b8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ba:	00 97       	sbiw	r24, 0x00	; 0
    26bc:	21 f0       	breq	.+8      	; 0x26c6 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    26be:	e9 81       	ldd	r30, Y+1	; 0x01
    26c0:	fa 81       	ldd	r31, Y+2	; 0x02
    26c2:	8c 81       	ldd	r24, Y+4	; 0x04
    26c4:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    26c6:	89 81       	ldd	r24, Y+1	; 0x01
    26c8:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    26ca:	0f 90       	pop	r0
    26cc:	0f 90       	pop	r0
    26ce:	0f 90       	pop	r0
    26d0:	0f 90       	pop	r0
    26d2:	cf 91       	pop	r28
    26d4:	df 91       	pop	r29
    26d6:	08 95       	ret

000026d8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    26d8:	df 93       	push	r29
    26da:	cf 93       	push	r28
    26dc:	cd b7       	in	r28, 0x3d	; 61
    26de:	de b7       	in	r29, 0x3e	; 62
    26e0:	2f 97       	sbiw	r28, 0x0f	; 15
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	f8 94       	cli
    26e6:	de bf       	out	0x3e, r29	; 62
    26e8:	0f be       	out	0x3f, r0	; 63
    26ea:	cd bf       	out	0x3d, r28	; 61
    26ec:	99 87       	std	Y+9, r25	; 0x09
    26ee:	88 87       	std	Y+8, r24	; 0x08
    26f0:	7b 87       	std	Y+11, r23	; 0x0b
    26f2:	6a 87       	std	Y+10, r22	; 0x0a
    26f4:	5d 87       	std	Y+13, r21	; 0x0d
    26f6:	4c 87       	std	Y+12, r20	; 0x0c
    26f8:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    26fa:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    26fc:	88 85       	ldd	r24, Y+8	; 0x08
    26fe:	99 85       	ldd	r25, Y+9	; 0x09
    2700:	9a 83       	std	Y+2, r25	; 0x02
    2702:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2704:	0f b6       	in	r0, 0x3f	; 63
    2706:	f8 94       	cli
    2708:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    270a:	e9 81       	ldd	r30, Y+1	; 0x01
    270c:	fa 81       	ldd	r31, Y+2	; 0x02
    270e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2710:	e9 81       	ldd	r30, Y+1	; 0x01
    2712:	fa 81       	ldd	r31, Y+2	; 0x02
    2714:	83 8d       	ldd	r24, Z+27	; 0x1b
    2716:	98 17       	cp	r25, r24
    2718:	18 f0       	brcs	.+6      	; 0x2720 <xQueueGenericSend+0x48>
    271a:	8e 85       	ldd	r24, Y+14	; 0x0e
    271c:	82 30       	cpi	r24, 0x02	; 2
    271e:	11 f5       	brne	.+68     	; 0x2764 <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2720:	89 81       	ldd	r24, Y+1	; 0x01
    2722:	9a 81       	ldd	r25, Y+2	; 0x02
    2724:	2a 85       	ldd	r18, Y+10	; 0x0a
    2726:	3b 85       	ldd	r19, Y+11	; 0x0b
    2728:	b9 01       	movw	r22, r18
    272a:	4e 85       	ldd	r20, Y+14	; 0x0e
    272c:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <prvCopyDataToQueue>
    2730:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2732:	e9 81       	ldd	r30, Y+1	; 0x01
    2734:	fa 81       	ldd	r31, Y+2	; 0x02
    2736:	81 89       	ldd	r24, Z+17	; 0x11
    2738:	88 23       	and	r24, r24
    273a:	51 f0       	breq	.+20     	; 0x2750 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    273c:	89 81       	ldd	r24, Y+1	; 0x01
    273e:	9a 81       	ldd	r25, Y+2	; 0x02
    2740:	41 96       	adiw	r24, 0x11	; 17
    2742:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    2746:	81 30       	cpi	r24, 0x01	; 1
    2748:	41 f4       	brne	.+16     	; 0x275a <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    274a:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
    274e:	05 c0       	rjmp	.+10     	; 0x275a <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2750:	8b 81       	ldd	r24, Y+3	; 0x03
    2752:	88 23       	and	r24, r24
    2754:	11 f0       	breq	.+4      	; 0x275a <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2756:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    275a:	0f 90       	pop	r0
    275c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    275e:	81 e0       	ldi	r24, 0x01	; 1
    2760:	8f 87       	std	Y+15, r24	; 0x0f
    2762:	5c c0       	rjmp	.+184    	; 0x281c <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2764:	8c 85       	ldd	r24, Y+12	; 0x0c
    2766:	9d 85       	ldd	r25, Y+13	; 0x0d
    2768:	00 97       	sbiw	r24, 0x00	; 0
    276a:	21 f4       	brne	.+8      	; 0x2774 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    276c:	0f 90       	pop	r0
    276e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2770:	1f 86       	std	Y+15, r1	; 0x0f
    2772:	54 c0       	rjmp	.+168    	; 0x281c <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2774:	8c 81       	ldd	r24, Y+4	; 0x04
    2776:	88 23       	and	r24, r24
    2778:	31 f4       	brne	.+12     	; 0x2786 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    277a:	ce 01       	movw	r24, r28
    277c:	05 96       	adiw	r24, 0x05	; 5
    277e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2782:	81 e0       	ldi	r24, 0x01	; 1
    2784:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2786:	0f 90       	pop	r0
    2788:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    278a:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    278e:	0f b6       	in	r0, 0x3f	; 63
    2790:	f8 94       	cli
    2792:	0f 92       	push	r0
    2794:	e9 81       	ldd	r30, Y+1	; 0x01
    2796:	fa 81       	ldd	r31, Y+2	; 0x02
    2798:	85 8d       	ldd	r24, Z+29	; 0x1d
    279a:	8f 3f       	cpi	r24, 0xFF	; 255
    279c:	19 f4       	brne	.+6      	; 0x27a4 <xQueueGenericSend+0xcc>
    279e:	e9 81       	ldd	r30, Y+1	; 0x01
    27a0:	fa 81       	ldd	r31, Y+2	; 0x02
    27a2:	15 8e       	std	Z+29, r1	; 0x1d
    27a4:	e9 81       	ldd	r30, Y+1	; 0x01
    27a6:	fa 81       	ldd	r31, Y+2	; 0x02
    27a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    27aa:	8f 3f       	cpi	r24, 0xFF	; 255
    27ac:	19 f4       	brne	.+6      	; 0x27b4 <xQueueGenericSend+0xdc>
    27ae:	e9 81       	ldd	r30, Y+1	; 0x01
    27b0:	fa 81       	ldd	r31, Y+2	; 0x02
    27b2:	16 8e       	std	Z+30, r1	; 0x1e
    27b4:	0f 90       	pop	r0
    27b6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    27b8:	ce 01       	movw	r24, r28
    27ba:	05 96       	adiw	r24, 0x05	; 5
    27bc:	9e 01       	movw	r18, r28
    27be:	24 5f       	subi	r18, 0xF4	; 244
    27c0:	3f 4f       	sbci	r19, 0xFF	; 255
    27c2:	b9 01       	movw	r22, r18
    27c4:	0e 94 75 1f 	call	0x3eea	; 0x3eea <xTaskCheckForTimeOut>
    27c8:	88 23       	and	r24, r24
    27ca:	09 f5       	brne	.+66     	; 0x280e <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    27cc:	89 81       	ldd	r24, Y+1	; 0x01
    27ce:	9a 81       	ldd	r25, Y+2	; 0x02
    27d0:	0e 94 e7 17 	call	0x2fce	; 0x2fce <prvIsQueueFull>
    27d4:	88 23       	and	r24, r24
    27d6:	a1 f0       	breq	.+40     	; 0x2800 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    27d8:	89 81       	ldd	r24, Y+1	; 0x01
    27da:	9a 81       	ldd	r25, Y+2	; 0x02
    27dc:	08 96       	adiw	r24, 0x08	; 8
    27de:	2c 85       	ldd	r18, Y+12	; 0x0c
    27e0:	3d 85       	ldd	r19, Y+13	; 0x0d
    27e2:	b9 01       	movw	r22, r18
    27e4:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    27e8:	89 81       	ldd	r24, Y+1	; 0x01
    27ea:	9a 81       	ldd	r25, Y+2	; 0x02
    27ec:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    27f0:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    27f4:	88 23       	and	r24, r24
    27f6:	09 f0       	breq	.+2      	; 0x27fa <xQueueGenericSend+0x122>
    27f8:	85 cf       	rjmp	.-246    	; 0x2704 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    27fa:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
    27fe:	82 cf       	rjmp	.-252    	; 0x2704 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2800:	89 81       	ldd	r24, Y+1	; 0x01
    2802:	9a 81       	ldd	r25, Y+2	; 0x02
    2804:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2808:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    280c:	7b cf       	rjmp	.-266    	; 0x2704 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    280e:	89 81       	ldd	r24, Y+1	; 0x01
    2810:	9a 81       	ldd	r25, Y+2	; 0x02
    2812:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2816:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    281a:	1f 86       	std	Y+15, r1	; 0x0f
    281c:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    281e:	2f 96       	adiw	r28, 0x0f	; 15
    2820:	0f b6       	in	r0, 0x3f	; 63
    2822:	f8 94       	cli
    2824:	de bf       	out	0x3e, r29	; 62
    2826:	0f be       	out	0x3f, r0	; 63
    2828:	cd bf       	out	0x3d, r28	; 61
    282a:	cf 91       	pop	r28
    282c:	df 91       	pop	r29
    282e:	08 95       	ret

00002830 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2830:	df 93       	push	r29
    2832:	cf 93       	push	r28
    2834:	cd b7       	in	r28, 0x3d	; 61
    2836:	de b7       	in	r29, 0x3e	; 62
    2838:	2b 97       	sbiw	r28, 0x0b	; 11
    283a:	0f b6       	in	r0, 0x3f	; 63
    283c:	f8 94       	cli
    283e:	de bf       	out	0x3e, r29	; 62
    2840:	0f be       	out	0x3f, r0	; 63
    2842:	cd bf       	out	0x3d, r28	; 61
    2844:	9e 83       	std	Y+6, r25	; 0x06
    2846:	8d 83       	std	Y+5, r24	; 0x05
    2848:	78 87       	std	Y+8, r23	; 0x08
    284a:	6f 83       	std	Y+7, r22	; 0x07
    284c:	5a 87       	std	Y+10, r21	; 0x0a
    284e:	49 87       	std	Y+9, r20	; 0x09
    2850:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2852:	8d 81       	ldd	r24, Y+5	; 0x05
    2854:	9e 81       	ldd	r25, Y+6	; 0x06
    2856:	9a 83       	std	Y+2, r25	; 0x02
    2858:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    285a:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    285c:	e9 81       	ldd	r30, Y+1	; 0x01
    285e:	fa 81       	ldd	r31, Y+2	; 0x02
    2860:	92 8d       	ldd	r25, Z+26	; 0x1a
    2862:	e9 81       	ldd	r30, Y+1	; 0x01
    2864:	fa 81       	ldd	r31, Y+2	; 0x02
    2866:	83 8d       	ldd	r24, Z+27	; 0x1b
    2868:	98 17       	cp	r25, r24
    286a:	18 f0       	brcs	.+6      	; 0x2872 <xQueueGenericSendFromISR+0x42>
    286c:	8b 85       	ldd	r24, Y+11	; 0x0b
    286e:	82 30       	cpi	r24, 0x02	; 2
    2870:	b1 f5       	brne	.+108    	; 0x28de <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    2872:	89 81       	ldd	r24, Y+1	; 0x01
    2874:	9a 81       	ldd	r25, Y+2	; 0x02
    2876:	2f 81       	ldd	r18, Y+7	; 0x07
    2878:	38 85       	ldd	r19, Y+8	; 0x08
    287a:	b9 01       	movw	r22, r18
    287c:	4b 85       	ldd	r20, Y+11	; 0x0b
    287e:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <prvCopyDataToQueue>
    2882:	88 23       	and	r24, r24
    2884:	41 f0       	breq	.+16     	; 0x2896 <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    2886:	89 85       	ldd	r24, Y+9	; 0x09
    2888:	9a 85       	ldd	r25, Y+10	; 0x0a
    288a:	00 97       	sbiw	r24, 0x00	; 0
    288c:	21 f0       	breq	.+8      	; 0x2896 <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    288e:	e9 85       	ldd	r30, Y+9	; 0x09
    2890:	fa 85       	ldd	r31, Y+10	; 0x0a
    2892:	81 e0       	ldi	r24, 0x01	; 1
    2894:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2896:	e9 81       	ldd	r30, Y+1	; 0x01
    2898:	fa 81       	ldd	r31, Y+2	; 0x02
    289a:	86 8d       	ldd	r24, Z+30	; 0x1e
    289c:	8f 3f       	cpi	r24, 0xFF	; 255
    289e:	a9 f4       	brne	.+42     	; 0x28ca <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28a0:	e9 81       	ldd	r30, Y+1	; 0x01
    28a2:	fa 81       	ldd	r31, Y+2	; 0x02
    28a4:	81 89       	ldd	r24, Z+17	; 0x11
    28a6:	88 23       	and	r24, r24
    28a8:	b9 f0       	breq	.+46     	; 0x28d8 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28aa:	89 81       	ldd	r24, Y+1	; 0x01
    28ac:	9a 81       	ldd	r25, Y+2	; 0x02
    28ae:	41 96       	adiw	r24, 0x11	; 17
    28b0:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    28b4:	88 23       	and	r24, r24
    28b6:	81 f0       	breq	.+32     	; 0x28d8 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    28b8:	89 85       	ldd	r24, Y+9	; 0x09
    28ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    28bc:	00 97       	sbiw	r24, 0x00	; 0
    28be:	61 f0       	breq	.+24     	; 0x28d8 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    28c0:	e9 85       	ldd	r30, Y+9	; 0x09
    28c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    28c4:	81 e0       	ldi	r24, 0x01	; 1
    28c6:	80 83       	st	Z, r24
    28c8:	07 c0       	rjmp	.+14     	; 0x28d8 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    28ca:	e9 81       	ldd	r30, Y+1	; 0x01
    28cc:	fa 81       	ldd	r31, Y+2	; 0x02
    28ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    28d0:	8f 5f       	subi	r24, 0xFF	; 255
    28d2:	e9 81       	ldd	r30, Y+1	; 0x01
    28d4:	fa 81       	ldd	r31, Y+2	; 0x02
    28d6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    28d8:	81 e0       	ldi	r24, 0x01	; 1
    28da:	8c 83       	std	Y+4, r24	; 0x04
    28dc:	01 c0       	rjmp	.+2      	; 0x28e0 <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    28de:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    28e0:	8c 81       	ldd	r24, Y+4	; 0x04
}
    28e2:	2b 96       	adiw	r28, 0x0b	; 11
    28e4:	0f b6       	in	r0, 0x3f	; 63
    28e6:	f8 94       	cli
    28e8:	de bf       	out	0x3e, r29	; 62
    28ea:	0f be       	out	0x3f, r0	; 63
    28ec:	cd bf       	out	0x3d, r28	; 61
    28ee:	cf 91       	pop	r28
    28f0:	df 91       	pop	r29
    28f2:	08 95       	ret

000028f4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    28f4:	df 93       	push	r29
    28f6:	cf 93       	push	r28
    28f8:	cd b7       	in	r28, 0x3d	; 61
    28fa:	de b7       	in	r29, 0x3e	; 62
    28fc:	60 97       	sbiw	r28, 0x10	; 16
    28fe:	0f b6       	in	r0, 0x3f	; 63
    2900:	f8 94       	cli
    2902:	de bf       	out	0x3e, r29	; 62
    2904:	0f be       	out	0x3f, r0	; 63
    2906:	cd bf       	out	0x3d, r28	; 61
    2908:	9a 87       	std	Y+10, r25	; 0x0a
    290a:	89 87       	std	Y+9, r24	; 0x09
    290c:	7c 87       	std	Y+12, r23	; 0x0c
    290e:	6b 87       	std	Y+11, r22	; 0x0b
    2910:	5e 87       	std	Y+14, r21	; 0x0e
    2912:	4d 87       	std	Y+13, r20	; 0x0d
    2914:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    2916:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2918:	89 85       	ldd	r24, Y+9	; 0x09
    291a:	9a 85       	ldd	r25, Y+10	; 0x0a
    291c:	9a 83       	std	Y+2, r25	; 0x02
    291e:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2920:	0f b6       	in	r0, 0x3f	; 63
    2922:	f8 94       	cli
    2924:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2926:	e9 81       	ldd	r30, Y+1	; 0x01
    2928:	fa 81       	ldd	r31, Y+2	; 0x02
    292a:	82 8d       	ldd	r24, Z+26	; 0x1a
    292c:	88 23       	and	r24, r24
    292e:	09 f4       	brne	.+2      	; 0x2932 <xQueueGenericReceive+0x3e>
    2930:	4b c0       	rjmp	.+150    	; 0x29c8 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2932:	e9 81       	ldd	r30, Y+1	; 0x01
    2934:	fa 81       	ldd	r31, Y+2	; 0x02
    2936:	86 81       	ldd	r24, Z+6	; 0x06
    2938:	97 81       	ldd	r25, Z+7	; 0x07
    293a:	9c 83       	std	Y+4, r25	; 0x04
    293c:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    293e:	89 81       	ldd	r24, Y+1	; 0x01
    2940:	9a 81       	ldd	r25, Y+2	; 0x02
    2942:	2b 85       	ldd	r18, Y+11	; 0x0b
    2944:	3c 85       	ldd	r19, Y+12	; 0x0c
    2946:	b9 01       	movw	r22, r18
    2948:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    294c:	8f 85       	ldd	r24, Y+15	; 0x0f
    294e:	88 23       	and	r24, r24
    2950:	11 f5       	brne	.+68     	; 0x2996 <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2952:	e9 81       	ldd	r30, Y+1	; 0x01
    2954:	fa 81       	ldd	r31, Y+2	; 0x02
    2956:	82 8d       	ldd	r24, Z+26	; 0x1a
    2958:	81 50       	subi	r24, 0x01	; 1
    295a:	e9 81       	ldd	r30, Y+1	; 0x01
    295c:	fa 81       	ldd	r31, Y+2	; 0x02
    295e:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2960:	e9 81       	ldd	r30, Y+1	; 0x01
    2962:	fa 81       	ldd	r31, Y+2	; 0x02
    2964:	80 81       	ld	r24, Z
    2966:	91 81       	ldd	r25, Z+1	; 0x01
    2968:	00 97       	sbiw	r24, 0x00	; 0
    296a:	31 f4       	brne	.+12     	; 0x2978 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    296c:	0e 94 ec 22 	call	0x45d8	; 0x45d8 <pvTaskIncrementMutexHeldCount>
    2970:	e9 81       	ldd	r30, Y+1	; 0x01
    2972:	fa 81       	ldd	r31, Y+2	; 0x02
    2974:	93 83       	std	Z+3, r25	; 0x03
    2976:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2978:	e9 81       	ldd	r30, Y+1	; 0x01
    297a:	fa 81       	ldd	r31, Y+2	; 0x02
    297c:	80 85       	ldd	r24, Z+8	; 0x08
    297e:	88 23       	and	r24, r24
    2980:	f1 f0       	breq	.+60     	; 0x29be <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2982:	89 81       	ldd	r24, Y+1	; 0x01
    2984:	9a 81       	ldd	r25, Y+2	; 0x02
    2986:	08 96       	adiw	r24, 0x08	; 8
    2988:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    298c:	81 30       	cpi	r24, 0x01	; 1
    298e:	b9 f4       	brne	.+46     	; 0x29be <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2990:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
    2994:	14 c0       	rjmp	.+40     	; 0x29be <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2996:	e9 81       	ldd	r30, Y+1	; 0x01
    2998:	fa 81       	ldd	r31, Y+2	; 0x02
    299a:	8b 81       	ldd	r24, Y+3	; 0x03
    299c:	9c 81       	ldd	r25, Y+4	; 0x04
    299e:	97 83       	std	Z+7, r25	; 0x07
    29a0:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    29a2:	e9 81       	ldd	r30, Y+1	; 0x01
    29a4:	fa 81       	ldd	r31, Y+2	; 0x02
    29a6:	81 89       	ldd	r24, Z+17	; 0x11
    29a8:	88 23       	and	r24, r24
    29aa:	49 f0       	breq	.+18     	; 0x29be <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    29ac:	89 81       	ldd	r24, Y+1	; 0x01
    29ae:	9a 81       	ldd	r25, Y+2	; 0x02
    29b0:	41 96       	adiw	r24, 0x11	; 17
    29b2:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    29b6:	88 23       	and	r24, r24
    29b8:	11 f0       	breq	.+4      	; 0x29be <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    29ba:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    29be:	0f 90       	pop	r0
    29c0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    29c2:	81 e0       	ldi	r24, 0x01	; 1
    29c4:	88 8b       	std	Y+16, r24	; 0x10
    29c6:	6d c0       	rjmp	.+218    	; 0x2aa2 <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    29c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    29ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    29cc:	00 97       	sbiw	r24, 0x00	; 0
    29ce:	21 f4       	brne	.+8      	; 0x29d8 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    29d0:	0f 90       	pop	r0
    29d2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    29d4:	18 8a       	std	Y+16, r1	; 0x10
    29d6:	65 c0       	rjmp	.+202    	; 0x2aa2 <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    29d8:	8d 81       	ldd	r24, Y+5	; 0x05
    29da:	88 23       	and	r24, r24
    29dc:	31 f4       	brne	.+12     	; 0x29ea <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    29de:	ce 01       	movw	r24, r28
    29e0:	06 96       	adiw	r24, 0x06	; 6
    29e2:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    29e6:	81 e0       	ldi	r24, 0x01	; 1
    29e8:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    29ea:	0f 90       	pop	r0
    29ec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    29ee:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    29f2:	0f b6       	in	r0, 0x3f	; 63
    29f4:	f8 94       	cli
    29f6:	0f 92       	push	r0
    29f8:	e9 81       	ldd	r30, Y+1	; 0x01
    29fa:	fa 81       	ldd	r31, Y+2	; 0x02
    29fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    29fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2a00:	19 f4       	brne	.+6      	; 0x2a08 <xQueueGenericReceive+0x114>
    2a02:	e9 81       	ldd	r30, Y+1	; 0x01
    2a04:	fa 81       	ldd	r31, Y+2	; 0x02
    2a06:	15 8e       	std	Z+29, r1	; 0x1d
    2a08:	e9 81       	ldd	r30, Y+1	; 0x01
    2a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a0e:	8f 3f       	cpi	r24, 0xFF	; 255
    2a10:	19 f4       	brne	.+6      	; 0x2a18 <xQueueGenericReceive+0x124>
    2a12:	e9 81       	ldd	r30, Y+1	; 0x01
    2a14:	fa 81       	ldd	r31, Y+2	; 0x02
    2a16:	16 8e       	std	Z+30, r1	; 0x1e
    2a18:	0f 90       	pop	r0
    2a1a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2a1c:	ce 01       	movw	r24, r28
    2a1e:	06 96       	adiw	r24, 0x06	; 6
    2a20:	9e 01       	movw	r18, r28
    2a22:	23 5f       	subi	r18, 0xF3	; 243
    2a24:	3f 4f       	sbci	r19, 0xFF	; 255
    2a26:	b9 01       	movw	r22, r18
    2a28:	0e 94 75 1f 	call	0x3eea	; 0x3eea <xTaskCheckForTimeOut>
    2a2c:	88 23       	and	r24, r24
    2a2e:	91 f5       	brne	.+100    	; 0x2a94 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a30:	89 81       	ldd	r24, Y+1	; 0x01
    2a32:	9a 81       	ldd	r25, Y+2	; 0x02
    2a34:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <prvIsQueueEmpty>
    2a38:	88 23       	and	r24, r24
    2a3a:	29 f1       	breq	.+74     	; 0x2a86 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a40:	80 81       	ld	r24, Z
    2a42:	91 81       	ldd	r25, Z+1	; 0x01
    2a44:	00 97       	sbiw	r24, 0x00	; 0
    2a46:	59 f4       	brne	.+22     	; 0x2a5e <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    2a48:	0f b6       	in	r0, 0x3f	; 63
    2a4a:	f8 94       	cli
    2a4c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a50:	fa 81       	ldd	r31, Y+2	; 0x02
    2a52:	82 81       	ldd	r24, Z+2	; 0x02
    2a54:	93 81       	ldd	r25, Z+3	; 0x03
    2a56:	0e 94 c8 21 	call	0x4390	; 0x4390 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    2a5a:	0f 90       	pop	r0
    2a5c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2a5e:	89 81       	ldd	r24, Y+1	; 0x01
    2a60:	9a 81       	ldd	r25, Y+2	; 0x02
    2a62:	41 96       	adiw	r24, 0x11	; 17
    2a64:	2d 85       	ldd	r18, Y+13	; 0x0d
    2a66:	3e 85       	ldd	r19, Y+14	; 0x0e
    2a68:	b9 01       	movw	r22, r18
    2a6a:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2a6e:	89 81       	ldd	r24, Y+1	; 0x01
    2a70:	9a 81       	ldd	r25, Y+2	; 0x02
    2a72:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2a76:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    2a7a:	88 23       	and	r24, r24
    2a7c:	09 f0       	breq	.+2      	; 0x2a80 <xQueueGenericReceive+0x18c>
    2a7e:	50 cf       	rjmp	.-352    	; 0x2920 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    2a80:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
    2a84:	4d cf       	rjmp	.-358    	; 0x2920 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	9a 81       	ldd	r25, Y+2	; 0x02
    2a8a:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2a8e:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    2a92:	46 cf       	rjmp	.-372    	; 0x2920 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2a94:	89 81       	ldd	r24, Y+1	; 0x01
    2a96:	9a 81       	ldd	r25, Y+2	; 0x02
    2a98:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2a9c:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2aa0:	18 8a       	std	Y+16, r1	; 0x10
    2aa2:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    2aa4:	60 96       	adiw	r28, 0x10	; 16
    2aa6:	0f b6       	in	r0, 0x3f	; 63
    2aa8:	f8 94       	cli
    2aaa:	de bf       	out	0x3e, r29	; 62
    2aac:	0f be       	out	0x3f, r0	; 63
    2aae:	cd bf       	out	0x3d, r28	; 61
    2ab0:	cf 91       	pop	r28
    2ab2:	df 91       	pop	r29
    2ab4:	08 95       	ret

00002ab6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2ab6:	df 93       	push	r29
    2ab8:	cf 93       	push	r28
    2aba:	cd b7       	in	r28, 0x3d	; 61
    2abc:	de b7       	in	r29, 0x3e	; 62
    2abe:	2a 97       	sbiw	r28, 0x0a	; 10
    2ac0:	0f b6       	in	r0, 0x3f	; 63
    2ac2:	f8 94       	cli
    2ac4:	de bf       	out	0x3e, r29	; 62
    2ac6:	0f be       	out	0x3f, r0	; 63
    2ac8:	cd bf       	out	0x3d, r28	; 61
    2aca:	9e 83       	std	Y+6, r25	; 0x06
    2acc:	8d 83       	std	Y+5, r24	; 0x05
    2ace:	78 87       	std	Y+8, r23	; 0x08
    2ad0:	6f 83       	std	Y+7, r22	; 0x07
    2ad2:	5a 87       	std	Y+10, r21	; 0x0a
    2ad4:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2ad6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ad8:	9e 81       	ldd	r25, Y+6	; 0x06
    2ada:	9a 83       	std	Y+2, r25	; 0x02
    2adc:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2ade:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2ae0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ae6:	88 23       	and	r24, r24
    2ae8:	91 f1       	breq	.+100    	; 0x2b4e <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2aea:	89 81       	ldd	r24, Y+1	; 0x01
    2aec:	9a 81       	ldd	r25, Y+2	; 0x02
    2aee:	2f 81       	ldd	r18, Y+7	; 0x07
    2af0:	38 85       	ldd	r19, Y+8	; 0x08
    2af2:	b9 01       	movw	r22, r18
    2af4:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2af8:	e9 81       	ldd	r30, Y+1	; 0x01
    2afa:	fa 81       	ldd	r31, Y+2	; 0x02
    2afc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2afe:	81 50       	subi	r24, 0x01	; 1
    2b00:	e9 81       	ldd	r30, Y+1	; 0x01
    2b02:	fa 81       	ldd	r31, Y+2	; 0x02
    2b04:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2b06:	e9 81       	ldd	r30, Y+1	; 0x01
    2b08:	fa 81       	ldd	r31, Y+2	; 0x02
    2b0a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b0c:	8f 3f       	cpi	r24, 0xFF	; 255
    2b0e:	a9 f4       	brne	.+42     	; 0x2b3a <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2b10:	e9 81       	ldd	r30, Y+1	; 0x01
    2b12:	fa 81       	ldd	r31, Y+2	; 0x02
    2b14:	80 85       	ldd	r24, Z+8	; 0x08
    2b16:	88 23       	and	r24, r24
    2b18:	b9 f0       	breq	.+46     	; 0x2b48 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2b1a:	89 81       	ldd	r24, Y+1	; 0x01
    2b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b1e:	08 96       	adiw	r24, 0x08	; 8
    2b20:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    2b24:	88 23       	and	r24, r24
    2b26:	81 f0       	breq	.+32     	; 0x2b48 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2b28:	89 85       	ldd	r24, Y+9	; 0x09
    2b2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b2c:	00 97       	sbiw	r24, 0x00	; 0
    2b2e:	61 f0       	breq	.+24     	; 0x2b48 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2b30:	e9 85       	ldd	r30, Y+9	; 0x09
    2b32:	fa 85       	ldd	r31, Y+10	; 0x0a
    2b34:	81 e0       	ldi	r24, 0x01	; 1
    2b36:	80 83       	st	Z, r24
    2b38:	07 c0       	rjmp	.+14     	; 0x2b48 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2b3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b40:	8f 5f       	subi	r24, 0xFF	; 255
    2b42:	e9 81       	ldd	r30, Y+1	; 0x01
    2b44:	fa 81       	ldd	r31, Y+2	; 0x02
    2b46:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2b48:	81 e0       	ldi	r24, 0x01	; 1
    2b4a:	8c 83       	std	Y+4, r24	; 0x04
    2b4c:	01 c0       	rjmp	.+2      	; 0x2b50 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2b4e:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2b50:	8c 81       	ldd	r24, Y+4	; 0x04
}
    2b52:	2a 96       	adiw	r28, 0x0a	; 10
    2b54:	0f b6       	in	r0, 0x3f	; 63
    2b56:	f8 94       	cli
    2b58:	de bf       	out	0x3e, r29	; 62
    2b5a:	0f be       	out	0x3f, r0	; 63
    2b5c:	cd bf       	out	0x3d, r28	; 61
    2b5e:	cf 91       	pop	r28
    2b60:	df 91       	pop	r29
    2b62:	08 95       	ret

00002b64 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2b64:	df 93       	push	r29
    2b66:	cf 93       	push	r28
    2b68:	cd b7       	in	r28, 0x3d	; 61
    2b6a:	de b7       	in	r29, 0x3e	; 62
    2b6c:	2a 97       	sbiw	r28, 0x0a	; 10
    2b6e:	0f b6       	in	r0, 0x3f	; 63
    2b70:	f8 94       	cli
    2b72:	de bf       	out	0x3e, r29	; 62
    2b74:	0f be       	out	0x3f, r0	; 63
    2b76:	cd bf       	out	0x3d, r28	; 61
    2b78:	98 87       	std	Y+8, r25	; 0x08
    2b7a:	8f 83       	std	Y+7, r24	; 0x07
    2b7c:	7a 87       	std	Y+10, r23	; 0x0a
    2b7e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2b80:	8f 81       	ldd	r24, Y+7	; 0x07
    2b82:	98 85       	ldd	r25, Y+8	; 0x08
    2b84:	9a 83       	std	Y+2, r25	; 0x02
    2b86:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2b88:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b90:	88 23       	and	r24, r24
    2b92:	b1 f0       	breq	.+44     	; 0x2bc0 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2b94:	e9 81       	ldd	r30, Y+1	; 0x01
    2b96:	fa 81       	ldd	r31, Y+2	; 0x02
    2b98:	86 81       	ldd	r24, Z+6	; 0x06
    2b9a:	97 81       	ldd	r25, Z+7	; 0x07
    2b9c:	9c 83       	std	Y+4, r25	; 0x04
    2b9e:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2ba0:	89 81       	ldd	r24, Y+1	; 0x01
    2ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba4:	29 85       	ldd	r18, Y+9	; 0x09
    2ba6:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ba8:	b9 01       	movw	r22, r18
    2baa:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2bae:	e9 81       	ldd	r30, Y+1	; 0x01
    2bb0:	fa 81       	ldd	r31, Y+2	; 0x02
    2bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb6:	97 83       	std	Z+7, r25	; 0x07
    2bb8:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2bba:	81 e0       	ldi	r24, 0x01	; 1
    2bbc:	8e 83       	std	Y+6, r24	; 0x06
    2bbe:	01 c0       	rjmp	.+2      	; 0x2bc2 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2bc0:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2bc2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2bc4:	2a 96       	adiw	r28, 0x0a	; 10
    2bc6:	0f b6       	in	r0, 0x3f	; 63
    2bc8:	f8 94       	cli
    2bca:	de bf       	out	0x3e, r29	; 62
    2bcc:	0f be       	out	0x3f, r0	; 63
    2bce:	cd bf       	out	0x3d, r28	; 61
    2bd0:	cf 91       	pop	r28
    2bd2:	df 91       	pop	r29
    2bd4:	08 95       	ret

00002bd6 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2bd6:	df 93       	push	r29
    2bd8:	cf 93       	push	r28
    2bda:	00 d0       	rcall	.+0      	; 0x2bdc <uxQueueMessagesWaiting+0x6>
    2bdc:	0f 92       	push	r0
    2bde:	cd b7       	in	r28, 0x3d	; 61
    2be0:	de b7       	in	r29, 0x3e	; 62
    2be2:	9b 83       	std	Y+3, r25	; 0x03
    2be4:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2be6:	0f b6       	in	r0, 0x3f	; 63
    2be8:	f8 94       	cli
    2bea:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2bec:	ea 81       	ldd	r30, Y+2	; 0x02
    2bee:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bf2:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2bf4:	0f 90       	pop	r0
    2bf6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2bf8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2bfa:	0f 90       	pop	r0
    2bfc:	0f 90       	pop	r0
    2bfe:	0f 90       	pop	r0
    2c00:	cf 91       	pop	r28
    2c02:	df 91       	pop	r29
    2c04:	08 95       	ret

00002c06 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2c06:	df 93       	push	r29
    2c08:	cf 93       	push	r28
    2c0a:	00 d0       	rcall	.+0      	; 0x2c0c <uxQueueSpacesAvailable+0x6>
    2c0c:	00 d0       	rcall	.+0      	; 0x2c0e <uxQueueSpacesAvailable+0x8>
    2c0e:	0f 92       	push	r0
    2c10:	cd b7       	in	r28, 0x3d	; 61
    2c12:	de b7       	in	r29, 0x3e	; 62
    2c14:	9d 83       	std	Y+5, r25	; 0x05
    2c16:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2c18:	8c 81       	ldd	r24, Y+4	; 0x04
    2c1a:	9d 81       	ldd	r25, Y+5	; 0x05
    2c1c:	9a 83       	std	Y+2, r25	; 0x02
    2c1e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2c20:	0f b6       	in	r0, 0x3f	; 63
    2c22:	f8 94       	cli
    2c24:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2c26:	e9 81       	ldd	r30, Y+1	; 0x01
    2c28:	fa 81       	ldd	r31, Y+2	; 0x02
    2c2a:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c30:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c32:	29 2f       	mov	r18, r25
    2c34:	28 1b       	sub	r18, r24
    2c36:	82 2f       	mov	r24, r18
    2c38:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2c3a:	0f 90       	pop	r0
    2c3c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2c40:	0f 90       	pop	r0
    2c42:	0f 90       	pop	r0
    2c44:	0f 90       	pop	r0
    2c46:	0f 90       	pop	r0
    2c48:	0f 90       	pop	r0
    2c4a:	cf 91       	pop	r28
    2c4c:	df 91       	pop	r29
    2c4e:	08 95       	ret

00002c50 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2c50:	df 93       	push	r29
    2c52:	cf 93       	push	r28
    2c54:	00 d0       	rcall	.+0      	; 0x2c56 <uxQueueMessagesWaitingFromISR+0x6>
    2c56:	0f 92       	push	r0
    2c58:	cd b7       	in	r28, 0x3d	; 61
    2c5a:	de b7       	in	r29, 0x3e	; 62
    2c5c:	9b 83       	std	Y+3, r25	; 0x03
    2c5e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2c60:	ea 81       	ldd	r30, Y+2	; 0x02
    2c62:	fb 81       	ldd	r31, Y+3	; 0x03
    2c64:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c66:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2c6a:	0f 90       	pop	r0
    2c6c:	0f 90       	pop	r0
    2c6e:	0f 90       	pop	r0
    2c70:	cf 91       	pop	r28
    2c72:	df 91       	pop	r29
    2c74:	08 95       	ret

00002c76 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2c76:	df 93       	push	r29
    2c78:	cf 93       	push	r28
    2c7a:	00 d0       	rcall	.+0      	; 0x2c7c <vQueueDelete+0x6>
    2c7c:	00 d0       	rcall	.+0      	; 0x2c7e <vQueueDelete+0x8>
    2c7e:	cd b7       	in	r28, 0x3d	; 61
    2c80:	de b7       	in	r29, 0x3e	; 62
    2c82:	9c 83       	std	Y+4, r25	; 0x04
    2c84:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2c86:	8b 81       	ldd	r24, Y+3	; 0x03
    2c88:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8a:	9a 83       	std	Y+2, r25	; 0x02
    2c8c:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    2c8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c90:	fa 81       	ldd	r31, Y+2	; 0x02
    2c92:	80 81       	ld	r24, Z
    2c94:	91 81       	ldd	r25, Z+1	; 0x01
    2c96:	00 97       	sbiw	r24, 0x00	; 0
    2c98:	31 f0       	breq	.+12     	; 0x2ca6 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    2c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c9e:	80 81       	ld	r24, Z
    2ca0:	91 81       	ldd	r25, Z+1	; 0x01
    2ca2:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vPortFree>
	}
	vPortFree( pxQueue );
    2ca6:	89 81       	ldd	r24, Y+1	; 0x01
    2ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    2caa:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vPortFree>
}
    2cae:	0f 90       	pop	r0
    2cb0:	0f 90       	pop	r0
    2cb2:	0f 90       	pop	r0
    2cb4:	0f 90       	pop	r0
    2cb6:	cf 91       	pop	r28
    2cb8:	df 91       	pop	r29
    2cba:	08 95       	ret

00002cbc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2cbc:	df 93       	push	r29
    2cbe:	cf 93       	push	r28
    2cc0:	00 d0       	rcall	.+0      	; 0x2cc2 <prvCopyDataToQueue+0x6>
    2cc2:	00 d0       	rcall	.+0      	; 0x2cc4 <prvCopyDataToQueue+0x8>
    2cc4:	00 d0       	rcall	.+0      	; 0x2cc6 <prvCopyDataToQueue+0xa>
    2cc6:	cd b7       	in	r28, 0x3d	; 61
    2cc8:	de b7       	in	r29, 0x3e	; 62
    2cca:	9b 83       	std	Y+3, r25	; 0x03
    2ccc:	8a 83       	std	Y+2, r24	; 0x02
    2cce:	7d 83       	std	Y+5, r23	; 0x05
    2cd0:	6c 83       	std	Y+4, r22	; 0x04
    2cd2:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    2cd4:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2cd6:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd8:	fb 81       	ldd	r31, Y+3	; 0x03
    2cda:	84 8d       	ldd	r24, Z+28	; 0x1c
    2cdc:	88 23       	and	r24, r24
    2cde:	99 f4       	brne	.+38     	; 0x2d06 <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2ce0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ce2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ce4:	80 81       	ld	r24, Z
    2ce6:	91 81       	ldd	r25, Z+1	; 0x01
    2ce8:	00 97       	sbiw	r24, 0x00	; 0
    2cea:	09 f0       	breq	.+2      	; 0x2cee <prvCopyDataToQueue+0x32>
    2cec:	8f c0       	rjmp	.+286    	; 0x2e0c <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2cee:	ea 81       	ldd	r30, Y+2	; 0x02
    2cf0:	fb 81       	ldd	r31, Y+3	; 0x03
    2cf2:	82 81       	ldd	r24, Z+2	; 0x02
    2cf4:	93 81       	ldd	r25, Z+3	; 0x03
    2cf6:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskPriorityDisinherit>
    2cfa:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    2cfc:	ea 81       	ldd	r30, Y+2	; 0x02
    2cfe:	fb 81       	ldd	r31, Y+3	; 0x03
    2d00:	13 82       	std	Z+3, r1	; 0x03
    2d02:	12 82       	std	Z+2, r1	; 0x02
    2d04:	83 c0       	rjmp	.+262    	; 0x2e0c <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2d06:	8e 81       	ldd	r24, Y+6	; 0x06
    2d08:	88 23       	and	r24, r24
    2d0a:	99 f5       	brne	.+102    	; 0x2d72 <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2d0c:	ea 81       	ldd	r30, Y+2	; 0x02
    2d0e:	fb 81       	ldd	r31, Y+3	; 0x03
    2d10:	64 81       	ldd	r22, Z+4	; 0x04
    2d12:	75 81       	ldd	r23, Z+5	; 0x05
    2d14:	ea 81       	ldd	r30, Y+2	; 0x02
    2d16:	fb 81       	ldd	r31, Y+3	; 0x03
    2d18:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d1a:	48 2f       	mov	r20, r24
    2d1c:	50 e0       	ldi	r21, 0x00	; 0
    2d1e:	2c 81       	ldd	r18, Y+4	; 0x04
    2d20:	3d 81       	ldd	r19, Y+5	; 0x05
    2d22:	cb 01       	movw	r24, r22
    2d24:	b9 01       	movw	r22, r18
    2d26:	0e 94 e9 2d 	call	0x5bd2	; 0x5bd2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2d2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2d2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2d2e:	24 81       	ldd	r18, Z+4	; 0x04
    2d30:	35 81       	ldd	r19, Z+5	; 0x05
    2d32:	ea 81       	ldd	r30, Y+2	; 0x02
    2d34:	fb 81       	ldd	r31, Y+3	; 0x03
    2d36:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d38:	88 2f       	mov	r24, r24
    2d3a:	90 e0       	ldi	r25, 0x00	; 0
    2d3c:	82 0f       	add	r24, r18
    2d3e:	93 1f       	adc	r25, r19
    2d40:	ea 81       	ldd	r30, Y+2	; 0x02
    2d42:	fb 81       	ldd	r31, Y+3	; 0x03
    2d44:	95 83       	std	Z+5, r25	; 0x05
    2d46:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2d48:	ea 81       	ldd	r30, Y+2	; 0x02
    2d4a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d4c:	24 81       	ldd	r18, Z+4	; 0x04
    2d4e:	35 81       	ldd	r19, Z+5	; 0x05
    2d50:	ea 81       	ldd	r30, Y+2	; 0x02
    2d52:	fb 81       	ldd	r31, Y+3	; 0x03
    2d54:	82 81       	ldd	r24, Z+2	; 0x02
    2d56:	93 81       	ldd	r25, Z+3	; 0x03
    2d58:	28 17       	cp	r18, r24
    2d5a:	39 07       	cpc	r19, r25
    2d5c:	08 f4       	brcc	.+2      	; 0x2d60 <prvCopyDataToQueue+0xa4>
    2d5e:	56 c0       	rjmp	.+172    	; 0x2e0c <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2d60:	ea 81       	ldd	r30, Y+2	; 0x02
    2d62:	fb 81       	ldd	r31, Y+3	; 0x03
    2d64:	80 81       	ld	r24, Z
    2d66:	91 81       	ldd	r25, Z+1	; 0x01
    2d68:	ea 81       	ldd	r30, Y+2	; 0x02
    2d6a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d6c:	95 83       	std	Z+5, r25	; 0x05
    2d6e:	84 83       	std	Z+4, r24	; 0x04
    2d70:	4d c0       	rjmp	.+154    	; 0x2e0c <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2d72:	ea 81       	ldd	r30, Y+2	; 0x02
    2d74:	fb 81       	ldd	r31, Y+3	; 0x03
    2d76:	66 81       	ldd	r22, Z+6	; 0x06
    2d78:	77 81       	ldd	r23, Z+7	; 0x07
    2d7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2d7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2d7e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d80:	48 2f       	mov	r20, r24
    2d82:	50 e0       	ldi	r21, 0x00	; 0
    2d84:	2c 81       	ldd	r18, Y+4	; 0x04
    2d86:	3d 81       	ldd	r19, Y+5	; 0x05
    2d88:	cb 01       	movw	r24, r22
    2d8a:	b9 01       	movw	r22, r18
    2d8c:	0e 94 e9 2d 	call	0x5bd2	; 0x5bd2 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2d90:	ea 81       	ldd	r30, Y+2	; 0x02
    2d92:	fb 81       	ldd	r31, Y+3	; 0x03
    2d94:	26 81       	ldd	r18, Z+6	; 0x06
    2d96:	37 81       	ldd	r19, Z+7	; 0x07
    2d98:	ea 81       	ldd	r30, Y+2	; 0x02
    2d9a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d9e:	88 2f       	mov	r24, r24
    2da0:	90 e0       	ldi	r25, 0x00	; 0
    2da2:	90 95       	com	r25
    2da4:	81 95       	neg	r24
    2da6:	9f 4f       	sbci	r25, 0xFF	; 255
    2da8:	82 0f       	add	r24, r18
    2daa:	93 1f       	adc	r25, r19
    2dac:	ea 81       	ldd	r30, Y+2	; 0x02
    2dae:	fb 81       	ldd	r31, Y+3	; 0x03
    2db0:	97 83       	std	Z+7, r25	; 0x07
    2db2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2db4:	ea 81       	ldd	r30, Y+2	; 0x02
    2db6:	fb 81       	ldd	r31, Y+3	; 0x03
    2db8:	26 81       	ldd	r18, Z+6	; 0x06
    2dba:	37 81       	ldd	r19, Z+7	; 0x07
    2dbc:	ea 81       	ldd	r30, Y+2	; 0x02
    2dbe:	fb 81       	ldd	r31, Y+3	; 0x03
    2dc0:	80 81       	ld	r24, Z
    2dc2:	91 81       	ldd	r25, Z+1	; 0x01
    2dc4:	28 17       	cp	r18, r24
    2dc6:	39 07       	cpc	r19, r25
    2dc8:	90 f4       	brcc	.+36     	; 0x2dee <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2dca:	ea 81       	ldd	r30, Y+2	; 0x02
    2dcc:	fb 81       	ldd	r31, Y+3	; 0x03
    2dce:	22 81       	ldd	r18, Z+2	; 0x02
    2dd0:	33 81       	ldd	r19, Z+3	; 0x03
    2dd2:	ea 81       	ldd	r30, Y+2	; 0x02
    2dd4:	fb 81       	ldd	r31, Y+3	; 0x03
    2dd6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2dd8:	88 2f       	mov	r24, r24
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	90 95       	com	r25
    2dde:	81 95       	neg	r24
    2de0:	9f 4f       	sbci	r25, 0xFF	; 255
    2de2:	82 0f       	add	r24, r18
    2de4:	93 1f       	adc	r25, r19
    2de6:	ea 81       	ldd	r30, Y+2	; 0x02
    2de8:	fb 81       	ldd	r31, Y+3	; 0x03
    2dea:	97 83       	std	Z+7, r25	; 0x07
    2dec:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2dee:	8e 81       	ldd	r24, Y+6	; 0x06
    2df0:	82 30       	cpi	r24, 0x02	; 2
    2df2:	61 f4       	brne	.+24     	; 0x2e0c <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2df4:	ea 81       	ldd	r30, Y+2	; 0x02
    2df6:	fb 81       	ldd	r31, Y+3	; 0x03
    2df8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dfa:	88 23       	and	r24, r24
    2dfc:	39 f0       	breq	.+14     	; 0x2e0c <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2dfe:	ea 81       	ldd	r30, Y+2	; 0x02
    2e00:	fb 81       	ldd	r31, Y+3	; 0x03
    2e02:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e04:	81 50       	subi	r24, 0x01	; 1
    2e06:	ea 81       	ldd	r30, Y+2	; 0x02
    2e08:	fb 81       	ldd	r31, Y+3	; 0x03
    2e0a:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2e0c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e0e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e10:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e12:	8f 5f       	subi	r24, 0xFF	; 255
    2e14:	ea 81       	ldd	r30, Y+2	; 0x02
    2e16:	fb 81       	ldd	r31, Y+3	; 0x03
    2e18:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2e1a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e1c:	26 96       	adiw	r28, 0x06	; 6
    2e1e:	0f b6       	in	r0, 0x3f	; 63
    2e20:	f8 94       	cli
    2e22:	de bf       	out	0x3e, r29	; 62
    2e24:	0f be       	out	0x3f, r0	; 63
    2e26:	cd bf       	out	0x3d, r28	; 61
    2e28:	cf 91       	pop	r28
    2e2a:	df 91       	pop	r29
    2e2c:	08 95       	ret

00002e2e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2e2e:	df 93       	push	r29
    2e30:	cf 93       	push	r28
    2e32:	00 d0       	rcall	.+0      	; 0x2e34 <prvCopyDataFromQueue+0x6>
    2e34:	00 d0       	rcall	.+0      	; 0x2e36 <prvCopyDataFromQueue+0x8>
    2e36:	cd b7       	in	r28, 0x3d	; 61
    2e38:	de b7       	in	r29, 0x3e	; 62
    2e3a:	9a 83       	std	Y+2, r25	; 0x02
    2e3c:	89 83       	std	Y+1, r24	; 0x01
    2e3e:	7c 83       	std	Y+4, r23	; 0x04
    2e40:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2e42:	e9 81       	ldd	r30, Y+1	; 0x01
    2e44:	fa 81       	ldd	r31, Y+2	; 0x02
    2e46:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e48:	88 23       	and	r24, r24
    2e4a:	89 f1       	breq	.+98     	; 0x2eae <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2e4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e50:	26 81       	ldd	r18, Z+6	; 0x06
    2e52:	37 81       	ldd	r19, Z+7	; 0x07
    2e54:	e9 81       	ldd	r30, Y+1	; 0x01
    2e56:	fa 81       	ldd	r31, Y+2	; 0x02
    2e58:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e5a:	88 2f       	mov	r24, r24
    2e5c:	90 e0       	ldi	r25, 0x00	; 0
    2e5e:	82 0f       	add	r24, r18
    2e60:	93 1f       	adc	r25, r19
    2e62:	e9 81       	ldd	r30, Y+1	; 0x01
    2e64:	fa 81       	ldd	r31, Y+2	; 0x02
    2e66:	97 83       	std	Z+7, r25	; 0x07
    2e68:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e6e:	26 81       	ldd	r18, Z+6	; 0x06
    2e70:	37 81       	ldd	r19, Z+7	; 0x07
    2e72:	e9 81       	ldd	r30, Y+1	; 0x01
    2e74:	fa 81       	ldd	r31, Y+2	; 0x02
    2e76:	82 81       	ldd	r24, Z+2	; 0x02
    2e78:	93 81       	ldd	r25, Z+3	; 0x03
    2e7a:	28 17       	cp	r18, r24
    2e7c:	39 07       	cpc	r19, r25
    2e7e:	40 f0       	brcs	.+16     	; 0x2e90 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2e80:	e9 81       	ldd	r30, Y+1	; 0x01
    2e82:	fa 81       	ldd	r31, Y+2	; 0x02
    2e84:	80 81       	ld	r24, Z
    2e86:	91 81       	ldd	r25, Z+1	; 0x01
    2e88:	e9 81       	ldd	r30, Y+1	; 0x01
    2e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8c:	97 83       	std	Z+7, r25	; 0x07
    2e8e:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2e90:	e9 81       	ldd	r30, Y+1	; 0x01
    2e92:	fa 81       	ldd	r31, Y+2	; 0x02
    2e94:	46 81       	ldd	r20, Z+6	; 0x06
    2e96:	57 81       	ldd	r21, Z+7	; 0x07
    2e98:	e9 81       	ldd	r30, Y+1	; 0x01
    2e9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e9e:	28 2f       	mov	r18, r24
    2ea0:	30 e0       	ldi	r19, 0x00	; 0
    2ea2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea6:	ba 01       	movw	r22, r20
    2ea8:	a9 01       	movw	r20, r18
    2eaa:	0e 94 e9 2d 	call	0x5bd2	; 0x5bd2 <memcpy>
	}
}
    2eae:	0f 90       	pop	r0
    2eb0:	0f 90       	pop	r0
    2eb2:	0f 90       	pop	r0
    2eb4:	0f 90       	pop	r0
    2eb6:	cf 91       	pop	r28
    2eb8:	df 91       	pop	r29
    2eba:	08 95       	ret

00002ebc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2ebc:	df 93       	push	r29
    2ebe:	cf 93       	push	r28
    2ec0:	00 d0       	rcall	.+0      	; 0x2ec2 <prvUnlockQueue+0x6>
    2ec2:	cd b7       	in	r28, 0x3d	; 61
    2ec4:	de b7       	in	r29, 0x3e	; 62
    2ec6:	9a 83       	std	Y+2, r25	; 0x02
    2ec8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2eca:	0f b6       	in	r0, 0x3f	; 63
    2ecc:	f8 94       	cli
    2ece:	0f 92       	push	r0
    2ed0:	15 c0       	rjmp	.+42     	; 0x2efc <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ed2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed6:	81 89       	ldd	r24, Z+17	; 0x11
    2ed8:	88 23       	and	r24, r24
    2eda:	a9 f0       	breq	.+42     	; 0x2f06 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2edc:	89 81       	ldd	r24, Y+1	; 0x01
    2ede:	9a 81       	ldd	r25, Y+2	; 0x02
    2ee0:	41 96       	adiw	r24, 0x11	; 17
    2ee2:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    2ee6:	88 23       	and	r24, r24
    2ee8:	11 f0       	breq	.+4      	; 0x2eee <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2eea:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2eee:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ef4:	81 50       	subi	r24, 0x01	; 1
    2ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef8:	fa 81       	ldd	r31, Y+2	; 0x02
    2efa:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2efc:	e9 81       	ldd	r30, Y+1	; 0x01
    2efe:	fa 81       	ldd	r31, Y+2	; 0x02
    2f00:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f02:	18 16       	cp	r1, r24
    2f04:	34 f3       	brlt	.-52     	; 0x2ed2 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2f06:	e9 81       	ldd	r30, Y+1	; 0x01
    2f08:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0a:	8f ef       	ldi	r24, 0xFF	; 255
    2f0c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2f0e:	0f 90       	pop	r0
    2f10:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2f12:	0f b6       	in	r0, 0x3f	; 63
    2f14:	f8 94       	cli
    2f16:	0f 92       	push	r0
    2f18:	15 c0       	rjmp	.+42     	; 0x2f44 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f1e:	80 85       	ldd	r24, Z+8	; 0x08
    2f20:	88 23       	and	r24, r24
    2f22:	a9 f0       	breq	.+42     	; 0x2f4e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f24:	89 81       	ldd	r24, Y+1	; 0x01
    2f26:	9a 81       	ldd	r25, Y+2	; 0x02
    2f28:	08 96       	adiw	r24, 0x08	; 8
    2f2a:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <xTaskRemoveFromEventList>
    2f2e:	88 23       	and	r24, r24
    2f30:	11 f0       	breq	.+4      	; 0x2f36 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2f32:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2f36:	e9 81       	ldd	r30, Y+1	; 0x01
    2f38:	fa 81       	ldd	r31, Y+2	; 0x02
    2f3a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f3c:	81 50       	subi	r24, 0x01	; 1
    2f3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f40:	fa 81       	ldd	r31, Y+2	; 0x02
    2f42:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2f44:	e9 81       	ldd	r30, Y+1	; 0x01
    2f46:	fa 81       	ldd	r31, Y+2	; 0x02
    2f48:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f4a:	18 16       	cp	r1, r24
    2f4c:	34 f3       	brlt	.-52     	; 0x2f1a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2f4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f50:	fa 81       	ldd	r31, Y+2	; 0x02
    2f52:	8f ef       	ldi	r24, 0xFF	; 255
    2f54:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2f56:	0f 90       	pop	r0
    2f58:	0f be       	out	0x3f, r0	; 63
}
    2f5a:	0f 90       	pop	r0
    2f5c:	0f 90       	pop	r0
    2f5e:	cf 91       	pop	r28
    2f60:	df 91       	pop	r29
    2f62:	08 95       	ret

00002f64 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2f64:	df 93       	push	r29
    2f66:	cf 93       	push	r28
    2f68:	00 d0       	rcall	.+0      	; 0x2f6a <prvIsQueueEmpty+0x6>
    2f6a:	0f 92       	push	r0
    2f6c:	cd b7       	in	r28, 0x3d	; 61
    2f6e:	de b7       	in	r29, 0x3e	; 62
    2f70:	9b 83       	std	Y+3, r25	; 0x03
    2f72:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2f74:	0f b6       	in	r0, 0x3f	; 63
    2f76:	f8 94       	cli
    2f78:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2f7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2f7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2f7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f80:	88 23       	and	r24, r24
    2f82:	19 f4       	brne	.+6      	; 0x2f8a <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2f84:	81 e0       	ldi	r24, 0x01	; 1
    2f86:	89 83       	std	Y+1, r24	; 0x01
    2f88:	01 c0       	rjmp	.+2      	; 0x2f8c <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2f8a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2f8c:	0f 90       	pop	r0
    2f8e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2f90:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f92:	0f 90       	pop	r0
    2f94:	0f 90       	pop	r0
    2f96:	0f 90       	pop	r0
    2f98:	cf 91       	pop	r28
    2f9a:	df 91       	pop	r29
    2f9c:	08 95       	ret

00002f9e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2f9e:	df 93       	push	r29
    2fa0:	cf 93       	push	r28
    2fa2:	00 d0       	rcall	.+0      	; 0x2fa4 <xQueueIsQueueEmptyFromISR+0x6>
    2fa4:	0f 92       	push	r0
    2fa6:	cd b7       	in	r28, 0x3d	; 61
    2fa8:	de b7       	in	r29, 0x3e	; 62
    2faa:	9b 83       	std	Y+3, r25	; 0x03
    2fac:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2fae:	ea 81       	ldd	r30, Y+2	; 0x02
    2fb0:	fb 81       	ldd	r31, Y+3	; 0x03
    2fb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fb4:	88 23       	and	r24, r24
    2fb6:	19 f4       	brne	.+6      	; 0x2fbe <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	89 83       	std	Y+1, r24	; 0x01
    2fbc:	01 c0       	rjmp	.+2      	; 0x2fc0 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    2fbe:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2fc0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2fc2:	0f 90       	pop	r0
    2fc4:	0f 90       	pop	r0
    2fc6:	0f 90       	pop	r0
    2fc8:	cf 91       	pop	r28
    2fca:	df 91       	pop	r29
    2fcc:	08 95       	ret

00002fce <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2fce:	df 93       	push	r29
    2fd0:	cf 93       	push	r28
    2fd2:	00 d0       	rcall	.+0      	; 0x2fd4 <prvIsQueueFull+0x6>
    2fd4:	0f 92       	push	r0
    2fd6:	cd b7       	in	r28, 0x3d	; 61
    2fd8:	de b7       	in	r29, 0x3e	; 62
    2fda:	9b 83       	std	Y+3, r25	; 0x03
    2fdc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2fde:	0f b6       	in	r0, 0x3f	; 63
    2fe0:	f8 94       	cli
    2fe2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2fe4:	ea 81       	ldd	r30, Y+2	; 0x02
    2fe6:	fb 81       	ldd	r31, Y+3	; 0x03
    2fe8:	92 8d       	ldd	r25, Z+26	; 0x1a
    2fea:	ea 81       	ldd	r30, Y+2	; 0x02
    2fec:	fb 81       	ldd	r31, Y+3	; 0x03
    2fee:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ff0:	98 17       	cp	r25, r24
    2ff2:	19 f4       	brne	.+6      	; 0x2ffa <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2ff4:	81 e0       	ldi	r24, 0x01	; 1
    2ff6:	89 83       	std	Y+1, r24	; 0x01
    2ff8:	01 c0       	rjmp	.+2      	; 0x2ffc <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2ffa:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ffc:	0f 90       	pop	r0
    2ffe:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3000:	89 81       	ldd	r24, Y+1	; 0x01
}
    3002:	0f 90       	pop	r0
    3004:	0f 90       	pop	r0
    3006:	0f 90       	pop	r0
    3008:	cf 91       	pop	r28
    300a:	df 91       	pop	r29
    300c:	08 95       	ret

0000300e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    300e:	df 93       	push	r29
    3010:	cf 93       	push	r28
    3012:	00 d0       	rcall	.+0      	; 0x3014 <xQueueIsQueueFullFromISR+0x6>
    3014:	0f 92       	push	r0
    3016:	cd b7       	in	r28, 0x3d	; 61
    3018:	de b7       	in	r29, 0x3e	; 62
    301a:	9b 83       	std	Y+3, r25	; 0x03
    301c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    301e:	ea 81       	ldd	r30, Y+2	; 0x02
    3020:	fb 81       	ldd	r31, Y+3	; 0x03
    3022:	92 8d       	ldd	r25, Z+26	; 0x1a
    3024:	ea 81       	ldd	r30, Y+2	; 0x02
    3026:	fb 81       	ldd	r31, Y+3	; 0x03
    3028:	83 8d       	ldd	r24, Z+27	; 0x1b
    302a:	98 17       	cp	r25, r24
    302c:	19 f4       	brne	.+6      	; 0x3034 <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    302e:	81 e0       	ldi	r24, 0x01	; 1
    3030:	89 83       	std	Y+1, r24	; 0x01
    3032:	01 c0       	rjmp	.+2      	; 0x3036 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    3034:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3036:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3038:	0f 90       	pop	r0
    303a:	0f 90       	pop	r0
    303c:	0f 90       	pop	r0
    303e:	cf 91       	pop	r28
    3040:	df 91       	pop	r29
    3042:	08 95       	ret

00003044 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    3044:	df 93       	push	r29
    3046:	cf 93       	push	r28
    3048:	cd b7       	in	r28, 0x3d	; 61
    304a:	de b7       	in	r29, 0x3e	; 62
    304c:	2a 97       	sbiw	r28, 0x0a	; 10
    304e:	0f b6       	in	r0, 0x3f	; 63
    3050:	f8 94       	cli
    3052:	de bf       	out	0x3e, r29	; 62
    3054:	0f be       	out	0x3f, r0	; 63
    3056:	cd bf       	out	0x3d, r28	; 61
    3058:	9d 83       	std	Y+5, r25	; 0x05
    305a:	8c 83       	std	Y+4, r24	; 0x04
    305c:	7f 83       	std	Y+7, r23	; 0x07
    305e:	6e 83       	std	Y+6, r22	; 0x06
    3060:	59 87       	std	Y+9, r21	; 0x09
    3062:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3064:	8c 81       	ldd	r24, Y+4	; 0x04
    3066:	9d 81       	ldd	r25, Y+5	; 0x05
    3068:	9a 83       	std	Y+2, r25	; 0x02
    306a:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    306c:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    306e:	89 81       	ldd	r24, Y+1	; 0x01
    3070:	9a 81       	ldd	r25, Y+2	; 0x02
    3072:	0e 94 e7 17 	call	0x2fce	; 0x2fce <prvIsQueueFull>
    3076:	88 23       	and	r24, r24
    3078:	a9 f0       	breq	.+42     	; 0x30a4 <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    307a:	88 85       	ldd	r24, Y+8	; 0x08
    307c:	99 85       	ldd	r25, Y+9	; 0x09
    307e:	00 97       	sbiw	r24, 0x00	; 0
    3080:	71 f0       	breq	.+28     	; 0x309e <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    3082:	89 81       	ldd	r24, Y+1	; 0x01
    3084:	9a 81       	ldd	r25, Y+2	; 0x02
    3086:	9c 01       	movw	r18, r24
    3088:	28 5f       	subi	r18, 0xF8	; 248
    308a:	3f 4f       	sbci	r19, 0xFF	; 255
    308c:	88 85       	ldd	r24, Y+8	; 0x08
    308e:	99 85       	ldd	r25, Y+9	; 0x09
    3090:	b9 01       	movw	r22, r18
    3092:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    3096:	78 94       	sei
					return errQUEUE_BLOCKED;
    3098:	8c ef       	ldi	r24, 0xFC	; 252
    309a:	8a 87       	std	Y+10, r24	; 0x0a
    309c:	2a c0       	rjmp	.+84     	; 0x30f2 <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    309e:	78 94       	sei
					return errQUEUE_FULL;
    30a0:	1a 86       	std	Y+10, r1	; 0x0a
    30a2:	27 c0       	rjmp	.+78     	; 0x30f2 <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    30a4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    30a6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    30a8:	e9 81       	ldd	r30, Y+1	; 0x01
    30aa:	fa 81       	ldd	r31, Y+2	; 0x02
    30ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    30ae:	e9 81       	ldd	r30, Y+1	; 0x01
    30b0:	fa 81       	ldd	r31, Y+2	; 0x02
    30b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    30b4:	98 17       	cp	r25, r24
    30b6:	c8 f4       	brcc	.+50     	; 0x30ea <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    30b8:	89 81       	ldd	r24, Y+1	; 0x01
    30ba:	9a 81       	ldd	r25, Y+2	; 0x02
    30bc:	2e 81       	ldd	r18, Y+6	; 0x06
    30be:	3f 81       	ldd	r19, Y+7	; 0x07
    30c0:	b9 01       	movw	r22, r18
    30c2:	40 e0       	ldi	r20, 0x00	; 0
    30c4:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <prvCopyDataToQueue>
				xReturn = pdPASS;
    30c8:	81 e0       	ldi	r24, 0x01	; 1
    30ca:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30cc:	e9 81       	ldd	r30, Y+1	; 0x01
    30ce:	fa 81       	ldd	r31, Y+2	; 0x02
    30d0:	81 89       	ldd	r24, Z+17	; 0x11
    30d2:	88 23       	and	r24, r24
    30d4:	59 f0       	breq	.+22     	; 0x30ec <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30d6:	89 81       	ldd	r24, Y+1	; 0x01
    30d8:	9a 81       	ldd	r25, Y+2	; 0x02
    30da:	41 96       	adiw	r24, 0x11	; 17
    30dc:	0e 94 4b 09 	call	0x1296	; 0x1296 <xCoRoutineRemoveFromEventList>
    30e0:	88 23       	and	r24, r24
    30e2:	21 f0       	breq	.+8      	; 0x30ec <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    30e4:	8b ef       	ldi	r24, 0xFB	; 251
    30e6:	8b 83       	std	Y+3, r24	; 0x03
    30e8:	01 c0       	rjmp	.+2      	; 0x30ec <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    30ea:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    30ec:	78 94       	sei

		return xReturn;
    30ee:	8b 81       	ldd	r24, Y+3	; 0x03
    30f0:	8a 87       	std	Y+10, r24	; 0x0a
    30f2:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    30f4:	2a 96       	adiw	r28, 0x0a	; 10
    30f6:	0f b6       	in	r0, 0x3f	; 63
    30f8:	f8 94       	cli
    30fa:	de bf       	out	0x3e, r29	; 62
    30fc:	0f be       	out	0x3f, r0	; 63
    30fe:	cd bf       	out	0x3d, r28	; 61
    3100:	cf 91       	pop	r28
    3102:	df 91       	pop	r29
    3104:	08 95       	ret

00003106 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    3106:	df 93       	push	r29
    3108:	cf 93       	push	r28
    310a:	cd b7       	in	r28, 0x3d	; 61
    310c:	de b7       	in	r29, 0x3e	; 62
    310e:	2a 97       	sbiw	r28, 0x0a	; 10
    3110:	0f b6       	in	r0, 0x3f	; 63
    3112:	f8 94       	cli
    3114:	de bf       	out	0x3e, r29	; 62
    3116:	0f be       	out	0x3f, r0	; 63
    3118:	cd bf       	out	0x3d, r28	; 61
    311a:	9d 83       	std	Y+5, r25	; 0x05
    311c:	8c 83       	std	Y+4, r24	; 0x04
    311e:	7f 83       	std	Y+7, r23	; 0x07
    3120:	6e 83       	std	Y+6, r22	; 0x06
    3122:	59 87       	std	Y+9, r21	; 0x09
    3124:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3126:	8c 81       	ldd	r24, Y+4	; 0x04
    3128:	9d 81       	ldd	r25, Y+5	; 0x05
    312a:	9a 83       	std	Y+2, r25	; 0x02
    312c:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    312e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3130:	e9 81       	ldd	r30, Y+1	; 0x01
    3132:	fa 81       	ldd	r31, Y+2	; 0x02
    3134:	82 8d       	ldd	r24, Z+26	; 0x1a
    3136:	88 23       	and	r24, r24
    3138:	a9 f4       	brne	.+42     	; 0x3164 <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    313a:	88 85       	ldd	r24, Y+8	; 0x08
    313c:	99 85       	ldd	r25, Y+9	; 0x09
    313e:	00 97       	sbiw	r24, 0x00	; 0
    3140:	71 f0       	breq	.+28     	; 0x315e <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    3142:	89 81       	ldd	r24, Y+1	; 0x01
    3144:	9a 81       	ldd	r25, Y+2	; 0x02
    3146:	9c 01       	movw	r18, r24
    3148:	2f 5e       	subi	r18, 0xEF	; 239
    314a:	3f 4f       	sbci	r19, 0xFF	; 255
    314c:	88 85       	ldd	r24, Y+8	; 0x08
    314e:	99 85       	ldd	r25, Y+9	; 0x09
    3150:	b9 01       	movw	r22, r18
    3152:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    3156:	78 94       	sei
					return errQUEUE_BLOCKED;
    3158:	8c ef       	ldi	r24, 0xFC	; 252
    315a:	8a 87       	std	Y+10, r24	; 0x0a
    315c:	58 c0       	rjmp	.+176    	; 0x320e <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    315e:	78 94       	sei
					return errQUEUE_FULL;
    3160:	1a 86       	std	Y+10, r1	; 0x0a
    3162:	55 c0       	rjmp	.+170    	; 0x320e <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    3164:	78 94       	sei

		portDISABLE_INTERRUPTS();
    3166:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3168:	e9 81       	ldd	r30, Y+1	; 0x01
    316a:	fa 81       	ldd	r31, Y+2	; 0x02
    316c:	82 8d       	ldd	r24, Z+26	; 0x1a
    316e:	88 23       	and	r24, r24
    3170:	09 f4       	brne	.+2      	; 0x3174 <xQueueCRReceive+0x6e>
    3172:	49 c0       	rjmp	.+146    	; 0x3206 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3174:	e9 81       	ldd	r30, Y+1	; 0x01
    3176:	fa 81       	ldd	r31, Y+2	; 0x02
    3178:	26 81       	ldd	r18, Z+6	; 0x06
    317a:	37 81       	ldd	r19, Z+7	; 0x07
    317c:	e9 81       	ldd	r30, Y+1	; 0x01
    317e:	fa 81       	ldd	r31, Y+2	; 0x02
    3180:	84 8d       	ldd	r24, Z+28	; 0x1c
    3182:	88 2f       	mov	r24, r24
    3184:	90 e0       	ldi	r25, 0x00	; 0
    3186:	82 0f       	add	r24, r18
    3188:	93 1f       	adc	r25, r19
    318a:	e9 81       	ldd	r30, Y+1	; 0x01
    318c:	fa 81       	ldd	r31, Y+2	; 0x02
    318e:	97 83       	std	Z+7, r25	; 0x07
    3190:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    3192:	e9 81       	ldd	r30, Y+1	; 0x01
    3194:	fa 81       	ldd	r31, Y+2	; 0x02
    3196:	26 81       	ldd	r18, Z+6	; 0x06
    3198:	37 81       	ldd	r19, Z+7	; 0x07
    319a:	e9 81       	ldd	r30, Y+1	; 0x01
    319c:	fa 81       	ldd	r31, Y+2	; 0x02
    319e:	82 81       	ldd	r24, Z+2	; 0x02
    31a0:	93 81       	ldd	r25, Z+3	; 0x03
    31a2:	28 17       	cp	r18, r24
    31a4:	39 07       	cpc	r19, r25
    31a6:	40 f0       	brcs	.+16     	; 0x31b8 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    31a8:	e9 81       	ldd	r30, Y+1	; 0x01
    31aa:	fa 81       	ldd	r31, Y+2	; 0x02
    31ac:	80 81       	ld	r24, Z
    31ae:	91 81       	ldd	r25, Z+1	; 0x01
    31b0:	e9 81       	ldd	r30, Y+1	; 0x01
    31b2:	fa 81       	ldd	r31, Y+2	; 0x02
    31b4:	97 83       	std	Z+7, r25	; 0x07
    31b6:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    31b8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ba:	fa 81       	ldd	r31, Y+2	; 0x02
    31bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    31be:	81 50       	subi	r24, 0x01	; 1
    31c0:	e9 81       	ldd	r30, Y+1	; 0x01
    31c2:	fa 81       	ldd	r31, Y+2	; 0x02
    31c4:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    31c6:	e9 81       	ldd	r30, Y+1	; 0x01
    31c8:	fa 81       	ldd	r31, Y+2	; 0x02
    31ca:	46 81       	ldd	r20, Z+6	; 0x06
    31cc:	57 81       	ldd	r21, Z+7	; 0x07
    31ce:	e9 81       	ldd	r30, Y+1	; 0x01
    31d0:	fa 81       	ldd	r31, Y+2	; 0x02
    31d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    31d4:	28 2f       	mov	r18, r24
    31d6:	30 e0       	ldi	r19, 0x00	; 0
    31d8:	8e 81       	ldd	r24, Y+6	; 0x06
    31da:	9f 81       	ldd	r25, Y+7	; 0x07
    31dc:	ba 01       	movw	r22, r20
    31de:	a9 01       	movw	r20, r18
    31e0:	0e 94 e9 2d 	call	0x5bd2	; 0x5bd2 <memcpy>

				xReturn = pdPASS;
    31e4:	81 e0       	ldi	r24, 0x01	; 1
    31e6:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    31e8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ea:	fa 81       	ldd	r31, Y+2	; 0x02
    31ec:	80 85       	ldd	r24, Z+8	; 0x08
    31ee:	88 23       	and	r24, r24
    31f0:	59 f0       	breq	.+22     	; 0x3208 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    31f2:	89 81       	ldd	r24, Y+1	; 0x01
    31f4:	9a 81       	ldd	r25, Y+2	; 0x02
    31f6:	08 96       	adiw	r24, 0x08	; 8
    31f8:	0e 94 4b 09 	call	0x1296	; 0x1296 <xCoRoutineRemoveFromEventList>
    31fc:	88 23       	and	r24, r24
    31fe:	21 f0       	breq	.+8      	; 0x3208 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    3200:	8b ef       	ldi	r24, 0xFB	; 251
    3202:	8b 83       	std	Y+3, r24	; 0x03
    3204:	01 c0       	rjmp	.+2      	; 0x3208 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    3206:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    3208:	78 94       	sei

		return xReturn;
    320a:	8b 81       	ldd	r24, Y+3	; 0x03
    320c:	8a 87       	std	Y+10, r24	; 0x0a
    320e:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    3210:	2a 96       	adiw	r28, 0x0a	; 10
    3212:	0f b6       	in	r0, 0x3f	; 63
    3214:	f8 94       	cli
    3216:	de bf       	out	0x3e, r29	; 62
    3218:	0f be       	out	0x3f, r0	; 63
    321a:	cd bf       	out	0x3d, r28	; 61
    321c:	cf 91       	pop	r28
    321e:	df 91       	pop	r29
    3220:	08 95       	ret

00003222 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    3222:	df 93       	push	r29
    3224:	cf 93       	push	r28
    3226:	cd b7       	in	r28, 0x3d	; 61
    3228:	de b7       	in	r29, 0x3e	; 62
    322a:	28 97       	sbiw	r28, 0x08	; 8
    322c:	0f b6       	in	r0, 0x3f	; 63
    322e:	f8 94       	cli
    3230:	de bf       	out	0x3e, r29	; 62
    3232:	0f be       	out	0x3f, r0	; 63
    3234:	cd bf       	out	0x3d, r28	; 61
    3236:	9c 83       	std	Y+4, r25	; 0x04
    3238:	8b 83       	std	Y+3, r24	; 0x03
    323a:	7e 83       	std	Y+6, r23	; 0x06
    323c:	6d 83       	std	Y+5, r22	; 0x05
    323e:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3240:	8b 81       	ldd	r24, Y+3	; 0x03
    3242:	9c 81       	ldd	r25, Y+4	; 0x04
    3244:	9a 83       	std	Y+2, r25	; 0x02
    3246:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3248:	e9 81       	ldd	r30, Y+1	; 0x01
    324a:	fa 81       	ldd	r31, Y+2	; 0x02
    324c:	92 8d       	ldd	r25, Z+26	; 0x1a
    324e:	e9 81       	ldd	r30, Y+1	; 0x01
    3250:	fa 81       	ldd	r31, Y+2	; 0x02
    3252:	83 8d       	ldd	r24, Z+27	; 0x1b
    3254:	98 17       	cp	r25, r24
    3256:	d0 f4       	brcc	.+52     	; 0x328c <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    3258:	89 81       	ldd	r24, Y+1	; 0x01
    325a:	9a 81       	ldd	r25, Y+2	; 0x02
    325c:	2d 81       	ldd	r18, Y+5	; 0x05
    325e:	3e 81       	ldd	r19, Y+6	; 0x06
    3260:	b9 01       	movw	r22, r18
    3262:	40 e0       	ldi	r20, 0x00	; 0
    3264:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    3268:	8f 81       	ldd	r24, Y+7	; 0x07
    326a:	88 23       	and	r24, r24
    326c:	79 f4       	brne	.+30     	; 0x328c <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    326e:	e9 81       	ldd	r30, Y+1	; 0x01
    3270:	fa 81       	ldd	r31, Y+2	; 0x02
    3272:	81 89       	ldd	r24, Z+17	; 0x11
    3274:	88 23       	and	r24, r24
    3276:	51 f0       	breq	.+20     	; 0x328c <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3278:	89 81       	ldd	r24, Y+1	; 0x01
    327a:	9a 81       	ldd	r25, Y+2	; 0x02
    327c:	41 96       	adiw	r24, 0x11	; 17
    327e:	0e 94 4b 09 	call	0x1296	; 0x1296 <xCoRoutineRemoveFromEventList>
    3282:	88 23       	and	r24, r24
    3284:	19 f0       	breq	.+6      	; 0x328c <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    3286:	81 e0       	ldi	r24, 0x01	; 1
    3288:	88 87       	std	Y+8, r24	; 0x08
    328a:	02 c0       	rjmp	.+4      	; 0x3290 <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    328c:	8f 81       	ldd	r24, Y+7	; 0x07
    328e:	88 87       	std	Y+8, r24	; 0x08
    3290:	88 85       	ldd	r24, Y+8	; 0x08
	}
    3292:	28 96       	adiw	r28, 0x08	; 8
    3294:	0f b6       	in	r0, 0x3f	; 63
    3296:	f8 94       	cli
    3298:	de bf       	out	0x3e, r29	; 62
    329a:	0f be       	out	0x3f, r0	; 63
    329c:	cd bf       	out	0x3d, r28	; 61
    329e:	cf 91       	pop	r28
    32a0:	df 91       	pop	r29
    32a2:	08 95       	ret

000032a4 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    32a4:	df 93       	push	r29
    32a6:	cf 93       	push	r28
    32a8:	cd b7       	in	r28, 0x3d	; 61
    32aa:	de b7       	in	r29, 0x3e	; 62
    32ac:	29 97       	sbiw	r28, 0x09	; 9
    32ae:	0f b6       	in	r0, 0x3f	; 63
    32b0:	f8 94       	cli
    32b2:	de bf       	out	0x3e, r29	; 62
    32b4:	0f be       	out	0x3f, r0	; 63
    32b6:	cd bf       	out	0x3d, r28	; 61
    32b8:	9d 83       	std	Y+5, r25	; 0x05
    32ba:	8c 83       	std	Y+4, r24	; 0x04
    32bc:	7f 83       	std	Y+7, r23	; 0x07
    32be:	6e 83       	std	Y+6, r22	; 0x06
    32c0:	59 87       	std	Y+9, r21	; 0x09
    32c2:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    32c4:	8c 81       	ldd	r24, Y+4	; 0x04
    32c6:	9d 81       	ldd	r25, Y+5	; 0x05
    32c8:	9a 83       	std	Y+2, r25	; 0x02
    32ca:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    32cc:	e9 81       	ldd	r30, Y+1	; 0x01
    32ce:	fa 81       	ldd	r31, Y+2	; 0x02
    32d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    32d2:	88 23       	and	r24, r24
    32d4:	09 f4       	brne	.+2      	; 0x32d8 <xQueueCRReceiveFromISR+0x34>
    32d6:	50 c0       	rjmp	.+160    	; 0x3378 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    32d8:	e9 81       	ldd	r30, Y+1	; 0x01
    32da:	fa 81       	ldd	r31, Y+2	; 0x02
    32dc:	26 81       	ldd	r18, Z+6	; 0x06
    32de:	37 81       	ldd	r19, Z+7	; 0x07
    32e0:	e9 81       	ldd	r30, Y+1	; 0x01
    32e2:	fa 81       	ldd	r31, Y+2	; 0x02
    32e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    32e6:	88 2f       	mov	r24, r24
    32e8:	90 e0       	ldi	r25, 0x00	; 0
    32ea:	82 0f       	add	r24, r18
    32ec:	93 1f       	adc	r25, r19
    32ee:	e9 81       	ldd	r30, Y+1	; 0x01
    32f0:	fa 81       	ldd	r31, Y+2	; 0x02
    32f2:	97 83       	std	Z+7, r25	; 0x07
    32f4:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    32f6:	e9 81       	ldd	r30, Y+1	; 0x01
    32f8:	fa 81       	ldd	r31, Y+2	; 0x02
    32fa:	26 81       	ldd	r18, Z+6	; 0x06
    32fc:	37 81       	ldd	r19, Z+7	; 0x07
    32fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3300:	fa 81       	ldd	r31, Y+2	; 0x02
    3302:	82 81       	ldd	r24, Z+2	; 0x02
    3304:	93 81       	ldd	r25, Z+3	; 0x03
    3306:	28 17       	cp	r18, r24
    3308:	39 07       	cpc	r19, r25
    330a:	40 f0       	brcs	.+16     	; 0x331c <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    330c:	e9 81       	ldd	r30, Y+1	; 0x01
    330e:	fa 81       	ldd	r31, Y+2	; 0x02
    3310:	80 81       	ld	r24, Z
    3312:	91 81       	ldd	r25, Z+1	; 0x01
    3314:	e9 81       	ldd	r30, Y+1	; 0x01
    3316:	fa 81       	ldd	r31, Y+2	; 0x02
    3318:	97 83       	std	Z+7, r25	; 0x07
    331a:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    331c:	e9 81       	ldd	r30, Y+1	; 0x01
    331e:	fa 81       	ldd	r31, Y+2	; 0x02
    3320:	82 8d       	ldd	r24, Z+26	; 0x1a
    3322:	81 50       	subi	r24, 0x01	; 1
    3324:	e9 81       	ldd	r30, Y+1	; 0x01
    3326:	fa 81       	ldd	r31, Y+2	; 0x02
    3328:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    332a:	e9 81       	ldd	r30, Y+1	; 0x01
    332c:	fa 81       	ldd	r31, Y+2	; 0x02
    332e:	46 81       	ldd	r20, Z+6	; 0x06
    3330:	57 81       	ldd	r21, Z+7	; 0x07
    3332:	e9 81       	ldd	r30, Y+1	; 0x01
    3334:	fa 81       	ldd	r31, Y+2	; 0x02
    3336:	84 8d       	ldd	r24, Z+28	; 0x1c
    3338:	28 2f       	mov	r18, r24
    333a:	30 e0       	ldi	r19, 0x00	; 0
    333c:	8e 81       	ldd	r24, Y+6	; 0x06
    333e:	9f 81       	ldd	r25, Y+7	; 0x07
    3340:	ba 01       	movw	r22, r20
    3342:	a9 01       	movw	r20, r18
    3344:	0e 94 e9 2d 	call	0x5bd2	; 0x5bd2 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    3348:	e8 85       	ldd	r30, Y+8	; 0x08
    334a:	f9 85       	ldd	r31, Y+9	; 0x09
    334c:	80 81       	ld	r24, Z
    334e:	88 23       	and	r24, r24
    3350:	81 f4       	brne	.+32     	; 0x3372 <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3352:	e9 81       	ldd	r30, Y+1	; 0x01
    3354:	fa 81       	ldd	r31, Y+2	; 0x02
    3356:	80 85       	ldd	r24, Z+8	; 0x08
    3358:	88 23       	and	r24, r24
    335a:	59 f0       	breq	.+22     	; 0x3372 <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    335c:	89 81       	ldd	r24, Y+1	; 0x01
    335e:	9a 81       	ldd	r25, Y+2	; 0x02
    3360:	08 96       	adiw	r24, 0x08	; 8
    3362:	0e 94 4b 09 	call	0x1296	; 0x1296 <xCoRoutineRemoveFromEventList>
    3366:	88 23       	and	r24, r24
    3368:	21 f0       	breq	.+8      	; 0x3372 <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    336a:	e8 85       	ldd	r30, Y+8	; 0x08
    336c:	f9 85       	ldd	r31, Y+9	; 0x09
    336e:	81 e0       	ldi	r24, 0x01	; 1
    3370:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    3372:	81 e0       	ldi	r24, 0x01	; 1
    3374:	8b 83       	std	Y+3, r24	; 0x03
    3376:	01 c0       	rjmp	.+2      	; 0x337a <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    3378:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    337a:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    337c:	29 96       	adiw	r28, 0x09	; 9
    337e:	0f b6       	in	r0, 0x3f	; 63
    3380:	f8 94       	cli
    3382:	de bf       	out	0x3e, r29	; 62
    3384:	0f be       	out	0x3f, r0	; 63
    3386:	cd bf       	out	0x3d, r28	; 61
    3388:	cf 91       	pop	r28
    338a:	df 91       	pop	r29
    338c:	08 95       	ret

0000338e <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    338e:	af 92       	push	r10
    3390:	bf 92       	push	r11
    3392:	cf 92       	push	r12
    3394:	df 92       	push	r13
    3396:	ef 92       	push	r14
    3398:	ff 92       	push	r15
    339a:	0f 93       	push	r16
    339c:	1f 93       	push	r17
    339e:	df 93       	push	r29
    33a0:	cf 93       	push	r28
    33a2:	cd b7       	in	r28, 0x3d	; 61
    33a4:	de b7       	in	r29, 0x3e	; 62
    33a6:	64 97       	sbiw	r28, 0x14	; 20
    33a8:	0f b6       	in	r0, 0x3f	; 63
    33aa:	f8 94       	cli
    33ac:	de bf       	out	0x3e, r29	; 62
    33ae:	0f be       	out	0x3f, r0	; 63
    33b0:	cd bf       	out	0x3d, r28	; 61
    33b2:	9f 83       	std	Y+7, r25	; 0x07
    33b4:	8e 83       	std	Y+6, r24	; 0x06
    33b6:	79 87       	std	Y+9, r23	; 0x09
    33b8:	68 87       	std	Y+8, r22	; 0x08
    33ba:	5b 87       	std	Y+11, r21	; 0x0b
    33bc:	4a 87       	std	Y+10, r20	; 0x0a
    33be:	3d 87       	std	Y+13, r19	; 0x0d
    33c0:	2c 87       	std	Y+12, r18	; 0x0c
    33c2:	0e 87       	std	Y+14, r16	; 0x0e
    33c4:	f8 8a       	std	Y+16, r15	; 0x10
    33c6:	ef 86       	std	Y+15, r14	; 0x0f
    33c8:	da 8a       	std	Y+18, r13	; 0x12
    33ca:	c9 8a       	std	Y+17, r12	; 0x11
    33cc:	bc 8a       	std	Y+20, r11	; 0x14
    33ce:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    33d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    33d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    33d4:	29 89       	ldd	r18, Y+17	; 0x11
    33d6:	3a 89       	ldd	r19, Y+18	; 0x12
    33d8:	b9 01       	movw	r22, r18
    33da:	0e 94 31 21 	call	0x4262	; 0x4262 <prvAllocateTCBAndStack>
    33de:	9c 83       	std	Y+4, r25	; 0x04
    33e0:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    33e2:	8b 81       	ldd	r24, Y+3	; 0x03
    33e4:	9c 81       	ldd	r25, Y+4	; 0x04
    33e6:	00 97       	sbiw	r24, 0x00	; 0
    33e8:	09 f4       	brne	.+2      	; 0x33ec <xTaskGenericCreate+0x5e>
    33ea:	8d c0       	rjmp	.+282    	; 0x3506 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    33ec:	eb 81       	ldd	r30, Y+3	; 0x03
    33ee:	fc 81       	ldd	r31, Y+4	; 0x04
    33f0:	27 89       	ldd	r18, Z+23	; 0x17
    33f2:	30 8d       	ldd	r19, Z+24	; 0x18
    33f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    33f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    33f8:	01 97       	sbiw	r24, 0x01	; 1
    33fa:	82 0f       	add	r24, r18
    33fc:	93 1f       	adc	r25, r19
    33fe:	9a 83       	std	Y+2, r25	; 0x02
    3400:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    3402:	8b 81       	ldd	r24, Y+3	; 0x03
    3404:	9c 81       	ldd	r25, Y+4	; 0x04
    3406:	28 85       	ldd	r18, Y+8	; 0x08
    3408:	39 85       	ldd	r19, Y+9	; 0x09
    340a:	eb 89       	ldd	r30, Y+19	; 0x13
    340c:	fc 89       	ldd	r31, Y+20	; 0x14
    340e:	aa 85       	ldd	r26, Y+10	; 0x0a
    3410:	bb 85       	ldd	r27, Y+11	; 0x0b
    3412:	b9 01       	movw	r22, r18
    3414:	4e 85       	ldd	r20, Y+14	; 0x0e
    3416:	9f 01       	movw	r18, r30
    3418:	8d 01       	movw	r16, r26
    341a:	0e 94 f2 1f 	call	0x3fe4	; 0x3fe4 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    341e:	89 81       	ldd	r24, Y+1	; 0x01
    3420:	9a 81       	ldd	r25, Y+2	; 0x02
    3422:	2e 81       	ldd	r18, Y+6	; 0x06
    3424:	3f 81       	ldd	r19, Y+7	; 0x07
    3426:	4c 85       	ldd	r20, Y+12	; 0x0c
    3428:	5d 85       	ldd	r21, Y+13	; 0x0d
    342a:	b9 01       	movw	r22, r18
    342c:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <pxPortInitialiseStack>
    3430:	eb 81       	ldd	r30, Y+3	; 0x03
    3432:	fc 81       	ldd	r31, Y+4	; 0x04
    3434:	91 83       	std	Z+1, r25	; 0x01
    3436:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3438:	8f 85       	ldd	r24, Y+15	; 0x0f
    343a:	98 89       	ldd	r25, Y+16	; 0x10
    343c:	00 97       	sbiw	r24, 0x00	; 0
    343e:	31 f0       	breq	.+12     	; 0x344c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3440:	ef 85       	ldd	r30, Y+15	; 0x0f
    3442:	f8 89       	ldd	r31, Y+16	; 0x10
    3444:	8b 81       	ldd	r24, Y+3	; 0x03
    3446:	9c 81       	ldd	r25, Y+4	; 0x04
    3448:	91 83       	std	Z+1, r25	; 0x01
    344a:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    344c:	0f b6       	in	r0, 0x3f	; 63
    344e:	f8 94       	cli
    3450:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3452:	80 91 be 0b 	lds	r24, 0x0BBE
    3456:	8f 5f       	subi	r24, 0xFF	; 255
    3458:	80 93 be 0b 	sts	0x0BBE, r24
			if( pxCurrentTCB == NULL )
    345c:	80 91 bb 0b 	lds	r24, 0x0BBB
    3460:	90 91 bc 0b 	lds	r25, 0x0BBC
    3464:	00 97       	sbiw	r24, 0x00	; 0
    3466:	69 f4       	brne	.+26     	; 0x3482 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3468:	8b 81       	ldd	r24, Y+3	; 0x03
    346a:	9c 81       	ldd	r25, Y+4	; 0x04
    346c:	90 93 bc 0b 	sts	0x0BBC, r25
    3470:	80 93 bb 0b 	sts	0x0BBB, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3474:	80 91 be 0b 	lds	r24, 0x0BBE
    3478:	81 30       	cpi	r24, 0x01	; 1
    347a:	a9 f4       	brne	.+42     	; 0x34a6 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    347c:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <prvInitialiseTaskLists>
    3480:	12 c0       	rjmp	.+36     	; 0x34a6 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3482:	80 91 c2 0b 	lds	r24, 0x0BC2
    3486:	88 23       	and	r24, r24
    3488:	71 f4       	brne	.+28     	; 0x34a6 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    348a:	e0 91 bb 0b 	lds	r30, 0x0BBB
    348e:	f0 91 bc 0b 	lds	r31, 0x0BBC
    3492:	96 89       	ldd	r25, Z+22	; 0x16
    3494:	8e 85       	ldd	r24, Y+14	; 0x0e
    3496:	89 17       	cp	r24, r25
    3498:	30 f0       	brcs	.+12     	; 0x34a6 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
    349c:	9c 81       	ldd	r25, Y+4	; 0x04
    349e:	90 93 bc 0b 	sts	0x0BBC, r25
    34a2:	80 93 bb 0b 	sts	0x0BBB, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    34a6:	80 91 c6 0b 	lds	r24, 0x0BC6
    34aa:	8f 5f       	subi	r24, 0xFF	; 255
    34ac:	80 93 c6 0b 	sts	0x0BC6, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    34b0:	eb 81       	ldd	r30, Y+3	; 0x03
    34b2:	fc 81       	ldd	r31, Y+4	; 0x04
    34b4:	96 89       	ldd	r25, Z+22	; 0x16
    34b6:	80 91 c1 0b 	lds	r24, 0x0BC1
    34ba:	89 17       	cp	r24, r25
    34bc:	28 f4       	brcc	.+10     	; 0x34c8 <xTaskGenericCreate+0x13a>
    34be:	eb 81       	ldd	r30, Y+3	; 0x03
    34c0:	fc 81       	ldd	r31, Y+4	; 0x04
    34c2:	86 89       	ldd	r24, Z+22	; 0x16
    34c4:	80 93 c1 0b 	sts	0x0BC1, r24
    34c8:	eb 81       	ldd	r30, Y+3	; 0x03
    34ca:	fc 81       	ldd	r31, Y+4	; 0x04
    34cc:	86 89       	ldd	r24, Z+22	; 0x16
    34ce:	28 2f       	mov	r18, r24
    34d0:	30 e0       	ldi	r19, 0x00	; 0
    34d2:	c9 01       	movw	r24, r18
    34d4:	88 0f       	add	r24, r24
    34d6:	99 1f       	adc	r25, r25
    34d8:	88 0f       	add	r24, r24
    34da:	99 1f       	adc	r25, r25
    34dc:	88 0f       	add	r24, r24
    34de:	99 1f       	adc	r25, r25
    34e0:	82 0f       	add	r24, r18
    34e2:	93 1f       	adc	r25, r19
    34e4:	ac 01       	movw	r20, r24
    34e6:	48 53       	subi	r20, 0x38	; 56
    34e8:	54 4f       	sbci	r21, 0xF4	; 244
    34ea:	8b 81       	ldd	r24, Y+3	; 0x03
    34ec:	9c 81       	ldd	r25, Y+4	; 0x04
    34ee:	9c 01       	movw	r18, r24
    34f0:	2e 5f       	subi	r18, 0xFE	; 254
    34f2:	3f 4f       	sbci	r19, 0xFF	; 255
    34f4:	ca 01       	movw	r24, r20
    34f6:	b9 01       	movw	r22, r18
    34f8:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

			xReturn = pdPASS;
    34fc:	81 e0       	ldi	r24, 0x01	; 1
    34fe:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3500:	0f 90       	pop	r0
    3502:	0f be       	out	0x3f, r0	; 63
    3504:	02 c0       	rjmp	.+4      	; 0x350a <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3506:	8f ef       	ldi	r24, 0xFF	; 255
    3508:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    350a:	8d 81       	ldd	r24, Y+5	; 0x05
    350c:	81 30       	cpi	r24, 0x01	; 1
    350e:	71 f4       	brne	.+28     	; 0x352c <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    3510:	80 91 c2 0b 	lds	r24, 0x0BC2
    3514:	88 23       	and	r24, r24
    3516:	51 f0       	breq	.+20     	; 0x352c <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3518:	e0 91 bb 0b 	lds	r30, 0x0BBB
    351c:	f0 91 bc 0b 	lds	r31, 0x0BBC
    3520:	96 89       	ldd	r25, Z+22	; 0x16
    3522:	8e 85       	ldd	r24, Y+14	; 0x0e
    3524:	98 17       	cp	r25, r24
    3526:	10 f4       	brcc	.+4      	; 0x352c <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    3528:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    352c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    352e:	64 96       	adiw	r28, 0x14	; 20
    3530:	0f b6       	in	r0, 0x3f	; 63
    3532:	f8 94       	cli
    3534:	de bf       	out	0x3e, r29	; 62
    3536:	0f be       	out	0x3f, r0	; 63
    3538:	cd bf       	out	0x3d, r28	; 61
    353a:	cf 91       	pop	r28
    353c:	df 91       	pop	r29
    353e:	1f 91       	pop	r17
    3540:	0f 91       	pop	r16
    3542:	ff 90       	pop	r15
    3544:	ef 90       	pop	r14
    3546:	df 90       	pop	r13
    3548:	cf 90       	pop	r12
    354a:	bf 90       	pop	r11
    354c:	af 90       	pop	r10
    354e:	08 95       	ret

00003550 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3550:	df 93       	push	r29
    3552:	cf 93       	push	r28
    3554:	00 d0       	rcall	.+0      	; 0x3556 <vTaskDelete+0x6>
    3556:	00 d0       	rcall	.+0      	; 0x3558 <vTaskDelete+0x8>
    3558:	00 d0       	rcall	.+0      	; 0x355a <vTaskDelete+0xa>
    355a:	cd b7       	in	r28, 0x3d	; 61
    355c:	de b7       	in	r29, 0x3e	; 62
    355e:	9c 83       	std	Y+4, r25	; 0x04
    3560:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3562:	0f b6       	in	r0, 0x3f	; 63
    3564:	f8 94       	cli
    3566:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3568:	8b 81       	ldd	r24, Y+3	; 0x03
    356a:	9c 81       	ldd	r25, Y+4	; 0x04
    356c:	00 97       	sbiw	r24, 0x00	; 0
    356e:	39 f4       	brne	.+14     	; 0x357e <vTaskDelete+0x2e>
    3570:	80 91 bb 0b 	lds	r24, 0x0BBB
    3574:	90 91 bc 0b 	lds	r25, 0x0BBC
    3578:	9e 83       	std	Y+6, r25	; 0x06
    357a:	8d 83       	std	Y+5, r24	; 0x05
    357c:	04 c0       	rjmp	.+8      	; 0x3586 <vTaskDelete+0x36>
    357e:	8b 81       	ldd	r24, Y+3	; 0x03
    3580:	9c 81       	ldd	r25, Y+4	; 0x04
    3582:	9e 83       	std	Y+6, r25	; 0x06
    3584:	8d 83       	std	Y+5, r24	; 0x05
    3586:	8d 81       	ldd	r24, Y+5	; 0x05
    3588:	9e 81       	ldd	r25, Y+6	; 0x06
    358a:	9a 83       	std	Y+2, r25	; 0x02
    358c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    358e:	89 81       	ldd	r24, Y+1	; 0x01
    3590:	9a 81       	ldd	r25, Y+2	; 0x02
    3592:	02 96       	adiw	r24, 0x02	; 2
    3594:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3598:	e9 81       	ldd	r30, Y+1	; 0x01
    359a:	fa 81       	ldd	r31, Y+2	; 0x02
    359c:	84 89       	ldd	r24, Z+20	; 0x14
    359e:	95 89       	ldd	r25, Z+21	; 0x15
    35a0:	00 97       	sbiw	r24, 0x00	; 0
    35a2:	29 f0       	breq	.+10     	; 0x35ae <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    35a4:	89 81       	ldd	r24, Y+1	; 0x01
    35a6:	9a 81       	ldd	r25, Y+2	; 0x02
    35a8:	0c 96       	adiw	r24, 0x0c	; 12
    35aa:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    35ae:	89 81       	ldd	r24, Y+1	; 0x01
    35b0:	9a 81       	ldd	r25, Y+2	; 0x02
    35b2:	9c 01       	movw	r18, r24
    35b4:	2e 5f       	subi	r18, 0xFE	; 254
    35b6:	3f 4f       	sbci	r19, 0xFF	; 255
    35b8:	8d e1       	ldi	r24, 0x1D	; 29
    35ba:	9c e0       	ldi	r25, 0x0C	; 12
    35bc:	b9 01       	movw	r22, r18
    35be:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    35c2:	80 91 bd 0b 	lds	r24, 0x0BBD
    35c6:	8f 5f       	subi	r24, 0xFF	; 255
    35c8:	80 93 bd 0b 	sts	0x0BBD, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    35cc:	80 91 c6 0b 	lds	r24, 0x0BC6
    35d0:	8f 5f       	subi	r24, 0xFF	; 255
    35d2:	80 93 c6 0b 	sts	0x0BC6, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    35d6:	0f 90       	pop	r0
    35d8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    35da:	80 91 c2 0b 	lds	r24, 0x0BC2
    35de:	88 23       	and	r24, r24
    35e0:	99 f0       	breq	.+38     	; 0x3608 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    35e2:	20 91 bb 0b 	lds	r18, 0x0BBB
    35e6:	30 91 bc 0b 	lds	r19, 0x0BBC
    35ea:	89 81       	ldd	r24, Y+1	; 0x01
    35ec:	9a 81       	ldd	r25, Y+2	; 0x02
    35ee:	82 17       	cp	r24, r18
    35f0:	93 07       	cpc	r25, r19
    35f2:	19 f4       	brne	.+6      	; 0x35fa <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    35f4:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
    35f8:	07 c0       	rjmp	.+14     	; 0x3608 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    35fa:	0f b6       	in	r0, 0x3f	; 63
    35fc:	f8 94       	cli
    35fe:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    3600:	0e 94 8b 21 	call	0x4316	; 0x4316 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    3604:	0f 90       	pop	r0
    3606:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    3608:	26 96       	adiw	r28, 0x06	; 6
    360a:	0f b6       	in	r0, 0x3f	; 63
    360c:	f8 94       	cli
    360e:	de bf       	out	0x3e, r29	; 62
    3610:	0f be       	out	0x3f, r0	; 63
    3612:	cd bf       	out	0x3d, r28	; 61
    3614:	cf 91       	pop	r28
    3616:	df 91       	pop	r29
    3618:	08 95       	ret

0000361a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    361a:	df 93       	push	r29
    361c:	cf 93       	push	r28
    361e:	cd b7       	in	r28, 0x3d	; 61
    3620:	de b7       	in	r29, 0x3e	; 62
    3622:	2a 97       	sbiw	r28, 0x0a	; 10
    3624:	0f b6       	in	r0, 0x3f	; 63
    3626:	f8 94       	cli
    3628:	de bf       	out	0x3e, r29	; 62
    362a:	0f be       	out	0x3f, r0	; 63
    362c:	cd bf       	out	0x3d, r28	; 61
    362e:	98 87       	std	Y+8, r25	; 0x08
    3630:	8f 83       	std	Y+7, r24	; 0x07
    3632:	7a 87       	std	Y+10, r23	; 0x0a
    3634:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3636:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3638:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    363c:	80 91 bf 0b 	lds	r24, 0x0BBF
    3640:	90 91 c0 0b 	lds	r25, 0x0BC0
    3644:	9a 83       	std	Y+2, r25	; 0x02
    3646:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3648:	ef 81       	ldd	r30, Y+7	; 0x07
    364a:	f8 85       	ldd	r31, Y+8	; 0x08
    364c:	20 81       	ld	r18, Z
    364e:	31 81       	ldd	r19, Z+1	; 0x01
    3650:	89 85       	ldd	r24, Y+9	; 0x09
    3652:	9a 85       	ldd	r25, Y+10	; 0x0a
    3654:	82 0f       	add	r24, r18
    3656:	93 1f       	adc	r25, r19
    3658:	9e 83       	std	Y+6, r25	; 0x06
    365a:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    365c:	ef 81       	ldd	r30, Y+7	; 0x07
    365e:	f8 85       	ldd	r31, Y+8	; 0x08
    3660:	20 81       	ld	r18, Z
    3662:	31 81       	ldd	r19, Z+1	; 0x01
    3664:	89 81       	ldd	r24, Y+1	; 0x01
    3666:	9a 81       	ldd	r25, Y+2	; 0x02
    3668:	82 17       	cp	r24, r18
    366a:	93 07       	cpc	r25, r19
    366c:	98 f4       	brcc	.+38     	; 0x3694 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    366e:	ef 81       	ldd	r30, Y+7	; 0x07
    3670:	f8 85       	ldd	r31, Y+8	; 0x08
    3672:	20 81       	ld	r18, Z
    3674:	31 81       	ldd	r19, Z+1	; 0x01
    3676:	8d 81       	ldd	r24, Y+5	; 0x05
    3678:	9e 81       	ldd	r25, Y+6	; 0x06
    367a:	82 17       	cp	r24, r18
    367c:	93 07       	cpc	r25, r19
    367e:	e0 f4       	brcc	.+56     	; 0x36b8 <vTaskDelayUntil+0x9e>
    3680:	2d 81       	ldd	r18, Y+5	; 0x05
    3682:	3e 81       	ldd	r19, Y+6	; 0x06
    3684:	89 81       	ldd	r24, Y+1	; 0x01
    3686:	9a 81       	ldd	r25, Y+2	; 0x02
    3688:	82 17       	cp	r24, r18
    368a:	93 07       	cpc	r25, r19
    368c:	a8 f4       	brcc	.+42     	; 0x36b8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    368e:	81 e0       	ldi	r24, 0x01	; 1
    3690:	8b 83       	std	Y+3, r24	; 0x03
    3692:	12 c0       	rjmp	.+36     	; 0x36b8 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3694:	ef 81       	ldd	r30, Y+7	; 0x07
    3696:	f8 85       	ldd	r31, Y+8	; 0x08
    3698:	20 81       	ld	r18, Z
    369a:	31 81       	ldd	r19, Z+1	; 0x01
    369c:	8d 81       	ldd	r24, Y+5	; 0x05
    369e:	9e 81       	ldd	r25, Y+6	; 0x06
    36a0:	82 17       	cp	r24, r18
    36a2:	93 07       	cpc	r25, r19
    36a4:	38 f0       	brcs	.+14     	; 0x36b4 <vTaskDelayUntil+0x9a>
    36a6:	2d 81       	ldd	r18, Y+5	; 0x05
    36a8:	3e 81       	ldd	r19, Y+6	; 0x06
    36aa:	89 81       	ldd	r24, Y+1	; 0x01
    36ac:	9a 81       	ldd	r25, Y+2	; 0x02
    36ae:	82 17       	cp	r24, r18
    36b0:	93 07       	cpc	r25, r19
    36b2:	10 f4       	brcc	.+4      	; 0x36b8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    36b4:	81 e0       	ldi	r24, 0x01	; 1
    36b6:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    36b8:	ef 81       	ldd	r30, Y+7	; 0x07
    36ba:	f8 85       	ldd	r31, Y+8	; 0x08
    36bc:	8d 81       	ldd	r24, Y+5	; 0x05
    36be:	9e 81       	ldd	r25, Y+6	; 0x06
    36c0:	91 83       	std	Z+1, r25	; 0x01
    36c2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    36c4:	8b 81       	ldd	r24, Y+3	; 0x03
    36c6:	88 23       	and	r24, r24
    36c8:	59 f0       	breq	.+22     	; 0x36e0 <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    36ca:	80 91 bb 0b 	lds	r24, 0x0BBB
    36ce:	90 91 bc 0b 	lds	r25, 0x0BBC
    36d2:	02 96       	adiw	r24, 0x02	; 2
    36d4:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    36d8:	8d 81       	ldd	r24, Y+5	; 0x05
    36da:	9e 81       	ldd	r25, Y+6	; 0x06
    36dc:	0e 94 e8 20 	call	0x41d0	; 0x41d0 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    36e0:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    36e4:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    36e6:	8c 81       	ldd	r24, Y+4	; 0x04
    36e8:	88 23       	and	r24, r24
    36ea:	11 f4       	brne	.+4      	; 0x36f0 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    36ec:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    36f0:	2a 96       	adiw	r28, 0x0a	; 10
    36f2:	0f b6       	in	r0, 0x3f	; 63
    36f4:	f8 94       	cli
    36f6:	de bf       	out	0x3e, r29	; 62
    36f8:	0f be       	out	0x3f, r0	; 63
    36fa:	cd bf       	out	0x3d, r28	; 61
    36fc:	cf 91       	pop	r28
    36fe:	df 91       	pop	r29
    3700:	08 95       	ret

00003702 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3702:	df 93       	push	r29
    3704:	cf 93       	push	r28
    3706:	00 d0       	rcall	.+0      	; 0x3708 <vTaskDelay+0x6>
    3708:	00 d0       	rcall	.+0      	; 0x370a <vTaskDelay+0x8>
    370a:	0f 92       	push	r0
    370c:	cd b7       	in	r28, 0x3d	; 61
    370e:	de b7       	in	r29, 0x3e	; 62
    3710:	9d 83       	std	Y+5, r25	; 0x05
    3712:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    3714:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3716:	8c 81       	ldd	r24, Y+4	; 0x04
    3718:	9d 81       	ldd	r25, Y+5	; 0x05
    371a:	00 97       	sbiw	r24, 0x00	; 0
    371c:	d1 f0       	breq	.+52     	; 0x3752 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    371e:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3722:	20 91 bf 0b 	lds	r18, 0x0BBF
    3726:	30 91 c0 0b 	lds	r19, 0x0BC0
    372a:	8c 81       	ldd	r24, Y+4	; 0x04
    372c:	9d 81       	ldd	r25, Y+5	; 0x05
    372e:	82 0f       	add	r24, r18
    3730:	93 1f       	adc	r25, r19
    3732:	9b 83       	std	Y+3, r25	; 0x03
    3734:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3736:	80 91 bb 0b 	lds	r24, 0x0BBB
    373a:	90 91 bc 0b 	lds	r25, 0x0BBC
    373e:	02 96       	adiw	r24, 0x02	; 2
    3740:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3744:	8a 81       	ldd	r24, Y+2	; 0x02
    3746:	9b 81       	ldd	r25, Y+3	; 0x03
    3748:	0e 94 e8 20 	call	0x41d0	; 0x41d0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    374c:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>
    3750:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3752:	89 81       	ldd	r24, Y+1	; 0x01
    3754:	88 23       	and	r24, r24
    3756:	11 f4       	brne	.+4      	; 0x375c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3758:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    375c:	0f 90       	pop	r0
    375e:	0f 90       	pop	r0
    3760:	0f 90       	pop	r0
    3762:	0f 90       	pop	r0
    3764:	0f 90       	pop	r0
    3766:	cf 91       	pop	r28
    3768:	df 91       	pop	r29
    376a:	08 95       	ret

0000376c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    376c:	af 92       	push	r10
    376e:	bf 92       	push	r11
    3770:	cf 92       	push	r12
    3772:	df 92       	push	r13
    3774:	ef 92       	push	r14
    3776:	ff 92       	push	r15
    3778:	0f 93       	push	r16
    377a:	df 93       	push	r29
    377c:	cf 93       	push	r28
    377e:	0f 92       	push	r0
    3780:	cd b7       	in	r28, 0x3d	; 61
    3782:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3784:	82 ee       	ldi	r24, 0xE2	; 226
    3786:	9f e1       	ldi	r25, 0x1F	; 31
    3788:	28 e1       	ldi	r18, 0x18	; 24
    378a:	31 e0       	ldi	r19, 0x01	; 1
    378c:	b9 01       	movw	r22, r18
    378e:	45 e5       	ldi	r20, 0x55	; 85
    3790:	50 e0       	ldi	r21, 0x00	; 0
    3792:	20 e0       	ldi	r18, 0x00	; 0
    3794:	30 e0       	ldi	r19, 0x00	; 0
    3796:	00 e0       	ldi	r16, 0x00	; 0
    3798:	ee 24       	eor	r14, r14
    379a:	ff 24       	eor	r15, r15
    379c:	cc 24       	eor	r12, r12
    379e:	dd 24       	eor	r13, r13
    37a0:	aa 24       	eor	r10, r10
    37a2:	bb 24       	eor	r11, r11
    37a4:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>
    37a8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    37aa:	89 81       	ldd	r24, Y+1	; 0x01
    37ac:	81 30       	cpi	r24, 0x01	; 1
    37ae:	51 f4       	brne	.+20     	; 0x37c4 <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    37b0:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    37b2:	81 e0       	ldi	r24, 0x01	; 1
    37b4:	80 93 c2 0b 	sts	0x0BC2, r24
		xTickCount = ( TickType_t ) 0U;
    37b8:	10 92 c0 0b 	sts	0x0BC0, r1
    37bc:	10 92 bf 0b 	sts	0x0BBF, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    37c0:	0e 94 ca 10 	call	0x2194	; 0x2194 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    37c4:	0f 90       	pop	r0
    37c6:	cf 91       	pop	r28
    37c8:	df 91       	pop	r29
    37ca:	0f 91       	pop	r16
    37cc:	ff 90       	pop	r15
    37ce:	ef 90       	pop	r14
    37d0:	df 90       	pop	r13
    37d2:	cf 90       	pop	r12
    37d4:	bf 90       	pop	r11
    37d6:	af 90       	pop	r10
    37d8:	08 95       	ret

000037da <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    37da:	df 93       	push	r29
    37dc:	cf 93       	push	r28
    37de:	cd b7       	in	r28, 0x3d	; 61
    37e0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    37e2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    37e4:	10 92 c2 0b 	sts	0x0BC2, r1
	vPortEndScheduler();
    37e8:	0e 94 ff 10 	call	0x21fe	; 0x21fe <vPortEndScheduler>
}
    37ec:	cf 91       	pop	r28
    37ee:	df 91       	pop	r29
    37f0:	08 95       	ret

000037f2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    37f2:	df 93       	push	r29
    37f4:	cf 93       	push	r28
    37f6:	cd b7       	in	r28, 0x3d	; 61
    37f8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    37fa:	80 91 c7 0b 	lds	r24, 0x0BC7
    37fe:	8f 5f       	subi	r24, 0xFF	; 255
    3800:	80 93 c7 0b 	sts	0x0BC7, r24
}
    3804:	cf 91       	pop	r28
    3806:	df 91       	pop	r29
    3808:	08 95       	ret

0000380a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    380a:	df 93       	push	r29
    380c:	cf 93       	push	r28
    380e:	00 d0       	rcall	.+0      	; 0x3810 <xTaskResumeAll+0x6>
    3810:	0f 92       	push	r0
    3812:	cd b7       	in	r28, 0x3d	; 61
    3814:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    3816:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3818:	0f b6       	in	r0, 0x3f	; 63
    381a:	f8 94       	cli
    381c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    381e:	80 91 c7 0b 	lds	r24, 0x0BC7
    3822:	81 50       	subi	r24, 0x01	; 1
    3824:	80 93 c7 0b 	sts	0x0BC7, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3828:	80 91 c7 0b 	lds	r24, 0x0BC7
    382c:	88 23       	and	r24, r24
    382e:	09 f0       	breq	.+2      	; 0x3832 <xTaskResumeAll+0x28>
    3830:	6d c0       	rjmp	.+218    	; 0x390c <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3832:	80 91 be 0b 	lds	r24, 0x0BBE
    3836:	88 23       	and	r24, r24
    3838:	09 f4       	brne	.+2      	; 0x383c <xTaskResumeAll+0x32>
    383a:	68 c0       	rjmp	.+208    	; 0x390c <xTaskResumeAll+0x102>
    383c:	45 c0       	rjmp	.+138    	; 0x38c8 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    383e:	e0 91 19 0c 	lds	r30, 0x0C19
    3842:	f0 91 1a 0c 	lds	r31, 0x0C1A
    3846:	86 81       	ldd	r24, Z+6	; 0x06
    3848:	97 81       	ldd	r25, Z+7	; 0x07
    384a:	9b 83       	std	Y+3, r25	; 0x03
    384c:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    384e:	8a 81       	ldd	r24, Y+2	; 0x02
    3850:	9b 81       	ldd	r25, Y+3	; 0x03
    3852:	0c 96       	adiw	r24, 0x0c	; 12
    3854:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3858:	8a 81       	ldd	r24, Y+2	; 0x02
    385a:	9b 81       	ldd	r25, Y+3	; 0x03
    385c:	02 96       	adiw	r24, 0x02	; 2
    385e:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3862:	ea 81       	ldd	r30, Y+2	; 0x02
    3864:	fb 81       	ldd	r31, Y+3	; 0x03
    3866:	96 89       	ldd	r25, Z+22	; 0x16
    3868:	80 91 c1 0b 	lds	r24, 0x0BC1
    386c:	89 17       	cp	r24, r25
    386e:	28 f4       	brcc	.+10     	; 0x387a <xTaskResumeAll+0x70>
    3870:	ea 81       	ldd	r30, Y+2	; 0x02
    3872:	fb 81       	ldd	r31, Y+3	; 0x03
    3874:	86 89       	ldd	r24, Z+22	; 0x16
    3876:	80 93 c1 0b 	sts	0x0BC1, r24
    387a:	ea 81       	ldd	r30, Y+2	; 0x02
    387c:	fb 81       	ldd	r31, Y+3	; 0x03
    387e:	86 89       	ldd	r24, Z+22	; 0x16
    3880:	28 2f       	mov	r18, r24
    3882:	30 e0       	ldi	r19, 0x00	; 0
    3884:	c9 01       	movw	r24, r18
    3886:	88 0f       	add	r24, r24
    3888:	99 1f       	adc	r25, r25
    388a:	88 0f       	add	r24, r24
    388c:	99 1f       	adc	r25, r25
    388e:	88 0f       	add	r24, r24
    3890:	99 1f       	adc	r25, r25
    3892:	82 0f       	add	r24, r18
    3894:	93 1f       	adc	r25, r19
    3896:	ac 01       	movw	r20, r24
    3898:	48 53       	subi	r20, 0x38	; 56
    389a:	54 4f       	sbci	r21, 0xF4	; 244
    389c:	8a 81       	ldd	r24, Y+2	; 0x02
    389e:	9b 81       	ldd	r25, Y+3	; 0x03
    38a0:	9c 01       	movw	r18, r24
    38a2:	2e 5f       	subi	r18, 0xFE	; 254
    38a4:	3f 4f       	sbci	r19, 0xFF	; 255
    38a6:	ca 01       	movw	r24, r20
    38a8:	b9 01       	movw	r22, r18
    38aa:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    38ae:	ea 81       	ldd	r30, Y+2	; 0x02
    38b0:	fb 81       	ldd	r31, Y+3	; 0x03
    38b2:	96 89       	ldd	r25, Z+22	; 0x16
    38b4:	e0 91 bb 0b 	lds	r30, 0x0BBB
    38b8:	f0 91 bc 0b 	lds	r31, 0x0BBC
    38bc:	86 89       	ldd	r24, Z+22	; 0x16
    38be:	98 17       	cp	r25, r24
    38c0:	18 f0       	brcs	.+6      	; 0x38c8 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    38c2:	81 e0       	ldi	r24, 0x01	; 1
    38c4:	80 93 c4 0b 	sts	0x0BC4, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    38c8:	80 91 14 0c 	lds	r24, 0x0C14
    38cc:	88 23       	and	r24, r24
    38ce:	09 f0       	breq	.+2      	; 0x38d2 <xTaskResumeAll+0xc8>
    38d0:	b6 cf       	rjmp	.-148    	; 0x383e <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    38d2:	80 91 c3 0b 	lds	r24, 0x0BC3
    38d6:	88 23       	and	r24, r24
    38d8:	89 f0       	breq	.+34     	; 0x38fc <xTaskResumeAll+0xf2>
    38da:	0c c0       	rjmp	.+24     	; 0x38f4 <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    38dc:	0e 94 c4 1c 	call	0x3988	; 0x3988 <xTaskIncrementTick>
    38e0:	88 23       	and	r24, r24
    38e2:	19 f0       	breq	.+6      	; 0x38ea <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	80 93 c4 0b 	sts	0x0BC4, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    38ea:	80 91 c3 0b 	lds	r24, 0x0BC3
    38ee:	81 50       	subi	r24, 0x01	; 1
    38f0:	80 93 c3 0b 	sts	0x0BC3, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    38f4:	80 91 c3 0b 	lds	r24, 0x0BC3
    38f8:	88 23       	and	r24, r24
    38fa:	81 f7       	brne	.-32     	; 0x38dc <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    38fc:	80 91 c4 0b 	lds	r24, 0x0BC4
    3900:	81 30       	cpi	r24, 0x01	; 1
    3902:	21 f4       	brne	.+8      	; 0x390c <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3904:	81 e0       	ldi	r24, 0x01	; 1
    3906:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3908:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    390c:	0f 90       	pop	r0
    390e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3910:	89 81       	ldd	r24, Y+1	; 0x01
}
    3912:	0f 90       	pop	r0
    3914:	0f 90       	pop	r0
    3916:	0f 90       	pop	r0
    3918:	cf 91       	pop	r28
    391a:	df 91       	pop	r29
    391c:	08 95       	ret

0000391e <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    391e:	df 93       	push	r29
    3920:	cf 93       	push	r28
    3922:	00 d0       	rcall	.+0      	; 0x3924 <xTaskGetTickCount+0x6>
    3924:	cd b7       	in	r28, 0x3d	; 61
    3926:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3928:	0f b6       	in	r0, 0x3f	; 63
    392a:	f8 94       	cli
    392c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    392e:	80 91 bf 0b 	lds	r24, 0x0BBF
    3932:	90 91 c0 0b 	lds	r25, 0x0BC0
    3936:	9a 83       	std	Y+2, r25	; 0x02
    3938:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    393a:	0f 90       	pop	r0
    393c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    393e:	89 81       	ldd	r24, Y+1	; 0x01
    3940:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3942:	0f 90       	pop	r0
    3944:	0f 90       	pop	r0
    3946:	cf 91       	pop	r28
    3948:	df 91       	pop	r29
    394a:	08 95       	ret

0000394c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    394c:	df 93       	push	r29
    394e:	cf 93       	push	r28
    3950:	00 d0       	rcall	.+0      	; 0x3952 <xTaskGetTickCountFromISR+0x6>
    3952:	0f 92       	push	r0
    3954:	cd b7       	in	r28, 0x3d	; 61
    3956:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3958:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    395a:	80 91 bf 0b 	lds	r24, 0x0BBF
    395e:	90 91 c0 0b 	lds	r25, 0x0BC0
    3962:	9b 83       	std	Y+3, r25	; 0x03
    3964:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3966:	8a 81       	ldd	r24, Y+2	; 0x02
    3968:	9b 81       	ldd	r25, Y+3	; 0x03
}
    396a:	0f 90       	pop	r0
    396c:	0f 90       	pop	r0
    396e:	0f 90       	pop	r0
    3970:	cf 91       	pop	r28
    3972:	df 91       	pop	r29
    3974:	08 95       	ret

00003976 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3976:	df 93       	push	r29
    3978:	cf 93       	push	r28
    397a:	cd b7       	in	r28, 0x3d	; 61
    397c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    397e:	80 91 be 0b 	lds	r24, 0x0BBE
}
    3982:	cf 91       	pop	r28
    3984:	df 91       	pop	r29
    3986:	08 95       	ret

00003988 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3988:	df 93       	push	r29
    398a:	cf 93       	push	r28
    398c:	cd b7       	in	r28, 0x3d	; 61
    398e:	de b7       	in	r29, 0x3e	; 62
    3990:	29 97       	sbiw	r28, 0x09	; 9
    3992:	0f b6       	in	r0, 0x3f	; 63
    3994:	f8 94       	cli
    3996:	de bf       	out	0x3e, r29	; 62
    3998:	0f be       	out	0x3f, r0	; 63
    399a:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    399c:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    399e:	80 91 c7 0b 	lds	r24, 0x0BC7
    39a2:	88 23       	and	r24, r24
    39a4:	09 f0       	breq	.+2      	; 0x39a8 <xTaskIncrementTick+0x20>
    39a6:	c2 c0       	rjmp	.+388    	; 0x3b2c <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    39a8:	80 91 bf 0b 	lds	r24, 0x0BBF
    39ac:	90 91 c0 0b 	lds	r25, 0x0BC0
    39b0:	01 96       	adiw	r24, 0x01	; 1
    39b2:	90 93 c0 0b 	sts	0x0BC0, r25
    39b6:	80 93 bf 0b 	sts	0x0BBF, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    39ba:	80 91 bf 0b 	lds	r24, 0x0BBF
    39be:	90 91 c0 0b 	lds	r25, 0x0BC0
    39c2:	9c 83       	std	Y+4, r25	; 0x04
    39c4:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    39c6:	8b 81       	ldd	r24, Y+3	; 0x03
    39c8:	9c 81       	ldd	r25, Y+4	; 0x04
    39ca:	00 97       	sbiw	r24, 0x00	; 0
    39cc:	d9 f4       	brne	.+54     	; 0x3a04 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    39ce:	80 91 10 0c 	lds	r24, 0x0C10
    39d2:	90 91 11 0c 	lds	r25, 0x0C11
    39d6:	9a 83       	std	Y+2, r25	; 0x02
    39d8:	89 83       	std	Y+1, r24	; 0x01
    39da:	80 91 12 0c 	lds	r24, 0x0C12
    39de:	90 91 13 0c 	lds	r25, 0x0C13
    39e2:	90 93 11 0c 	sts	0x0C11, r25
    39e6:	80 93 10 0c 	sts	0x0C10, r24
    39ea:	89 81       	ldd	r24, Y+1	; 0x01
    39ec:	9a 81       	ldd	r25, Y+2	; 0x02
    39ee:	90 93 13 0c 	sts	0x0C13, r25
    39f2:	80 93 12 0c 	sts	0x0C12, r24
    39f6:	80 91 c5 0b 	lds	r24, 0x0BC5
    39fa:	8f 5f       	subi	r24, 0xFF	; 255
    39fc:	80 93 c5 0b 	sts	0x0BC5, r24
    3a00:	0e 94 8b 21 	call	0x4316	; 0x4316 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    3a04:	20 91 ab 01 	lds	r18, 0x01AB
    3a08:	30 91 ac 01 	lds	r19, 0x01AC
    3a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a10:	82 17       	cp	r24, r18
    3a12:	93 07       	cpc	r25, r19
    3a14:	08 f4       	brcc	.+2      	; 0x3a18 <xTaskIncrementTick+0x90>
    3a16:	71 c0       	rjmp	.+226    	; 0x3afa <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3a18:	e0 91 10 0c 	lds	r30, 0x0C10
    3a1c:	f0 91 11 0c 	lds	r31, 0x0C11
    3a20:	80 81       	ld	r24, Z
    3a22:	88 23       	and	r24, r24
    3a24:	39 f4       	brne	.+14     	; 0x3a34 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    3a26:	8f ef       	ldi	r24, 0xFF	; 255
    3a28:	9f ef       	ldi	r25, 0xFF	; 255
    3a2a:	90 93 ac 01 	sts	0x01AC, r25
    3a2e:	80 93 ab 01 	sts	0x01AB, r24
    3a32:	63 c0       	rjmp	.+198    	; 0x3afa <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3a34:	e0 91 10 0c 	lds	r30, 0x0C10
    3a38:	f0 91 11 0c 	lds	r31, 0x0C11
    3a3c:	05 80       	ldd	r0, Z+5	; 0x05
    3a3e:	f6 81       	ldd	r31, Z+6	; 0x06
    3a40:	e0 2d       	mov	r30, r0
    3a42:	86 81       	ldd	r24, Z+6	; 0x06
    3a44:	97 81       	ldd	r25, Z+7	; 0x07
    3a46:	99 87       	std	Y+9, r25	; 0x09
    3a48:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3a4a:	e8 85       	ldd	r30, Y+8	; 0x08
    3a4c:	f9 85       	ldd	r31, Y+9	; 0x09
    3a4e:	82 81       	ldd	r24, Z+2	; 0x02
    3a50:	93 81       	ldd	r25, Z+3	; 0x03
    3a52:	9f 83       	std	Y+7, r25	; 0x07
    3a54:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    3a56:	2b 81       	ldd	r18, Y+3	; 0x03
    3a58:	3c 81       	ldd	r19, Y+4	; 0x04
    3a5a:	8e 81       	ldd	r24, Y+6	; 0x06
    3a5c:	9f 81       	ldd	r25, Y+7	; 0x07
    3a5e:	28 17       	cp	r18, r24
    3a60:	39 07       	cpc	r19, r25
    3a62:	38 f4       	brcc	.+14     	; 0x3a72 <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    3a64:	8e 81       	ldd	r24, Y+6	; 0x06
    3a66:	9f 81       	ldd	r25, Y+7	; 0x07
    3a68:	90 93 ac 01 	sts	0x01AC, r25
    3a6c:	80 93 ab 01 	sts	0x01AB, r24
    3a70:	44 c0       	rjmp	.+136    	; 0x3afa <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3a72:	88 85       	ldd	r24, Y+8	; 0x08
    3a74:	99 85       	ldd	r25, Y+9	; 0x09
    3a76:	02 96       	adiw	r24, 0x02	; 2
    3a78:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3a7c:	e8 85       	ldd	r30, Y+8	; 0x08
    3a7e:	f9 85       	ldd	r31, Y+9	; 0x09
    3a80:	84 89       	ldd	r24, Z+20	; 0x14
    3a82:	95 89       	ldd	r25, Z+21	; 0x15
    3a84:	00 97       	sbiw	r24, 0x00	; 0
    3a86:	29 f0       	breq	.+10     	; 0x3a92 <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3a88:	88 85       	ldd	r24, Y+8	; 0x08
    3a8a:	99 85       	ldd	r25, Y+9	; 0x09
    3a8c:	0c 96       	adiw	r24, 0x0c	; 12
    3a8e:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3a92:	e8 85       	ldd	r30, Y+8	; 0x08
    3a94:	f9 85       	ldd	r31, Y+9	; 0x09
    3a96:	96 89       	ldd	r25, Z+22	; 0x16
    3a98:	80 91 c1 0b 	lds	r24, 0x0BC1
    3a9c:	89 17       	cp	r24, r25
    3a9e:	28 f4       	brcc	.+10     	; 0x3aaa <xTaskIncrementTick+0x122>
    3aa0:	e8 85       	ldd	r30, Y+8	; 0x08
    3aa2:	f9 85       	ldd	r31, Y+9	; 0x09
    3aa4:	86 89       	ldd	r24, Z+22	; 0x16
    3aa6:	80 93 c1 0b 	sts	0x0BC1, r24
    3aaa:	e8 85       	ldd	r30, Y+8	; 0x08
    3aac:	f9 85       	ldd	r31, Y+9	; 0x09
    3aae:	86 89       	ldd	r24, Z+22	; 0x16
    3ab0:	28 2f       	mov	r18, r24
    3ab2:	30 e0       	ldi	r19, 0x00	; 0
    3ab4:	c9 01       	movw	r24, r18
    3ab6:	88 0f       	add	r24, r24
    3ab8:	99 1f       	adc	r25, r25
    3aba:	88 0f       	add	r24, r24
    3abc:	99 1f       	adc	r25, r25
    3abe:	88 0f       	add	r24, r24
    3ac0:	99 1f       	adc	r25, r25
    3ac2:	82 0f       	add	r24, r18
    3ac4:	93 1f       	adc	r25, r19
    3ac6:	ac 01       	movw	r20, r24
    3ac8:	48 53       	subi	r20, 0x38	; 56
    3aca:	54 4f       	sbci	r21, 0xF4	; 244
    3acc:	88 85       	ldd	r24, Y+8	; 0x08
    3ace:	99 85       	ldd	r25, Y+9	; 0x09
    3ad0:	9c 01       	movw	r18, r24
    3ad2:	2e 5f       	subi	r18, 0xFE	; 254
    3ad4:	3f 4f       	sbci	r19, 0xFF	; 255
    3ad6:	ca 01       	movw	r24, r20
    3ad8:	b9 01       	movw	r22, r18
    3ada:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3ade:	e8 85       	ldd	r30, Y+8	; 0x08
    3ae0:	f9 85       	ldd	r31, Y+9	; 0x09
    3ae2:	96 89       	ldd	r25, Z+22	; 0x16
    3ae4:	e0 91 bb 0b 	lds	r30, 0x0BBB
    3ae8:	f0 91 bc 0b 	lds	r31, 0x0BBC
    3aec:	86 89       	ldd	r24, Z+22	; 0x16
    3aee:	98 17       	cp	r25, r24
    3af0:	08 f4       	brcc	.+2      	; 0x3af4 <xTaskIncrementTick+0x16c>
    3af2:	92 cf       	rjmp	.-220    	; 0x3a18 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    3af4:	81 e0       	ldi	r24, 0x01	; 1
    3af6:	8d 83       	std	Y+5, r24	; 0x05
    3af8:	8f cf       	rjmp	.-226    	; 0x3a18 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3afa:	e0 91 bb 0b 	lds	r30, 0x0BBB
    3afe:	f0 91 bc 0b 	lds	r31, 0x0BBC
    3b02:	86 89       	ldd	r24, Z+22	; 0x16
    3b04:	28 2f       	mov	r18, r24
    3b06:	30 e0       	ldi	r19, 0x00	; 0
    3b08:	c9 01       	movw	r24, r18
    3b0a:	88 0f       	add	r24, r24
    3b0c:	99 1f       	adc	r25, r25
    3b0e:	88 0f       	add	r24, r24
    3b10:	99 1f       	adc	r25, r25
    3b12:	88 0f       	add	r24, r24
    3b14:	99 1f       	adc	r25, r25
    3b16:	82 0f       	add	r24, r18
    3b18:	93 1f       	adc	r25, r19
    3b1a:	fc 01       	movw	r30, r24
    3b1c:	e8 53       	subi	r30, 0x38	; 56
    3b1e:	f4 4f       	sbci	r31, 0xF4	; 244
    3b20:	80 81       	ld	r24, Z
    3b22:	82 30       	cpi	r24, 0x02	; 2
    3b24:	40 f0       	brcs	.+16     	; 0x3b36 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    3b26:	81 e0       	ldi	r24, 0x01	; 1
    3b28:	8d 83       	std	Y+5, r24	; 0x05
    3b2a:	05 c0       	rjmp	.+10     	; 0x3b36 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3b2c:	80 91 c3 0b 	lds	r24, 0x0BC3
    3b30:	8f 5f       	subi	r24, 0xFF	; 255
    3b32:	80 93 c3 0b 	sts	0x0BC3, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3b36:	80 91 c4 0b 	lds	r24, 0x0BC4
    3b3a:	88 23       	and	r24, r24
    3b3c:	11 f0       	breq	.+4      	; 0x3b42 <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    3b3e:	81 e0       	ldi	r24, 0x01	; 1
    3b40:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3b42:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3b44:	29 96       	adiw	r28, 0x09	; 9
    3b46:	0f b6       	in	r0, 0x3f	; 63
    3b48:	f8 94       	cli
    3b4a:	de bf       	out	0x3e, r29	; 62
    3b4c:	0f be       	out	0x3f, r0	; 63
    3b4e:	cd bf       	out	0x3d, r28	; 61
    3b50:	cf 91       	pop	r28
    3b52:	df 91       	pop	r29
    3b54:	08 95       	ret

00003b56 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3b56:	df 93       	push	r29
    3b58:	cf 93       	push	r28
    3b5a:	00 d0       	rcall	.+0      	; 0x3b5c <vTaskSwitchContext+0x6>
    3b5c:	cd b7       	in	r28, 0x3d	; 61
    3b5e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3b60:	80 91 c7 0b 	lds	r24, 0x0BC7
    3b64:	88 23       	and	r24, r24
    3b66:	21 f0       	breq	.+8      	; 0x3b70 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3b68:	81 e0       	ldi	r24, 0x01	; 1
    3b6a:	80 93 c4 0b 	sts	0x0BC4, r24
    3b6e:	57 c0       	rjmp	.+174    	; 0x3c1e <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    3b70:	10 92 c4 0b 	sts	0x0BC4, r1
    3b74:	05 c0       	rjmp	.+10     	; 0x3b80 <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3b76:	80 91 c1 0b 	lds	r24, 0x0BC1
    3b7a:	81 50       	subi	r24, 0x01	; 1
    3b7c:	80 93 c1 0b 	sts	0x0BC1, r24
    3b80:	80 91 c1 0b 	lds	r24, 0x0BC1
    3b84:	28 2f       	mov	r18, r24
    3b86:	30 e0       	ldi	r19, 0x00	; 0
    3b88:	c9 01       	movw	r24, r18
    3b8a:	88 0f       	add	r24, r24
    3b8c:	99 1f       	adc	r25, r25
    3b8e:	88 0f       	add	r24, r24
    3b90:	99 1f       	adc	r25, r25
    3b92:	88 0f       	add	r24, r24
    3b94:	99 1f       	adc	r25, r25
    3b96:	82 0f       	add	r24, r18
    3b98:	93 1f       	adc	r25, r19
    3b9a:	fc 01       	movw	r30, r24
    3b9c:	e8 53       	subi	r30, 0x38	; 56
    3b9e:	f4 4f       	sbci	r31, 0xF4	; 244
    3ba0:	80 81       	ld	r24, Z
    3ba2:	88 23       	and	r24, r24
    3ba4:	41 f3       	breq	.-48     	; 0x3b76 <vTaskSwitchContext+0x20>
    3ba6:	80 91 c1 0b 	lds	r24, 0x0BC1
    3baa:	28 2f       	mov	r18, r24
    3bac:	30 e0       	ldi	r19, 0x00	; 0
    3bae:	c9 01       	movw	r24, r18
    3bb0:	88 0f       	add	r24, r24
    3bb2:	99 1f       	adc	r25, r25
    3bb4:	88 0f       	add	r24, r24
    3bb6:	99 1f       	adc	r25, r25
    3bb8:	88 0f       	add	r24, r24
    3bba:	99 1f       	adc	r25, r25
    3bbc:	82 0f       	add	r24, r18
    3bbe:	93 1f       	adc	r25, r19
    3bc0:	88 53       	subi	r24, 0x38	; 56
    3bc2:	94 4f       	sbci	r25, 0xF4	; 244
    3bc4:	9a 83       	std	Y+2, r25	; 0x02
    3bc6:	89 83       	std	Y+1, r24	; 0x01
    3bc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3bca:	fa 81       	ldd	r31, Y+2	; 0x02
    3bcc:	01 80       	ldd	r0, Z+1	; 0x01
    3bce:	f2 81       	ldd	r31, Z+2	; 0x02
    3bd0:	e0 2d       	mov	r30, r0
    3bd2:	82 81       	ldd	r24, Z+2	; 0x02
    3bd4:	93 81       	ldd	r25, Z+3	; 0x03
    3bd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3bd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3bda:	92 83       	std	Z+2, r25	; 0x02
    3bdc:	81 83       	std	Z+1, r24	; 0x01
    3bde:	e9 81       	ldd	r30, Y+1	; 0x01
    3be0:	fa 81       	ldd	r31, Y+2	; 0x02
    3be2:	21 81       	ldd	r18, Z+1	; 0x01
    3be4:	32 81       	ldd	r19, Z+2	; 0x02
    3be6:	89 81       	ldd	r24, Y+1	; 0x01
    3be8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bea:	03 96       	adiw	r24, 0x03	; 3
    3bec:	28 17       	cp	r18, r24
    3bee:	39 07       	cpc	r19, r25
    3bf0:	59 f4       	brne	.+22     	; 0x3c08 <vTaskSwitchContext+0xb2>
    3bf2:	e9 81       	ldd	r30, Y+1	; 0x01
    3bf4:	fa 81       	ldd	r31, Y+2	; 0x02
    3bf6:	01 80       	ldd	r0, Z+1	; 0x01
    3bf8:	f2 81       	ldd	r31, Z+2	; 0x02
    3bfa:	e0 2d       	mov	r30, r0
    3bfc:	82 81       	ldd	r24, Z+2	; 0x02
    3bfe:	93 81       	ldd	r25, Z+3	; 0x03
    3c00:	e9 81       	ldd	r30, Y+1	; 0x01
    3c02:	fa 81       	ldd	r31, Y+2	; 0x02
    3c04:	92 83       	std	Z+2, r25	; 0x02
    3c06:	81 83       	std	Z+1, r24	; 0x01
    3c08:	e9 81       	ldd	r30, Y+1	; 0x01
    3c0a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c0c:	01 80       	ldd	r0, Z+1	; 0x01
    3c0e:	f2 81       	ldd	r31, Z+2	; 0x02
    3c10:	e0 2d       	mov	r30, r0
    3c12:	86 81       	ldd	r24, Z+6	; 0x06
    3c14:	97 81       	ldd	r25, Z+7	; 0x07
    3c16:	90 93 bc 0b 	sts	0x0BBC, r25
    3c1a:	80 93 bb 0b 	sts	0x0BBB, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3c1e:	0f 90       	pop	r0
    3c20:	0f 90       	pop	r0
    3c22:	cf 91       	pop	r28
    3c24:	df 91       	pop	r29
    3c26:	08 95       	ret

00003c28 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3c28:	df 93       	push	r29
    3c2a:	cf 93       	push	r28
    3c2c:	00 d0       	rcall	.+0      	; 0x3c2e <vTaskPlaceOnEventList+0x6>
    3c2e:	00 d0       	rcall	.+0      	; 0x3c30 <vTaskPlaceOnEventList+0x8>
    3c30:	00 d0       	rcall	.+0      	; 0x3c32 <vTaskPlaceOnEventList+0xa>
    3c32:	cd b7       	in	r28, 0x3d	; 61
    3c34:	de b7       	in	r29, 0x3e	; 62
    3c36:	9c 83       	std	Y+4, r25	; 0x04
    3c38:	8b 83       	std	Y+3, r24	; 0x03
    3c3a:	7e 83       	std	Y+6, r23	; 0x06
    3c3c:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3c3e:	80 91 bb 0b 	lds	r24, 0x0BBB
    3c42:	90 91 bc 0b 	lds	r25, 0x0BBC
    3c46:	9c 01       	movw	r18, r24
    3c48:	24 5f       	subi	r18, 0xF4	; 244
    3c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    3c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c50:	b9 01       	movw	r22, r18
    3c52:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3c56:	80 91 bb 0b 	lds	r24, 0x0BBB
    3c5a:	90 91 bc 0b 	lds	r25, 0x0BBC
    3c5e:	02 96       	adiw	r24, 0x02	; 2
    3c60:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3c64:	20 91 bf 0b 	lds	r18, 0x0BBF
    3c68:	30 91 c0 0b 	lds	r19, 0x0BC0
    3c6c:	8d 81       	ldd	r24, Y+5	; 0x05
    3c6e:	9e 81       	ldd	r25, Y+6	; 0x06
    3c70:	82 0f       	add	r24, r18
    3c72:	93 1f       	adc	r25, r19
    3c74:	9a 83       	std	Y+2, r25	; 0x02
    3c76:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3c78:	89 81       	ldd	r24, Y+1	; 0x01
    3c7a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c7c:	0e 94 e8 20 	call	0x41d0	; 0x41d0 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3c80:	26 96       	adiw	r28, 0x06	; 6
    3c82:	0f b6       	in	r0, 0x3f	; 63
    3c84:	f8 94       	cli
    3c86:	de bf       	out	0x3e, r29	; 62
    3c88:	0f be       	out	0x3f, r0	; 63
    3c8a:	cd bf       	out	0x3d, r28	; 61
    3c8c:	cf 91       	pop	r28
    3c8e:	df 91       	pop	r29
    3c90:	08 95       	ret

00003c92 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3c92:	df 93       	push	r29
    3c94:	cf 93       	push	r28
    3c96:	cd b7       	in	r28, 0x3d	; 61
    3c98:	de b7       	in	r29, 0x3e	; 62
    3c9a:	28 97       	sbiw	r28, 0x08	; 8
    3c9c:	0f b6       	in	r0, 0x3f	; 63
    3c9e:	f8 94       	cli
    3ca0:	de bf       	out	0x3e, r29	; 62
    3ca2:	0f be       	out	0x3f, r0	; 63
    3ca4:	cd bf       	out	0x3d, r28	; 61
    3ca6:	9c 83       	std	Y+4, r25	; 0x04
    3ca8:	8b 83       	std	Y+3, r24	; 0x03
    3caa:	7e 83       	std	Y+6, r23	; 0x06
    3cac:	6d 83       	std	Y+5, r22	; 0x05
    3cae:	58 87       	std	Y+8, r21	; 0x08
    3cb0:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3cb2:	e0 91 bb 0b 	lds	r30, 0x0BBB
    3cb6:	f0 91 bc 0b 	lds	r31, 0x0BBC
    3cba:	8d 81       	ldd	r24, Y+5	; 0x05
    3cbc:	9e 81       	ldd	r25, Y+6	; 0x06
    3cbe:	90 68       	ori	r25, 0x80	; 128
    3cc0:	95 87       	std	Z+13, r25	; 0x0d
    3cc2:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3cc4:	80 91 bb 0b 	lds	r24, 0x0BBB
    3cc8:	90 91 bc 0b 	lds	r25, 0x0BBC
    3ccc:	9c 01       	movw	r18, r24
    3cce:	24 5f       	subi	r18, 0xF4	; 244
    3cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd6:	b9 01       	movw	r22, r18
    3cd8:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3cdc:	80 91 bb 0b 	lds	r24, 0x0BBB
    3ce0:	90 91 bc 0b 	lds	r25, 0x0BBC
    3ce4:	02 96       	adiw	r24, 0x02	; 2
    3ce6:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    3cea:	20 91 bf 0b 	lds	r18, 0x0BBF
    3cee:	30 91 c0 0b 	lds	r19, 0x0BC0
    3cf2:	8f 81       	ldd	r24, Y+7	; 0x07
    3cf4:	98 85       	ldd	r25, Y+8	; 0x08
    3cf6:	82 0f       	add	r24, r18
    3cf8:	93 1f       	adc	r25, r19
    3cfa:	9a 83       	std	Y+2, r25	; 0x02
    3cfc:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3cfe:	89 81       	ldd	r24, Y+1	; 0x01
    3d00:	9a 81       	ldd	r25, Y+2	; 0x02
    3d02:	0e 94 e8 20 	call	0x41d0	; 0x41d0 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3d06:	28 96       	adiw	r28, 0x08	; 8
    3d08:	0f b6       	in	r0, 0x3f	; 63
    3d0a:	f8 94       	cli
    3d0c:	de bf       	out	0x3e, r29	; 62
    3d0e:	0f be       	out	0x3f, r0	; 63
    3d10:	cd bf       	out	0x3d, r28	; 61
    3d12:	cf 91       	pop	r28
    3d14:	df 91       	pop	r29
    3d16:	08 95       	ret

00003d18 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3d18:	df 93       	push	r29
    3d1a:	cf 93       	push	r28
    3d1c:	00 d0       	rcall	.+0      	; 0x3d1e <xTaskRemoveFromEventList+0x6>
    3d1e:	00 d0       	rcall	.+0      	; 0x3d20 <xTaskRemoveFromEventList+0x8>
    3d20:	0f 92       	push	r0
    3d22:	cd b7       	in	r28, 0x3d	; 61
    3d24:	de b7       	in	r29, 0x3e	; 62
    3d26:	9d 83       	std	Y+5, r25	; 0x05
    3d28:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3d2a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d2c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d2e:	05 80       	ldd	r0, Z+5	; 0x05
    3d30:	f6 81       	ldd	r31, Z+6	; 0x06
    3d32:	e0 2d       	mov	r30, r0
    3d34:	86 81       	ldd	r24, Z+6	; 0x06
    3d36:	97 81       	ldd	r25, Z+7	; 0x07
    3d38:	9b 83       	std	Y+3, r25	; 0x03
    3d3a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3d40:	0c 96       	adiw	r24, 0x0c	; 12
    3d42:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d46:	80 91 c7 0b 	lds	r24, 0x0BC7
    3d4a:	88 23       	and	r24, r24
    3d4c:	61 f5       	brne	.+88     	; 0x3da6 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d50:	9b 81       	ldd	r25, Y+3	; 0x03
    3d52:	02 96       	adiw	r24, 0x02	; 2
    3d54:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3d58:	ea 81       	ldd	r30, Y+2	; 0x02
    3d5a:	fb 81       	ldd	r31, Y+3	; 0x03
    3d5c:	96 89       	ldd	r25, Z+22	; 0x16
    3d5e:	80 91 c1 0b 	lds	r24, 0x0BC1
    3d62:	89 17       	cp	r24, r25
    3d64:	28 f4       	brcc	.+10     	; 0x3d70 <xTaskRemoveFromEventList+0x58>
    3d66:	ea 81       	ldd	r30, Y+2	; 0x02
    3d68:	fb 81       	ldd	r31, Y+3	; 0x03
    3d6a:	86 89       	ldd	r24, Z+22	; 0x16
    3d6c:	80 93 c1 0b 	sts	0x0BC1, r24
    3d70:	ea 81       	ldd	r30, Y+2	; 0x02
    3d72:	fb 81       	ldd	r31, Y+3	; 0x03
    3d74:	86 89       	ldd	r24, Z+22	; 0x16
    3d76:	28 2f       	mov	r18, r24
    3d78:	30 e0       	ldi	r19, 0x00	; 0
    3d7a:	c9 01       	movw	r24, r18
    3d7c:	88 0f       	add	r24, r24
    3d7e:	99 1f       	adc	r25, r25
    3d80:	88 0f       	add	r24, r24
    3d82:	99 1f       	adc	r25, r25
    3d84:	88 0f       	add	r24, r24
    3d86:	99 1f       	adc	r25, r25
    3d88:	82 0f       	add	r24, r18
    3d8a:	93 1f       	adc	r25, r19
    3d8c:	ac 01       	movw	r20, r24
    3d8e:	48 53       	subi	r20, 0x38	; 56
    3d90:	54 4f       	sbci	r21, 0xF4	; 244
    3d92:	8a 81       	ldd	r24, Y+2	; 0x02
    3d94:	9b 81       	ldd	r25, Y+3	; 0x03
    3d96:	9c 01       	movw	r18, r24
    3d98:	2e 5f       	subi	r18, 0xFE	; 254
    3d9a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d9c:	ca 01       	movw	r24, r20
    3d9e:	b9 01       	movw	r22, r18
    3da0:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>
    3da4:	0a c0       	rjmp	.+20     	; 0x3dba <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3da6:	8a 81       	ldd	r24, Y+2	; 0x02
    3da8:	9b 81       	ldd	r25, Y+3	; 0x03
    3daa:	9c 01       	movw	r18, r24
    3dac:	24 5f       	subi	r18, 0xF4	; 244
    3dae:	3f 4f       	sbci	r19, 0xFF	; 255
    3db0:	84 e1       	ldi	r24, 0x14	; 20
    3db2:	9c e0       	ldi	r25, 0x0C	; 12
    3db4:	b9 01       	movw	r22, r18
    3db6:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3dba:	ea 81       	ldd	r30, Y+2	; 0x02
    3dbc:	fb 81       	ldd	r31, Y+3	; 0x03
    3dbe:	96 89       	ldd	r25, Z+22	; 0x16
    3dc0:	e0 91 bb 0b 	lds	r30, 0x0BBB
    3dc4:	f0 91 bc 0b 	lds	r31, 0x0BBC
    3dc8:	86 89       	ldd	r24, Z+22	; 0x16
    3dca:	89 17       	cp	r24, r25
    3dcc:	30 f4       	brcc	.+12     	; 0x3dda <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3dce:	81 e0       	ldi	r24, 0x01	; 1
    3dd0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3dd2:	81 e0       	ldi	r24, 0x01	; 1
    3dd4:	80 93 c4 0b 	sts	0x0BC4, r24
    3dd8:	01 c0       	rjmp	.+2      	; 0x3ddc <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3dda:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3ddc:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dde:	0f 90       	pop	r0
    3de0:	0f 90       	pop	r0
    3de2:	0f 90       	pop	r0
    3de4:	0f 90       	pop	r0
    3de6:	0f 90       	pop	r0
    3de8:	cf 91       	pop	r28
    3dea:	df 91       	pop	r29
    3dec:	08 95       	ret

00003dee <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3dee:	df 93       	push	r29
    3df0:	cf 93       	push	r28
    3df2:	cd b7       	in	r28, 0x3d	; 61
    3df4:	de b7       	in	r29, 0x3e	; 62
    3df6:	27 97       	sbiw	r28, 0x07	; 7
    3df8:	0f b6       	in	r0, 0x3f	; 63
    3dfa:	f8 94       	cli
    3dfc:	de bf       	out	0x3e, r29	; 62
    3dfe:	0f be       	out	0x3f, r0	; 63
    3e00:	cd bf       	out	0x3d, r28	; 61
    3e02:	9d 83       	std	Y+5, r25	; 0x05
    3e04:	8c 83       	std	Y+4, r24	; 0x04
    3e06:	7f 83       	std	Y+7, r23	; 0x07
    3e08:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3e0a:	8e 81       	ldd	r24, Y+6	; 0x06
    3e0c:	9f 81       	ldd	r25, Y+7	; 0x07
    3e0e:	90 68       	ori	r25, 0x80	; 128
    3e10:	ec 81       	ldd	r30, Y+4	; 0x04
    3e12:	fd 81       	ldd	r31, Y+5	; 0x05
    3e14:	91 83       	std	Z+1, r25	; 0x01
    3e16:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    3e18:	ec 81       	ldd	r30, Y+4	; 0x04
    3e1a:	fd 81       	ldd	r31, Y+5	; 0x05
    3e1c:	86 81       	ldd	r24, Z+6	; 0x06
    3e1e:	97 81       	ldd	r25, Z+7	; 0x07
    3e20:	9b 83       	std	Y+3, r25	; 0x03
    3e22:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3e24:	8c 81       	ldd	r24, Y+4	; 0x04
    3e26:	9d 81       	ldd	r25, Y+5	; 0x05
    3e28:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3e2c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e2e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e30:	02 96       	adiw	r24, 0x02	; 2
    3e32:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3e36:	ea 81       	ldd	r30, Y+2	; 0x02
    3e38:	fb 81       	ldd	r31, Y+3	; 0x03
    3e3a:	96 89       	ldd	r25, Z+22	; 0x16
    3e3c:	80 91 c1 0b 	lds	r24, 0x0BC1
    3e40:	89 17       	cp	r24, r25
    3e42:	28 f4       	brcc	.+10     	; 0x3e4e <xTaskRemoveFromUnorderedEventList+0x60>
    3e44:	ea 81       	ldd	r30, Y+2	; 0x02
    3e46:	fb 81       	ldd	r31, Y+3	; 0x03
    3e48:	86 89       	ldd	r24, Z+22	; 0x16
    3e4a:	80 93 c1 0b 	sts	0x0BC1, r24
    3e4e:	ea 81       	ldd	r30, Y+2	; 0x02
    3e50:	fb 81       	ldd	r31, Y+3	; 0x03
    3e52:	86 89       	ldd	r24, Z+22	; 0x16
    3e54:	28 2f       	mov	r18, r24
    3e56:	30 e0       	ldi	r19, 0x00	; 0
    3e58:	c9 01       	movw	r24, r18
    3e5a:	88 0f       	add	r24, r24
    3e5c:	99 1f       	adc	r25, r25
    3e5e:	88 0f       	add	r24, r24
    3e60:	99 1f       	adc	r25, r25
    3e62:	88 0f       	add	r24, r24
    3e64:	99 1f       	adc	r25, r25
    3e66:	82 0f       	add	r24, r18
    3e68:	93 1f       	adc	r25, r19
    3e6a:	ac 01       	movw	r20, r24
    3e6c:	48 53       	subi	r20, 0x38	; 56
    3e6e:	54 4f       	sbci	r21, 0xF4	; 244
    3e70:	8a 81       	ldd	r24, Y+2	; 0x02
    3e72:	9b 81       	ldd	r25, Y+3	; 0x03
    3e74:	9c 01       	movw	r18, r24
    3e76:	2e 5f       	subi	r18, 0xFE	; 254
    3e78:	3f 4f       	sbci	r19, 0xFF	; 255
    3e7a:	ca 01       	movw	r24, r20
    3e7c:	b9 01       	movw	r22, r18
    3e7e:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3e82:	ea 81       	ldd	r30, Y+2	; 0x02
    3e84:	fb 81       	ldd	r31, Y+3	; 0x03
    3e86:	96 89       	ldd	r25, Z+22	; 0x16
    3e88:	e0 91 bb 0b 	lds	r30, 0x0BBB
    3e8c:	f0 91 bc 0b 	lds	r31, 0x0BBC
    3e90:	86 89       	ldd	r24, Z+22	; 0x16
    3e92:	89 17       	cp	r24, r25
    3e94:	30 f4       	brcc	.+12     	; 0x3ea2 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3e96:	81 e0       	ldi	r24, 0x01	; 1
    3e98:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3e9a:	81 e0       	ldi	r24, 0x01	; 1
    3e9c:	80 93 c4 0b 	sts	0x0BC4, r24
    3ea0:	01 c0       	rjmp	.+2      	; 0x3ea4 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    3ea2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3ea4:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ea6:	27 96       	adiw	r28, 0x07	; 7
    3ea8:	0f b6       	in	r0, 0x3f	; 63
    3eaa:	f8 94       	cli
    3eac:	de bf       	out	0x3e, r29	; 62
    3eae:	0f be       	out	0x3f, r0	; 63
    3eb0:	cd bf       	out	0x3d, r28	; 61
    3eb2:	cf 91       	pop	r28
    3eb4:	df 91       	pop	r29
    3eb6:	08 95       	ret

00003eb8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3eb8:	df 93       	push	r29
    3eba:	cf 93       	push	r28
    3ebc:	00 d0       	rcall	.+0      	; 0x3ebe <vTaskSetTimeOutState+0x6>
    3ebe:	cd b7       	in	r28, 0x3d	; 61
    3ec0:	de b7       	in	r29, 0x3e	; 62
    3ec2:	9a 83       	std	Y+2, r25	; 0x02
    3ec4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3ec6:	80 91 c5 0b 	lds	r24, 0x0BC5
    3eca:	e9 81       	ldd	r30, Y+1	; 0x01
    3ecc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ece:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3ed0:	80 91 bf 0b 	lds	r24, 0x0BBF
    3ed4:	90 91 c0 0b 	lds	r25, 0x0BC0
    3ed8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eda:	fa 81       	ldd	r31, Y+2	; 0x02
    3edc:	92 83       	std	Z+2, r25	; 0x02
    3ede:	81 83       	std	Z+1, r24	; 0x01
}
    3ee0:	0f 90       	pop	r0
    3ee2:	0f 90       	pop	r0
    3ee4:	cf 91       	pop	r28
    3ee6:	df 91       	pop	r29
    3ee8:	08 95       	ret

00003eea <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3eea:	df 93       	push	r29
    3eec:	cf 93       	push	r28
    3eee:	cd b7       	in	r28, 0x3d	; 61
    3ef0:	de b7       	in	r29, 0x3e	; 62
    3ef2:	27 97       	sbiw	r28, 0x07	; 7
    3ef4:	0f b6       	in	r0, 0x3f	; 63
    3ef6:	f8 94       	cli
    3ef8:	de bf       	out	0x3e, r29	; 62
    3efa:	0f be       	out	0x3f, r0	; 63
    3efc:	cd bf       	out	0x3d, r28	; 61
    3efe:	9d 83       	std	Y+5, r25	; 0x05
    3f00:	8c 83       	std	Y+4, r24	; 0x04
    3f02:	7f 83       	std	Y+7, r23	; 0x07
    3f04:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3f06:	0f b6       	in	r0, 0x3f	; 63
    3f08:	f8 94       	cli
    3f0a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3f0c:	80 91 bf 0b 	lds	r24, 0x0BBF
    3f10:	90 91 c0 0b 	lds	r25, 0x0BC0
    3f14:	9a 83       	std	Y+2, r25	; 0x02
    3f16:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3f18:	ec 81       	ldd	r30, Y+4	; 0x04
    3f1a:	fd 81       	ldd	r31, Y+5	; 0x05
    3f1c:	90 81       	ld	r25, Z
    3f1e:	80 91 c5 0b 	lds	r24, 0x0BC5
    3f22:	98 17       	cp	r25, r24
    3f24:	61 f0       	breq	.+24     	; 0x3f3e <xTaskCheckForTimeOut+0x54>
    3f26:	ec 81       	ldd	r30, Y+4	; 0x04
    3f28:	fd 81       	ldd	r31, Y+5	; 0x05
    3f2a:	21 81       	ldd	r18, Z+1	; 0x01
    3f2c:	32 81       	ldd	r19, Z+2	; 0x02
    3f2e:	89 81       	ldd	r24, Y+1	; 0x01
    3f30:	9a 81       	ldd	r25, Y+2	; 0x02
    3f32:	82 17       	cp	r24, r18
    3f34:	93 07       	cpc	r25, r19
    3f36:	18 f0       	brcs	.+6      	; 0x3f3e <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3f38:	81 e0       	ldi	r24, 0x01	; 1
    3f3a:	8b 83       	std	Y+3, r24	; 0x03
    3f3c:	2d c0       	rjmp	.+90     	; 0x3f98 <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3f3e:	ec 81       	ldd	r30, Y+4	; 0x04
    3f40:	fd 81       	ldd	r31, Y+5	; 0x05
    3f42:	21 81       	ldd	r18, Z+1	; 0x01
    3f44:	32 81       	ldd	r19, Z+2	; 0x02
    3f46:	89 81       	ldd	r24, Y+1	; 0x01
    3f48:	9a 81       	ldd	r25, Y+2	; 0x02
    3f4a:	ac 01       	movw	r20, r24
    3f4c:	42 1b       	sub	r20, r18
    3f4e:	53 0b       	sbc	r21, r19
    3f50:	9a 01       	movw	r18, r20
    3f52:	ee 81       	ldd	r30, Y+6	; 0x06
    3f54:	ff 81       	ldd	r31, Y+7	; 0x07
    3f56:	80 81       	ld	r24, Z
    3f58:	91 81       	ldd	r25, Z+1	; 0x01
    3f5a:	28 17       	cp	r18, r24
    3f5c:	39 07       	cpc	r19, r25
    3f5e:	d0 f4       	brcc	.+52     	; 0x3f94 <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    3f60:	ee 81       	ldd	r30, Y+6	; 0x06
    3f62:	ff 81       	ldd	r31, Y+7	; 0x07
    3f64:	40 81       	ld	r20, Z
    3f66:	51 81       	ldd	r21, Z+1	; 0x01
    3f68:	ec 81       	ldd	r30, Y+4	; 0x04
    3f6a:	fd 81       	ldd	r31, Y+5	; 0x05
    3f6c:	21 81       	ldd	r18, Z+1	; 0x01
    3f6e:	32 81       	ldd	r19, Z+2	; 0x02
    3f70:	89 81       	ldd	r24, Y+1	; 0x01
    3f72:	9a 81       	ldd	r25, Y+2	; 0x02
    3f74:	b9 01       	movw	r22, r18
    3f76:	68 1b       	sub	r22, r24
    3f78:	79 0b       	sbc	r23, r25
    3f7a:	cb 01       	movw	r24, r22
    3f7c:	84 0f       	add	r24, r20
    3f7e:	95 1f       	adc	r25, r21
    3f80:	ee 81       	ldd	r30, Y+6	; 0x06
    3f82:	ff 81       	ldd	r31, Y+7	; 0x07
    3f84:	91 83       	std	Z+1, r25	; 0x01
    3f86:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3f88:	8c 81       	ldd	r24, Y+4	; 0x04
    3f8a:	9d 81       	ldd	r25, Y+5	; 0x05
    3f8c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3f90:	1b 82       	std	Y+3, r1	; 0x03
    3f92:	02 c0       	rjmp	.+4      	; 0x3f98 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    3f94:	81 e0       	ldi	r24, 0x01	; 1
    3f96:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    3f98:	0f 90       	pop	r0
    3f9a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f9c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3f9e:	27 96       	adiw	r28, 0x07	; 7
    3fa0:	0f b6       	in	r0, 0x3f	; 63
    3fa2:	f8 94       	cli
    3fa4:	de bf       	out	0x3e, r29	; 62
    3fa6:	0f be       	out	0x3f, r0	; 63
    3fa8:	cd bf       	out	0x3d, r28	; 61
    3faa:	cf 91       	pop	r28
    3fac:	df 91       	pop	r29
    3fae:	08 95       	ret

00003fb0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3fb0:	df 93       	push	r29
    3fb2:	cf 93       	push	r28
    3fb4:	cd b7       	in	r28, 0x3d	; 61
    3fb6:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3fb8:	81 e0       	ldi	r24, 0x01	; 1
    3fba:	80 93 c4 0b 	sts	0x0BC4, r24
}
    3fbe:	cf 91       	pop	r28
    3fc0:	df 91       	pop	r29
    3fc2:	08 95       	ret

00003fc4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3fc4:	df 93       	push	r29
    3fc6:	cf 93       	push	r28
    3fc8:	00 d0       	rcall	.+0      	; 0x3fca <prvIdleTask+0x6>
    3fca:	cd b7       	in	r28, 0x3d	; 61
    3fcc:	de b7       	in	r29, 0x3e	; 62
    3fce:	9a 83       	std	Y+2, r25	; 0x02
    3fd0:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    3fd2:	0e 94 a9 20 	call	0x4152	; 0x4152 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    3fd6:	80 91 c8 0b 	lds	r24, 0x0BC8
    3fda:	82 30       	cpi	r24, 0x02	; 2
    3fdc:	d0 f3       	brcs	.-12     	; 0x3fd2 <prvIdleTask+0xe>
			{
				taskYIELD();
    3fde:	0e 94 06 11 	call	0x220c	; 0x220c <vPortYield>
    3fe2:	f7 cf       	rjmp	.-18     	; 0x3fd2 <prvIdleTask+0xe>

00003fe4 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3fe4:	0f 93       	push	r16
    3fe6:	1f 93       	push	r17
    3fe8:	df 93       	push	r29
    3fea:	cf 93       	push	r28
    3fec:	cd b7       	in	r28, 0x3d	; 61
    3fee:	de b7       	in	r29, 0x3e	; 62
    3ff0:	2a 97       	sbiw	r28, 0x0a	; 10
    3ff2:	0f b6       	in	r0, 0x3f	; 63
    3ff4:	f8 94       	cli
    3ff6:	de bf       	out	0x3e, r29	; 62
    3ff8:	0f be       	out	0x3f, r0	; 63
    3ffa:	cd bf       	out	0x3d, r28	; 61
    3ffc:	9b 83       	std	Y+3, r25	; 0x03
    3ffe:	8a 83       	std	Y+2, r24	; 0x02
    4000:	7d 83       	std	Y+5, r23	; 0x05
    4002:	6c 83       	std	Y+4, r22	; 0x04
    4004:	4e 83       	std	Y+6, r20	; 0x06
    4006:	38 87       	std	Y+8, r19	; 0x08
    4008:	2f 83       	std	Y+7, r18	; 0x07
    400a:	1a 87       	std	Y+10, r17	; 0x0a
    400c:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    400e:	19 82       	std	Y+1, r1	; 0x01
    4010:	21 c0       	rjmp	.+66     	; 0x4054 <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    4012:	89 81       	ldd	r24, Y+1	; 0x01
    4014:	48 2f       	mov	r20, r24
    4016:	50 e0       	ldi	r21, 0x00	; 0
    4018:	89 81       	ldd	r24, Y+1	; 0x01
    401a:	28 2f       	mov	r18, r24
    401c:	30 e0       	ldi	r19, 0x00	; 0
    401e:	8c 81       	ldd	r24, Y+4	; 0x04
    4020:	9d 81       	ldd	r25, Y+5	; 0x05
    4022:	fc 01       	movw	r30, r24
    4024:	e2 0f       	add	r30, r18
    4026:	f3 1f       	adc	r31, r19
    4028:	20 81       	ld	r18, Z
    402a:	8a 81       	ldd	r24, Y+2	; 0x02
    402c:	9b 81       	ldd	r25, Y+3	; 0x03
    402e:	84 0f       	add	r24, r20
    4030:	95 1f       	adc	r25, r21
    4032:	fc 01       	movw	r30, r24
    4034:	79 96       	adiw	r30, 0x19	; 25
    4036:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    4038:	89 81       	ldd	r24, Y+1	; 0x01
    403a:	28 2f       	mov	r18, r24
    403c:	30 e0       	ldi	r19, 0x00	; 0
    403e:	8c 81       	ldd	r24, Y+4	; 0x04
    4040:	9d 81       	ldd	r25, Y+5	; 0x05
    4042:	fc 01       	movw	r30, r24
    4044:	e2 0f       	add	r30, r18
    4046:	f3 1f       	adc	r31, r19
    4048:	80 81       	ld	r24, Z
    404a:	88 23       	and	r24, r24
    404c:	31 f0       	breq	.+12     	; 0x405a <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    404e:	89 81       	ldd	r24, Y+1	; 0x01
    4050:	8f 5f       	subi	r24, 0xFF	; 255
    4052:	89 83       	std	Y+1, r24	; 0x01
    4054:	89 81       	ldd	r24, Y+1	; 0x01
    4056:	84 31       	cpi	r24, 0x14	; 20
    4058:	e0 f2       	brcs	.-72     	; 0x4012 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    405a:	ea 81       	ldd	r30, Y+2	; 0x02
    405c:	fb 81       	ldd	r31, Y+3	; 0x03
    405e:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4060:	8e 81       	ldd	r24, Y+6	; 0x06
    4062:	86 30       	cpi	r24, 0x06	; 6
    4064:	10 f0       	brcs	.+4      	; 0x406a <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4066:	85 e0       	ldi	r24, 0x05	; 5
    4068:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    406a:	ea 81       	ldd	r30, Y+2	; 0x02
    406c:	fb 81       	ldd	r31, Y+3	; 0x03
    406e:	8e 81       	ldd	r24, Y+6	; 0x06
    4070:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    4072:	ea 81       	ldd	r30, Y+2	; 0x02
    4074:	fb 81       	ldd	r31, Y+3	; 0x03
    4076:	8e 81       	ldd	r24, Y+6	; 0x06
    4078:	85 a7       	std	Z+45, r24	; 0x2d
		pxTCB->uxMutexesHeld = 0;
    407a:	ea 81       	ldd	r30, Y+2	; 0x02
    407c:	fb 81       	ldd	r31, Y+3	; 0x03
    407e:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4080:	8a 81       	ldd	r24, Y+2	; 0x02
    4082:	9b 81       	ldd	r25, Y+3	; 0x03
    4084:	02 96       	adiw	r24, 0x02	; 2
    4086:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    408a:	8a 81       	ldd	r24, Y+2	; 0x02
    408c:	9b 81       	ldd	r25, Y+3	; 0x03
    408e:	0c 96       	adiw	r24, 0x0c	; 12
    4090:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4094:	ea 81       	ldd	r30, Y+2	; 0x02
    4096:	fb 81       	ldd	r31, Y+3	; 0x03
    4098:	8a 81       	ldd	r24, Y+2	; 0x02
    409a:	9b 81       	ldd	r25, Y+3	; 0x03
    409c:	91 87       	std	Z+9, r25	; 0x09
    409e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    40a0:	8e 81       	ldd	r24, Y+6	; 0x06
    40a2:	28 2f       	mov	r18, r24
    40a4:	30 e0       	ldi	r19, 0x00	; 0
    40a6:	86 e0       	ldi	r24, 0x06	; 6
    40a8:	90 e0       	ldi	r25, 0x00	; 0
    40aa:	82 1b       	sub	r24, r18
    40ac:	93 0b       	sbc	r25, r19
    40ae:	ea 81       	ldd	r30, Y+2	; 0x02
    40b0:	fb 81       	ldd	r31, Y+3	; 0x03
    40b2:	95 87       	std	Z+13, r25	; 0x0d
    40b4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    40b6:	ea 81       	ldd	r30, Y+2	; 0x02
    40b8:	fb 81       	ldd	r31, Y+3	; 0x03
    40ba:	8a 81       	ldd	r24, Y+2	; 0x02
    40bc:	9b 81       	ldd	r25, Y+3	; 0x03
    40be:	93 8b       	std	Z+19, r25	; 0x13
    40c0:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    40c2:	2a 96       	adiw	r28, 0x0a	; 10
    40c4:	0f b6       	in	r0, 0x3f	; 63
    40c6:	f8 94       	cli
    40c8:	de bf       	out	0x3e, r29	; 62
    40ca:	0f be       	out	0x3f, r0	; 63
    40cc:	cd bf       	out	0x3d, r28	; 61
    40ce:	cf 91       	pop	r28
    40d0:	df 91       	pop	r29
    40d2:	1f 91       	pop	r17
    40d4:	0f 91       	pop	r16
    40d6:	08 95       	ret

000040d8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    40d8:	df 93       	push	r29
    40da:	cf 93       	push	r28
    40dc:	0f 92       	push	r0
    40de:	cd b7       	in	r28, 0x3d	; 61
    40e0:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    40e2:	19 82       	std	Y+1, r1	; 0x01
    40e4:	13 c0       	rjmp	.+38     	; 0x410c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    40e6:	89 81       	ldd	r24, Y+1	; 0x01
    40e8:	28 2f       	mov	r18, r24
    40ea:	30 e0       	ldi	r19, 0x00	; 0
    40ec:	c9 01       	movw	r24, r18
    40ee:	88 0f       	add	r24, r24
    40f0:	99 1f       	adc	r25, r25
    40f2:	88 0f       	add	r24, r24
    40f4:	99 1f       	adc	r25, r25
    40f6:	88 0f       	add	r24, r24
    40f8:	99 1f       	adc	r25, r25
    40fa:	82 0f       	add	r24, r18
    40fc:	93 1f       	adc	r25, r19
    40fe:	88 53       	subi	r24, 0x38	; 56
    4100:	94 4f       	sbci	r25, 0xF4	; 244
    4102:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4106:	89 81       	ldd	r24, Y+1	; 0x01
    4108:	8f 5f       	subi	r24, 0xFF	; 255
    410a:	89 83       	std	Y+1, r24	; 0x01
    410c:	89 81       	ldd	r24, Y+1	; 0x01
    410e:	86 30       	cpi	r24, 0x06	; 6
    4110:	50 f3       	brcs	.-44     	; 0x40e6 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4112:	8e ef       	ldi	r24, 0xFE	; 254
    4114:	9b e0       	ldi	r25, 0x0B	; 11
    4116:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    411a:	87 e0       	ldi	r24, 0x07	; 7
    411c:	9c e0       	ldi	r25, 0x0C	; 12
    411e:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4122:	84 e1       	ldi	r24, 0x14	; 20
    4124:	9c e0       	ldi	r25, 0x0C	; 12
    4126:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    412a:	8d e1       	ldi	r24, 0x1D	; 29
    412c:	9c e0       	ldi	r25, 0x0C	; 12
    412e:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4132:	8e ef       	ldi	r24, 0xFE	; 254
    4134:	9b e0       	ldi	r25, 0x0B	; 11
    4136:	90 93 11 0c 	sts	0x0C11, r25
    413a:	80 93 10 0c 	sts	0x0C10, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    413e:	87 e0       	ldi	r24, 0x07	; 7
    4140:	9c e0       	ldi	r25, 0x0C	; 12
    4142:	90 93 13 0c 	sts	0x0C13, r25
    4146:	80 93 12 0c 	sts	0x0C12, r24
}
    414a:	0f 90       	pop	r0
    414c:	cf 91       	pop	r28
    414e:	df 91       	pop	r29
    4150:	08 95       	ret

00004152 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4152:	df 93       	push	r29
    4154:	cf 93       	push	r28
    4156:	00 d0       	rcall	.+0      	; 0x4158 <prvCheckTasksWaitingTermination+0x6>
    4158:	0f 92       	push	r0
    415a:	cd b7       	in	r28, 0x3d	; 61
    415c:	de b7       	in	r29, 0x3e	; 62
    415e:	2e c0       	rjmp	.+92     	; 0x41bc <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    4160:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4164:	80 91 1d 0c 	lds	r24, 0x0C1D
    4168:	1b 82       	std	Y+3, r1	; 0x03
    416a:	88 23       	and	r24, r24
    416c:	11 f4       	brne	.+4      	; 0x4172 <prvCheckTasksWaitingTermination+0x20>
    416e:	81 e0       	ldi	r24, 0x01	; 1
    4170:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    4172:	0e 94 05 1c 	call	0x380a	; 0x380a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4176:	8b 81       	ldd	r24, Y+3	; 0x03
    4178:	88 23       	and	r24, r24
    417a:	01 f5       	brne	.+64     	; 0x41bc <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    417c:	0f b6       	in	r0, 0x3f	; 63
    417e:	f8 94       	cli
    4180:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    4182:	e0 91 22 0c 	lds	r30, 0x0C22
    4186:	f0 91 23 0c 	lds	r31, 0x0C23
    418a:	86 81       	ldd	r24, Z+6	; 0x06
    418c:	97 81       	ldd	r25, Z+7	; 0x07
    418e:	9a 83       	std	Y+2, r25	; 0x02
    4190:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4192:	89 81       	ldd	r24, Y+1	; 0x01
    4194:	9a 81       	ldd	r25, Y+2	; 0x02
    4196:	02 96       	adiw	r24, 0x02	; 2
    4198:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
					--uxCurrentNumberOfTasks;
    419c:	80 91 be 0b 	lds	r24, 0x0BBE
    41a0:	81 50       	subi	r24, 0x01	; 1
    41a2:	80 93 be 0b 	sts	0x0BBE, r24
					--uxTasksDeleted;
    41a6:	80 91 bd 0b 	lds	r24, 0x0BBD
    41aa:	81 50       	subi	r24, 0x01	; 1
    41ac:	80 93 bd 0b 	sts	0x0BBD, r24
				}
				taskEXIT_CRITICAL();
    41b0:	0f 90       	pop	r0
    41b2:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    41b4:	89 81       	ldd	r24, Y+1	; 0x01
    41b6:	9a 81       	ldd	r25, Y+2	; 0x02
    41b8:	0e 94 75 21 	call	0x42ea	; 0x42ea <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    41bc:	80 91 bd 0b 	lds	r24, 0x0BBD
    41c0:	88 23       	and	r24, r24
    41c2:	71 f6       	brne	.-100    	; 0x4160 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    41c4:	0f 90       	pop	r0
    41c6:	0f 90       	pop	r0
    41c8:	0f 90       	pop	r0
    41ca:	cf 91       	pop	r28
    41cc:	df 91       	pop	r29
    41ce:	08 95       	ret

000041d0 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    41d0:	df 93       	push	r29
    41d2:	cf 93       	push	r28
    41d4:	00 d0       	rcall	.+0      	; 0x41d6 <prvAddCurrentTaskToDelayedList+0x6>
    41d6:	cd b7       	in	r28, 0x3d	; 61
    41d8:	de b7       	in	r29, 0x3e	; 62
    41da:	9a 83       	std	Y+2, r25	; 0x02
    41dc:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    41de:	e0 91 bb 0b 	lds	r30, 0x0BBB
    41e2:	f0 91 bc 0b 	lds	r31, 0x0BBC
    41e6:	89 81       	ldd	r24, Y+1	; 0x01
    41e8:	9a 81       	ldd	r25, Y+2	; 0x02
    41ea:	93 83       	std	Z+3, r25	; 0x03
    41ec:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    41ee:	20 91 bf 0b 	lds	r18, 0x0BBF
    41f2:	30 91 c0 0b 	lds	r19, 0x0BC0
    41f6:	89 81       	ldd	r24, Y+1	; 0x01
    41f8:	9a 81       	ldd	r25, Y+2	; 0x02
    41fa:	82 17       	cp	r24, r18
    41fc:	93 07       	cpc	r25, r19
    41fe:	70 f4       	brcc	.+28     	; 0x421c <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4200:	80 91 12 0c 	lds	r24, 0x0C12
    4204:	90 91 13 0c 	lds	r25, 0x0C13
    4208:	20 91 bb 0b 	lds	r18, 0x0BBB
    420c:	30 91 bc 0b 	lds	r19, 0x0BBC
    4210:	2e 5f       	subi	r18, 0xFE	; 254
    4212:	3f 4f       	sbci	r19, 0xFF	; 255
    4214:	b9 01       	movw	r22, r18
    4216:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <vListInsert>
    421a:	1e c0       	rjmp	.+60     	; 0x4258 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    421c:	40 91 10 0c 	lds	r20, 0x0C10
    4220:	50 91 11 0c 	lds	r21, 0x0C11
    4224:	80 91 bb 0b 	lds	r24, 0x0BBB
    4228:	90 91 bc 0b 	lds	r25, 0x0BBC
    422c:	9c 01       	movw	r18, r24
    422e:	2e 5f       	subi	r18, 0xFE	; 254
    4230:	3f 4f       	sbci	r19, 0xFF	; 255
    4232:	ca 01       	movw	r24, r20
    4234:	b9 01       	movw	r22, r18
    4236:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    423a:	20 91 ab 01 	lds	r18, 0x01AB
    423e:	30 91 ac 01 	lds	r19, 0x01AC
    4242:	89 81       	ldd	r24, Y+1	; 0x01
    4244:	9a 81       	ldd	r25, Y+2	; 0x02
    4246:	82 17       	cp	r24, r18
    4248:	93 07       	cpc	r25, r19
    424a:	30 f4       	brcc	.+12     	; 0x4258 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    424c:	89 81       	ldd	r24, Y+1	; 0x01
    424e:	9a 81       	ldd	r25, Y+2	; 0x02
    4250:	90 93 ac 01 	sts	0x01AC, r25
    4254:	80 93 ab 01 	sts	0x01AB, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    4258:	0f 90       	pop	r0
    425a:	0f 90       	pop	r0
    425c:	cf 91       	pop	r28
    425e:	df 91       	pop	r29
    4260:	08 95       	ret

00004262 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    4262:	df 93       	push	r29
    4264:	cf 93       	push	r28
    4266:	cd b7       	in	r28, 0x3d	; 61
    4268:	de b7       	in	r29, 0x3e	; 62
    426a:	28 97       	sbiw	r28, 0x08	; 8
    426c:	0f b6       	in	r0, 0x3f	; 63
    426e:	f8 94       	cli
    4270:	de bf       	out	0x3e, r29	; 62
    4272:	0f be       	out	0x3f, r0	; 63
    4274:	cd bf       	out	0x3d, r28	; 61
    4276:	9c 83       	std	Y+4, r25	; 0x04
    4278:	8b 83       	std	Y+3, r24	; 0x03
    427a:	7e 83       	std	Y+6, r23	; 0x06
    427c:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    427e:	8f e2       	ldi	r24, 0x2F	; 47
    4280:	90 e0       	ldi	r25, 0x00	; 0
    4282:	0e 94 c3 0c 	call	0x1986	; 0x1986 <pvPortMalloc>
    4286:	9a 83       	std	Y+2, r25	; 0x02
    4288:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    428a:	89 81       	ldd	r24, Y+1	; 0x01
    428c:	9a 81       	ldd	r25, Y+2	; 0x02
    428e:	00 97       	sbiw	r24, 0x00	; 0
    4290:	09 f1       	breq	.+66     	; 0x42d4 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4292:	8d 81       	ldd	r24, Y+5	; 0x05
    4294:	9e 81       	ldd	r25, Y+6	; 0x06
    4296:	00 97       	sbiw	r24, 0x00	; 0
    4298:	39 f4       	brne	.+14     	; 0x42a8 <prvAllocateTCBAndStack+0x46>
    429a:	8b 81       	ldd	r24, Y+3	; 0x03
    429c:	9c 81       	ldd	r25, Y+4	; 0x04
    429e:	0e 94 c3 0c 	call	0x1986	; 0x1986 <pvPortMalloc>
    42a2:	98 87       	std	Y+8, r25	; 0x08
    42a4:	8f 83       	std	Y+7, r24	; 0x07
    42a6:	04 c0       	rjmp	.+8      	; 0x42b0 <prvAllocateTCBAndStack+0x4e>
    42a8:	8d 81       	ldd	r24, Y+5	; 0x05
    42aa:	9e 81       	ldd	r25, Y+6	; 0x06
    42ac:	98 87       	std	Y+8, r25	; 0x08
    42ae:	8f 83       	std	Y+7, r24	; 0x07
    42b0:	e9 81       	ldd	r30, Y+1	; 0x01
    42b2:	fa 81       	ldd	r31, Y+2	; 0x02
    42b4:	8f 81       	ldd	r24, Y+7	; 0x07
    42b6:	98 85       	ldd	r25, Y+8	; 0x08
    42b8:	90 8f       	std	Z+24, r25	; 0x18
    42ba:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    42bc:	e9 81       	ldd	r30, Y+1	; 0x01
    42be:	fa 81       	ldd	r31, Y+2	; 0x02
    42c0:	87 89       	ldd	r24, Z+23	; 0x17
    42c2:	90 8d       	ldd	r25, Z+24	; 0x18
    42c4:	00 97       	sbiw	r24, 0x00	; 0
    42c6:	31 f4       	brne	.+12     	; 0x42d4 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    42c8:	89 81       	ldd	r24, Y+1	; 0x01
    42ca:	9a 81       	ldd	r25, Y+2	; 0x02
    42cc:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vPortFree>
			pxNewTCB = NULL;
    42d0:	1a 82       	std	Y+2, r1	; 0x02
    42d2:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    42d8:	28 96       	adiw	r28, 0x08	; 8
    42da:	0f b6       	in	r0, 0x3f	; 63
    42dc:	f8 94       	cli
    42de:	de bf       	out	0x3e, r29	; 62
    42e0:	0f be       	out	0x3f, r0	; 63
    42e2:	cd bf       	out	0x3d, r28	; 61
    42e4:	cf 91       	pop	r28
    42e6:	df 91       	pop	r29
    42e8:	08 95       	ret

000042ea <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    42ea:	df 93       	push	r29
    42ec:	cf 93       	push	r28
    42ee:	00 d0       	rcall	.+0      	; 0x42f0 <prvDeleteTCB+0x6>
    42f0:	cd b7       	in	r28, 0x3d	; 61
    42f2:	de b7       	in	r29, 0x3e	; 62
    42f4:	9a 83       	std	Y+2, r25	; 0x02
    42f6:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    42f8:	e9 81       	ldd	r30, Y+1	; 0x01
    42fa:	fa 81       	ldd	r31, Y+2	; 0x02
    42fc:	87 89       	ldd	r24, Z+23	; 0x17
    42fe:	90 8d       	ldd	r25, Z+24	; 0x18
    4300:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vPortFree>
		vPortFree( pxTCB );
    4304:	89 81       	ldd	r24, Y+1	; 0x01
    4306:	9a 81       	ldd	r25, Y+2	; 0x02
    4308:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vPortFree>
	}
    430c:	0f 90       	pop	r0
    430e:	0f 90       	pop	r0
    4310:	cf 91       	pop	r28
    4312:	df 91       	pop	r29
    4314:	08 95       	ret

00004316 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4316:	df 93       	push	r29
    4318:	cf 93       	push	r28
    431a:	00 d0       	rcall	.+0      	; 0x431c <prvResetNextTaskUnblockTime+0x6>
    431c:	cd b7       	in	r28, 0x3d	; 61
    431e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4320:	e0 91 10 0c 	lds	r30, 0x0C10
    4324:	f0 91 11 0c 	lds	r31, 0x0C11
    4328:	80 81       	ld	r24, Z
    432a:	88 23       	and	r24, r24
    432c:	39 f4       	brne	.+14     	; 0x433c <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    432e:	8f ef       	ldi	r24, 0xFF	; 255
    4330:	9f ef       	ldi	r25, 0xFF	; 255
    4332:	90 93 ac 01 	sts	0x01AC, r25
    4336:	80 93 ab 01 	sts	0x01AB, r24
    433a:	13 c0       	rjmp	.+38     	; 0x4362 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    433c:	e0 91 10 0c 	lds	r30, 0x0C10
    4340:	f0 91 11 0c 	lds	r31, 0x0C11
    4344:	05 80       	ldd	r0, Z+5	; 0x05
    4346:	f6 81       	ldd	r31, Z+6	; 0x06
    4348:	e0 2d       	mov	r30, r0
    434a:	86 81       	ldd	r24, Z+6	; 0x06
    434c:	97 81       	ldd	r25, Z+7	; 0x07
    434e:	9a 83       	std	Y+2, r25	; 0x02
    4350:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    4352:	e9 81       	ldd	r30, Y+1	; 0x01
    4354:	fa 81       	ldd	r31, Y+2	; 0x02
    4356:	82 81       	ldd	r24, Z+2	; 0x02
    4358:	93 81       	ldd	r25, Z+3	; 0x03
    435a:	90 93 ac 01 	sts	0x01AC, r25
    435e:	80 93 ab 01 	sts	0x01AB, r24
	}
}
    4362:	0f 90       	pop	r0
    4364:	0f 90       	pop	r0
    4366:	cf 91       	pop	r28
    4368:	df 91       	pop	r29
    436a:	08 95       	ret

0000436c <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    436c:	df 93       	push	r29
    436e:	cf 93       	push	r28
    4370:	00 d0       	rcall	.+0      	; 0x4372 <xTaskGetCurrentTaskHandle+0x6>
    4372:	cd b7       	in	r28, 0x3d	; 61
    4374:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4376:	80 91 bb 0b 	lds	r24, 0x0BBB
    437a:	90 91 bc 0b 	lds	r25, 0x0BBC
    437e:	9a 83       	std	Y+2, r25	; 0x02
    4380:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4382:	89 81       	ldd	r24, Y+1	; 0x01
    4384:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4386:	0f 90       	pop	r0
    4388:	0f 90       	pop	r0
    438a:	cf 91       	pop	r28
    438c:	df 91       	pop	r29
    438e:	08 95       	ret

00004390 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4390:	df 93       	push	r29
    4392:	cf 93       	push	r28
    4394:	00 d0       	rcall	.+0      	; 0x4396 <vTaskPriorityInherit+0x6>
    4396:	00 d0       	rcall	.+0      	; 0x4398 <vTaskPriorityInherit+0x8>
    4398:	cd b7       	in	r28, 0x3d	; 61
    439a:	de b7       	in	r29, 0x3e	; 62
    439c:	9c 83       	std	Y+4, r25	; 0x04
    439e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    43a0:	8b 81       	ldd	r24, Y+3	; 0x03
    43a2:	9c 81       	ldd	r25, Y+4	; 0x04
    43a4:	9a 83       	std	Y+2, r25	; 0x02
    43a6:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    43a8:	8b 81       	ldd	r24, Y+3	; 0x03
    43aa:	9c 81       	ldd	r25, Y+4	; 0x04
    43ac:	00 97       	sbiw	r24, 0x00	; 0
    43ae:	09 f4       	brne	.+2      	; 0x43b2 <vTaskPriorityInherit+0x22>
    43b0:	73 c0       	rjmp	.+230    	; 0x4498 <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    43b2:	e9 81       	ldd	r30, Y+1	; 0x01
    43b4:	fa 81       	ldd	r31, Y+2	; 0x02
    43b6:	96 89       	ldd	r25, Z+22	; 0x16
    43b8:	e0 91 bb 0b 	lds	r30, 0x0BBB
    43bc:	f0 91 bc 0b 	lds	r31, 0x0BBC
    43c0:	86 89       	ldd	r24, Z+22	; 0x16
    43c2:	98 17       	cp	r25, r24
    43c4:	08 f0       	brcs	.+2      	; 0x43c8 <vTaskPriorityInherit+0x38>
    43c6:	68 c0       	rjmp	.+208    	; 0x4498 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    43c8:	e9 81       	ldd	r30, Y+1	; 0x01
    43ca:	fa 81       	ldd	r31, Y+2	; 0x02
    43cc:	84 85       	ldd	r24, Z+12	; 0x0c
    43ce:	95 85       	ldd	r25, Z+13	; 0x0d
    43d0:	99 23       	and	r25, r25
    43d2:	7c f0       	brlt	.+30     	; 0x43f2 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    43d4:	e0 91 bb 0b 	lds	r30, 0x0BBB
    43d8:	f0 91 bc 0b 	lds	r31, 0x0BBC
    43dc:	86 89       	ldd	r24, Z+22	; 0x16
    43de:	28 2f       	mov	r18, r24
    43e0:	30 e0       	ldi	r19, 0x00	; 0
    43e2:	86 e0       	ldi	r24, 0x06	; 6
    43e4:	90 e0       	ldi	r25, 0x00	; 0
    43e6:	82 1b       	sub	r24, r18
    43e8:	93 0b       	sbc	r25, r19
    43ea:	e9 81       	ldd	r30, Y+1	; 0x01
    43ec:	fa 81       	ldd	r31, Y+2	; 0x02
    43ee:	95 87       	std	Z+13, r25	; 0x0d
    43f0:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    43f2:	e9 81       	ldd	r30, Y+1	; 0x01
    43f4:	fa 81       	ldd	r31, Y+2	; 0x02
    43f6:	42 85       	ldd	r20, Z+10	; 0x0a
    43f8:	53 85       	ldd	r21, Z+11	; 0x0b
    43fa:	e9 81       	ldd	r30, Y+1	; 0x01
    43fc:	fa 81       	ldd	r31, Y+2	; 0x02
    43fe:	86 89       	ldd	r24, Z+22	; 0x16
    4400:	28 2f       	mov	r18, r24
    4402:	30 e0       	ldi	r19, 0x00	; 0
    4404:	c9 01       	movw	r24, r18
    4406:	88 0f       	add	r24, r24
    4408:	99 1f       	adc	r25, r25
    440a:	88 0f       	add	r24, r24
    440c:	99 1f       	adc	r25, r25
    440e:	88 0f       	add	r24, r24
    4410:	99 1f       	adc	r25, r25
    4412:	82 0f       	add	r24, r18
    4414:	93 1f       	adc	r25, r19
    4416:	88 53       	subi	r24, 0x38	; 56
    4418:	94 4f       	sbci	r25, 0xF4	; 244
    441a:	48 17       	cp	r20, r24
    441c:	59 07       	cpc	r21, r25
    441e:	a1 f5       	brne	.+104    	; 0x4488 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4420:	89 81       	ldd	r24, Y+1	; 0x01
    4422:	9a 81       	ldd	r25, Y+2	; 0x02
    4424:	02 96       	adiw	r24, 0x02	; 2
    4426:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    442a:	e0 91 bb 0b 	lds	r30, 0x0BBB
    442e:	f0 91 bc 0b 	lds	r31, 0x0BBC
    4432:	86 89       	ldd	r24, Z+22	; 0x16
    4434:	e9 81       	ldd	r30, Y+1	; 0x01
    4436:	fa 81       	ldd	r31, Y+2	; 0x02
    4438:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    443a:	e9 81       	ldd	r30, Y+1	; 0x01
    443c:	fa 81       	ldd	r31, Y+2	; 0x02
    443e:	96 89       	ldd	r25, Z+22	; 0x16
    4440:	80 91 c1 0b 	lds	r24, 0x0BC1
    4444:	89 17       	cp	r24, r25
    4446:	28 f4       	brcc	.+10     	; 0x4452 <vTaskPriorityInherit+0xc2>
    4448:	e9 81       	ldd	r30, Y+1	; 0x01
    444a:	fa 81       	ldd	r31, Y+2	; 0x02
    444c:	86 89       	ldd	r24, Z+22	; 0x16
    444e:	80 93 c1 0b 	sts	0x0BC1, r24
    4452:	e9 81       	ldd	r30, Y+1	; 0x01
    4454:	fa 81       	ldd	r31, Y+2	; 0x02
    4456:	86 89       	ldd	r24, Z+22	; 0x16
    4458:	28 2f       	mov	r18, r24
    445a:	30 e0       	ldi	r19, 0x00	; 0
    445c:	c9 01       	movw	r24, r18
    445e:	88 0f       	add	r24, r24
    4460:	99 1f       	adc	r25, r25
    4462:	88 0f       	add	r24, r24
    4464:	99 1f       	adc	r25, r25
    4466:	88 0f       	add	r24, r24
    4468:	99 1f       	adc	r25, r25
    446a:	82 0f       	add	r24, r18
    446c:	93 1f       	adc	r25, r19
    446e:	ac 01       	movw	r20, r24
    4470:	48 53       	subi	r20, 0x38	; 56
    4472:	54 4f       	sbci	r21, 0xF4	; 244
    4474:	89 81       	ldd	r24, Y+1	; 0x01
    4476:	9a 81       	ldd	r25, Y+2	; 0x02
    4478:	9c 01       	movw	r18, r24
    447a:	2e 5f       	subi	r18, 0xFE	; 254
    447c:	3f 4f       	sbci	r19, 0xFF	; 255
    447e:	ca 01       	movw	r24, r20
    4480:	b9 01       	movw	r22, r18
    4482:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>
    4486:	08 c0       	rjmp	.+16     	; 0x4498 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4488:	e0 91 bb 0b 	lds	r30, 0x0BBB
    448c:	f0 91 bc 0b 	lds	r31, 0x0BBC
    4490:	86 89       	ldd	r24, Z+22	; 0x16
    4492:	e9 81       	ldd	r30, Y+1	; 0x01
    4494:	fa 81       	ldd	r31, Y+2	; 0x02
    4496:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4498:	0f 90       	pop	r0
    449a:	0f 90       	pop	r0
    449c:	0f 90       	pop	r0
    449e:	0f 90       	pop	r0
    44a0:	cf 91       	pop	r28
    44a2:	df 91       	pop	r29
    44a4:	08 95       	ret

000044a6 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    44a6:	df 93       	push	r29
    44a8:	cf 93       	push	r28
    44aa:	00 d0       	rcall	.+0      	; 0x44ac <xTaskPriorityDisinherit+0x6>
    44ac:	00 d0       	rcall	.+0      	; 0x44ae <xTaskPriorityDisinherit+0x8>
    44ae:	0f 92       	push	r0
    44b0:	cd b7       	in	r28, 0x3d	; 61
    44b2:	de b7       	in	r29, 0x3e	; 62
    44b4:	9d 83       	std	Y+5, r25	; 0x05
    44b6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    44b8:	8c 81       	ldd	r24, Y+4	; 0x04
    44ba:	9d 81       	ldd	r25, Y+5	; 0x05
    44bc:	9b 83       	std	Y+3, r25	; 0x03
    44be:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    44c0:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    44c2:	8c 81       	ldd	r24, Y+4	; 0x04
    44c4:	9d 81       	ldd	r25, Y+5	; 0x05
    44c6:	00 97       	sbiw	r24, 0x00	; 0
    44c8:	09 f4       	brne	.+2      	; 0x44cc <xTaskPriorityDisinherit+0x26>
    44ca:	56 c0       	rjmp	.+172    	; 0x4578 <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    44cc:	ea 81       	ldd	r30, Y+2	; 0x02
    44ce:	fb 81       	ldd	r31, Y+3	; 0x03
    44d0:	86 a5       	ldd	r24, Z+46	; 0x2e
    44d2:	81 50       	subi	r24, 0x01	; 1
    44d4:	ea 81       	ldd	r30, Y+2	; 0x02
    44d6:	fb 81       	ldd	r31, Y+3	; 0x03
    44d8:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    44da:	ea 81       	ldd	r30, Y+2	; 0x02
    44dc:	fb 81       	ldd	r31, Y+3	; 0x03
    44de:	96 89       	ldd	r25, Z+22	; 0x16
    44e0:	ea 81       	ldd	r30, Y+2	; 0x02
    44e2:	fb 81       	ldd	r31, Y+3	; 0x03
    44e4:	85 a5       	ldd	r24, Z+45	; 0x2d
    44e6:	98 17       	cp	r25, r24
    44e8:	09 f4       	brne	.+2      	; 0x44ec <xTaskPriorityDisinherit+0x46>
    44ea:	46 c0       	rjmp	.+140    	; 0x4578 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    44ec:	ea 81       	ldd	r30, Y+2	; 0x02
    44ee:	fb 81       	ldd	r31, Y+3	; 0x03
    44f0:	86 a5       	ldd	r24, Z+46	; 0x2e
    44f2:	88 23       	and	r24, r24
    44f4:	09 f0       	breq	.+2      	; 0x44f8 <xTaskPriorityDisinherit+0x52>
    44f6:	40 c0       	rjmp	.+128    	; 0x4578 <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    44f8:	8a 81       	ldd	r24, Y+2	; 0x02
    44fa:	9b 81       	ldd	r25, Y+3	; 0x03
    44fc:	02 96       	adiw	r24, 0x02	; 2
    44fe:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    4502:	ea 81       	ldd	r30, Y+2	; 0x02
    4504:	fb 81       	ldd	r31, Y+3	; 0x03
    4506:	85 a5       	ldd	r24, Z+45	; 0x2d
    4508:	ea 81       	ldd	r30, Y+2	; 0x02
    450a:	fb 81       	ldd	r31, Y+3	; 0x03
    450c:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    450e:	ea 81       	ldd	r30, Y+2	; 0x02
    4510:	fb 81       	ldd	r31, Y+3	; 0x03
    4512:	86 89       	ldd	r24, Z+22	; 0x16
    4514:	28 2f       	mov	r18, r24
    4516:	30 e0       	ldi	r19, 0x00	; 0
    4518:	86 e0       	ldi	r24, 0x06	; 6
    451a:	90 e0       	ldi	r25, 0x00	; 0
    451c:	82 1b       	sub	r24, r18
    451e:	93 0b       	sbc	r25, r19
    4520:	ea 81       	ldd	r30, Y+2	; 0x02
    4522:	fb 81       	ldd	r31, Y+3	; 0x03
    4524:	95 87       	std	Z+13, r25	; 0x0d
    4526:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    4528:	ea 81       	ldd	r30, Y+2	; 0x02
    452a:	fb 81       	ldd	r31, Y+3	; 0x03
    452c:	96 89       	ldd	r25, Z+22	; 0x16
    452e:	80 91 c1 0b 	lds	r24, 0x0BC1
    4532:	89 17       	cp	r24, r25
    4534:	28 f4       	brcc	.+10     	; 0x4540 <xTaskPriorityDisinherit+0x9a>
    4536:	ea 81       	ldd	r30, Y+2	; 0x02
    4538:	fb 81       	ldd	r31, Y+3	; 0x03
    453a:	86 89       	ldd	r24, Z+22	; 0x16
    453c:	80 93 c1 0b 	sts	0x0BC1, r24
    4540:	ea 81       	ldd	r30, Y+2	; 0x02
    4542:	fb 81       	ldd	r31, Y+3	; 0x03
    4544:	86 89       	ldd	r24, Z+22	; 0x16
    4546:	28 2f       	mov	r18, r24
    4548:	30 e0       	ldi	r19, 0x00	; 0
    454a:	c9 01       	movw	r24, r18
    454c:	88 0f       	add	r24, r24
    454e:	99 1f       	adc	r25, r25
    4550:	88 0f       	add	r24, r24
    4552:	99 1f       	adc	r25, r25
    4554:	88 0f       	add	r24, r24
    4556:	99 1f       	adc	r25, r25
    4558:	82 0f       	add	r24, r18
    455a:	93 1f       	adc	r25, r19
    455c:	ac 01       	movw	r20, r24
    455e:	48 53       	subi	r20, 0x38	; 56
    4560:	54 4f       	sbci	r21, 0xF4	; 244
    4562:	8a 81       	ldd	r24, Y+2	; 0x02
    4564:	9b 81       	ldd	r25, Y+3	; 0x03
    4566:	9c 01       	movw	r18, r24
    4568:	2e 5f       	subi	r18, 0xFE	; 254
    456a:	3f 4f       	sbci	r19, 0xFF	; 255
    456c:	ca 01       	movw	r24, r20
    456e:	b9 01       	movw	r22, r18
    4570:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    4574:	81 e0       	ldi	r24, 0x01	; 1
    4576:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4578:	89 81       	ldd	r24, Y+1	; 0x01
	}
    457a:	0f 90       	pop	r0
    457c:	0f 90       	pop	r0
    457e:	0f 90       	pop	r0
    4580:	0f 90       	pop	r0
    4582:	0f 90       	pop	r0
    4584:	cf 91       	pop	r28
    4586:	df 91       	pop	r29
    4588:	08 95       	ret

0000458a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    458a:	df 93       	push	r29
    458c:	cf 93       	push	r28
    458e:	00 d0       	rcall	.+0      	; 0x4590 <uxTaskResetEventItemValue+0x6>
    4590:	cd b7       	in	r28, 0x3d	; 61
    4592:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4594:	e0 91 bb 0b 	lds	r30, 0x0BBB
    4598:	f0 91 bc 0b 	lds	r31, 0x0BBC
    459c:	84 85       	ldd	r24, Z+12	; 0x0c
    459e:	95 85       	ldd	r25, Z+13	; 0x0d
    45a0:	9a 83       	std	Y+2, r25	; 0x02
    45a2:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    45a4:	a0 91 bb 0b 	lds	r26, 0x0BBB
    45a8:	b0 91 bc 0b 	lds	r27, 0x0BBC
    45ac:	e0 91 bb 0b 	lds	r30, 0x0BBB
    45b0:	f0 91 bc 0b 	lds	r31, 0x0BBC
    45b4:	86 89       	ldd	r24, Z+22	; 0x16
    45b6:	28 2f       	mov	r18, r24
    45b8:	30 e0       	ldi	r19, 0x00	; 0
    45ba:	86 e0       	ldi	r24, 0x06	; 6
    45bc:	90 e0       	ldi	r25, 0x00	; 0
    45be:	82 1b       	sub	r24, r18
    45c0:	93 0b       	sbc	r25, r19
    45c2:	1d 96       	adiw	r26, 0x0d	; 13
    45c4:	9c 93       	st	X, r25
    45c6:	8e 93       	st	-X, r24
    45c8:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    45ca:	89 81       	ldd	r24, Y+1	; 0x01
    45cc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    45ce:	0f 90       	pop	r0
    45d0:	0f 90       	pop	r0
    45d2:	cf 91       	pop	r28
    45d4:	df 91       	pop	r29
    45d6:	08 95       	ret

000045d8 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    45d8:	df 93       	push	r29
    45da:	cf 93       	push	r28
    45dc:	cd b7       	in	r28, 0x3d	; 61
    45de:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    45e0:	80 91 bb 0b 	lds	r24, 0x0BBB
    45e4:	90 91 bc 0b 	lds	r25, 0x0BBC
    45e8:	00 97       	sbiw	r24, 0x00	; 0
    45ea:	39 f0       	breq	.+14     	; 0x45fa <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    45ec:	e0 91 bb 0b 	lds	r30, 0x0BBB
    45f0:	f0 91 bc 0b 	lds	r31, 0x0BBC
    45f4:	86 a5       	ldd	r24, Z+46	; 0x2e
    45f6:	8f 5f       	subi	r24, 0xFF	; 255
    45f8:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    45fa:	80 91 bb 0b 	lds	r24, 0x0BBB
    45fe:	90 91 bc 0b 	lds	r25, 0x0BBC
	}
    4602:	cf 91       	pop	r28
    4604:	df 91       	pop	r29
    4606:	08 95       	ret

00004608 <DIO_VidSetPinDirection>:
/*
loc_u8port=port name 
loc_u8pin =pin number
loc_u8state=pin direction
*/
void DIO_VidSetPinDirection(uint8 loc_u8port,uint8 loc_u8pin, uint8 loc_u8state){
    4608:	df 93       	push	r29
    460a:	cf 93       	push	r28
    460c:	cd b7       	in	r28, 0x3d	; 61
    460e:	de b7       	in	r29, 0x3e	; 62
    4610:	27 97       	sbiw	r28, 0x07	; 7
    4612:	0f b6       	in	r0, 0x3f	; 63
    4614:	f8 94       	cli
    4616:	de bf       	out	0x3e, r29	; 62
    4618:	0f be       	out	0x3f, r0	; 63
    461a:	cd bf       	out	0x3d, r28	; 61
    461c:	89 83       	std	Y+1, r24	; 0x01
    461e:	6a 83       	std	Y+2, r22	; 0x02
    4620:	4b 83       	std	Y+3, r20	; 0x03
	
	if(1==loc_u8state){
    4622:	8b 81       	ldd	r24, Y+3	; 0x03
    4624:	81 30       	cpi	r24, 0x01	; 1
    4626:	09 f0       	breq	.+2      	; 0x462a <DIO_VidSetPinDirection+0x22>
    4628:	6f c0       	rjmp	.+222    	; 0x4708 <DIO_VidSetPinDirection+0x100>
	    switch(loc_u8port){
    462a:	89 81       	ldd	r24, Y+1	; 0x01
    462c:	28 2f       	mov	r18, r24
    462e:	30 e0       	ldi	r19, 0x00	; 0
    4630:	3f 83       	std	Y+7, r19	; 0x07
    4632:	2e 83       	std	Y+6, r18	; 0x06
    4634:	8e 81       	ldd	r24, Y+6	; 0x06
    4636:	9f 81       	ldd	r25, Y+7	; 0x07
    4638:	81 30       	cpi	r24, 0x01	; 1
    463a:	91 05       	cpc	r25, r1
    463c:	49 f1       	breq	.+82     	; 0x4690 <DIO_VidSetPinDirection+0x88>
    463e:	2e 81       	ldd	r18, Y+6	; 0x06
    4640:	3f 81       	ldd	r19, Y+7	; 0x07
    4642:	22 30       	cpi	r18, 0x02	; 2
    4644:	31 05       	cpc	r19, r1
    4646:	2c f4       	brge	.+10     	; 0x4652 <DIO_VidSetPinDirection+0x4a>
    4648:	8e 81       	ldd	r24, Y+6	; 0x06
    464a:	9f 81       	ldd	r25, Y+7	; 0x07
    464c:	00 97       	sbiw	r24, 0x00	; 0
    464e:	61 f0       	breq	.+24     	; 0x4668 <DIO_VidSetPinDirection+0x60>
    4650:	d2 c0       	rjmp	.+420    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
    4652:	2e 81       	ldd	r18, Y+6	; 0x06
    4654:	3f 81       	ldd	r19, Y+7	; 0x07
    4656:	22 30       	cpi	r18, 0x02	; 2
    4658:	31 05       	cpc	r19, r1
    465a:	71 f1       	breq	.+92     	; 0x46b8 <DIO_VidSetPinDirection+0xb0>
    465c:	8e 81       	ldd	r24, Y+6	; 0x06
    465e:	9f 81       	ldd	r25, Y+7	; 0x07
    4660:	83 30       	cpi	r24, 0x03	; 3
    4662:	91 05       	cpc	r25, r1
    4664:	e9 f1       	breq	.+122    	; 0x46e0 <DIO_VidSetPinDirection+0xd8>
    4666:	c7 c0       	rjmp	.+398    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 0:SET_BIT(DDRA,loc_u8pin);break;
    4668:	aa e3       	ldi	r26, 0x3A	; 58
    466a:	b0 e0       	ldi	r27, 0x00	; 0
    466c:	ea e3       	ldi	r30, 0x3A	; 58
    466e:	f0 e0       	ldi	r31, 0x00	; 0
    4670:	80 81       	ld	r24, Z
    4672:	48 2f       	mov	r20, r24
    4674:	8a 81       	ldd	r24, Y+2	; 0x02
    4676:	28 2f       	mov	r18, r24
    4678:	30 e0       	ldi	r19, 0x00	; 0
    467a:	81 e0       	ldi	r24, 0x01	; 1
    467c:	90 e0       	ldi	r25, 0x00	; 0
    467e:	02 2e       	mov	r0, r18
    4680:	02 c0       	rjmp	.+4      	; 0x4686 <DIO_VidSetPinDirection+0x7e>
    4682:	88 0f       	add	r24, r24
    4684:	99 1f       	adc	r25, r25
    4686:	0a 94       	dec	r0
    4688:	e2 f7       	brpl	.-8      	; 0x4682 <DIO_VidSetPinDirection+0x7a>
    468a:	84 2b       	or	r24, r20
    468c:	8c 93       	st	X, r24
    468e:	b3 c0       	rjmp	.+358    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 1:SET_BIT(DDRB,loc_u8pin);break;
    4690:	a7 e3       	ldi	r26, 0x37	; 55
    4692:	b0 e0       	ldi	r27, 0x00	; 0
    4694:	e7 e3       	ldi	r30, 0x37	; 55
    4696:	f0 e0       	ldi	r31, 0x00	; 0
    4698:	80 81       	ld	r24, Z
    469a:	48 2f       	mov	r20, r24
    469c:	8a 81       	ldd	r24, Y+2	; 0x02
    469e:	28 2f       	mov	r18, r24
    46a0:	30 e0       	ldi	r19, 0x00	; 0
    46a2:	81 e0       	ldi	r24, 0x01	; 1
    46a4:	90 e0       	ldi	r25, 0x00	; 0
    46a6:	02 2e       	mov	r0, r18
    46a8:	02 c0       	rjmp	.+4      	; 0x46ae <DIO_VidSetPinDirection+0xa6>
    46aa:	88 0f       	add	r24, r24
    46ac:	99 1f       	adc	r25, r25
    46ae:	0a 94       	dec	r0
    46b0:	e2 f7       	brpl	.-8      	; 0x46aa <DIO_VidSetPinDirection+0xa2>
    46b2:	84 2b       	or	r24, r20
    46b4:	8c 93       	st	X, r24
    46b6:	9f c0       	rjmp	.+318    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 2:SET_BIT(DDRC,loc_u8pin);break;
    46b8:	a4 e3       	ldi	r26, 0x34	; 52
    46ba:	b0 e0       	ldi	r27, 0x00	; 0
    46bc:	e4 e3       	ldi	r30, 0x34	; 52
    46be:	f0 e0       	ldi	r31, 0x00	; 0
    46c0:	80 81       	ld	r24, Z
    46c2:	48 2f       	mov	r20, r24
    46c4:	8a 81       	ldd	r24, Y+2	; 0x02
    46c6:	28 2f       	mov	r18, r24
    46c8:	30 e0       	ldi	r19, 0x00	; 0
    46ca:	81 e0       	ldi	r24, 0x01	; 1
    46cc:	90 e0       	ldi	r25, 0x00	; 0
    46ce:	02 2e       	mov	r0, r18
    46d0:	02 c0       	rjmp	.+4      	; 0x46d6 <DIO_VidSetPinDirection+0xce>
    46d2:	88 0f       	add	r24, r24
    46d4:	99 1f       	adc	r25, r25
    46d6:	0a 94       	dec	r0
    46d8:	e2 f7       	brpl	.-8      	; 0x46d2 <DIO_VidSetPinDirection+0xca>
    46da:	84 2b       	or	r24, r20
    46dc:	8c 93       	st	X, r24
    46de:	8b c0       	rjmp	.+278    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 3:SET_BIT(DDRD,loc_u8pin);break;
    46e0:	a1 e3       	ldi	r26, 0x31	; 49
    46e2:	b0 e0       	ldi	r27, 0x00	; 0
    46e4:	e1 e3       	ldi	r30, 0x31	; 49
    46e6:	f0 e0       	ldi	r31, 0x00	; 0
    46e8:	80 81       	ld	r24, Z
    46ea:	48 2f       	mov	r20, r24
    46ec:	8a 81       	ldd	r24, Y+2	; 0x02
    46ee:	28 2f       	mov	r18, r24
    46f0:	30 e0       	ldi	r19, 0x00	; 0
    46f2:	81 e0       	ldi	r24, 0x01	; 1
    46f4:	90 e0       	ldi	r25, 0x00	; 0
    46f6:	02 2e       	mov	r0, r18
    46f8:	02 c0       	rjmp	.+4      	; 0x46fe <DIO_VidSetPinDirection+0xf6>
    46fa:	88 0f       	add	r24, r24
    46fc:	99 1f       	adc	r25, r25
    46fe:	0a 94       	dec	r0
    4700:	e2 f7       	brpl	.-8      	; 0x46fa <DIO_VidSetPinDirection+0xf2>
    4702:	84 2b       	or	r24, r20
    4704:	8c 93       	st	X, r24
    4706:	77 c0       	rjmp	.+238    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
	 }
	}
	else if(0==loc_u8state){
    4708:	8b 81       	ldd	r24, Y+3	; 0x03
    470a:	88 23       	and	r24, r24
    470c:	09 f0       	breq	.+2      	; 0x4710 <DIO_VidSetPinDirection+0x108>
    470e:	73 c0       	rjmp	.+230    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
	    switch(loc_u8port){
    4710:	89 81       	ldd	r24, Y+1	; 0x01
    4712:	28 2f       	mov	r18, r24
    4714:	30 e0       	ldi	r19, 0x00	; 0
    4716:	3d 83       	std	Y+5, r19	; 0x05
    4718:	2c 83       	std	Y+4, r18	; 0x04
    471a:	8c 81       	ldd	r24, Y+4	; 0x04
    471c:	9d 81       	ldd	r25, Y+5	; 0x05
    471e:	81 30       	cpi	r24, 0x01	; 1
    4720:	91 05       	cpc	r25, r1
    4722:	59 f1       	breq	.+86     	; 0x477a <DIO_VidSetPinDirection+0x172>
    4724:	2c 81       	ldd	r18, Y+4	; 0x04
    4726:	3d 81       	ldd	r19, Y+5	; 0x05
    4728:	22 30       	cpi	r18, 0x02	; 2
    472a:	31 05       	cpc	r19, r1
    472c:	2c f4       	brge	.+10     	; 0x4738 <DIO_VidSetPinDirection+0x130>
    472e:	8c 81       	ldd	r24, Y+4	; 0x04
    4730:	9d 81       	ldd	r25, Y+5	; 0x05
    4732:	00 97       	sbiw	r24, 0x00	; 0
    4734:	69 f0       	breq	.+26     	; 0x4750 <DIO_VidSetPinDirection+0x148>
    4736:	5f c0       	rjmp	.+190    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
    4738:	2c 81       	ldd	r18, Y+4	; 0x04
    473a:	3d 81       	ldd	r19, Y+5	; 0x05
    473c:	22 30       	cpi	r18, 0x02	; 2
    473e:	31 05       	cpc	r19, r1
    4740:	89 f1       	breq	.+98     	; 0x47a4 <DIO_VidSetPinDirection+0x19c>
    4742:	8c 81       	ldd	r24, Y+4	; 0x04
    4744:	9d 81       	ldd	r25, Y+5	; 0x05
    4746:	83 30       	cpi	r24, 0x03	; 3
    4748:	91 05       	cpc	r25, r1
    474a:	09 f4       	brne	.+2      	; 0x474e <DIO_VidSetPinDirection+0x146>
    474c:	40 c0       	rjmp	.+128    	; 0x47ce <DIO_VidSetPinDirection+0x1c6>
    474e:	53 c0       	rjmp	.+166    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 0:CLR_BIT(DDRA,loc_u8pin);break;
    4750:	aa e3       	ldi	r26, 0x3A	; 58
    4752:	b0 e0       	ldi	r27, 0x00	; 0
    4754:	ea e3       	ldi	r30, 0x3A	; 58
    4756:	f0 e0       	ldi	r31, 0x00	; 0
    4758:	80 81       	ld	r24, Z
    475a:	48 2f       	mov	r20, r24
    475c:	8a 81       	ldd	r24, Y+2	; 0x02
    475e:	28 2f       	mov	r18, r24
    4760:	30 e0       	ldi	r19, 0x00	; 0
    4762:	81 e0       	ldi	r24, 0x01	; 1
    4764:	90 e0       	ldi	r25, 0x00	; 0
    4766:	02 2e       	mov	r0, r18
    4768:	02 c0       	rjmp	.+4      	; 0x476e <DIO_VidSetPinDirection+0x166>
    476a:	88 0f       	add	r24, r24
    476c:	99 1f       	adc	r25, r25
    476e:	0a 94       	dec	r0
    4770:	e2 f7       	brpl	.-8      	; 0x476a <DIO_VidSetPinDirection+0x162>
    4772:	80 95       	com	r24
    4774:	84 23       	and	r24, r20
    4776:	8c 93       	st	X, r24
    4778:	3e c0       	rjmp	.+124    	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 1:CLR_BIT(DDRB,loc_u8pin);break;
    477a:	a7 e3       	ldi	r26, 0x37	; 55
    477c:	b0 e0       	ldi	r27, 0x00	; 0
    477e:	e7 e3       	ldi	r30, 0x37	; 55
    4780:	f0 e0       	ldi	r31, 0x00	; 0
    4782:	80 81       	ld	r24, Z
    4784:	48 2f       	mov	r20, r24
    4786:	8a 81       	ldd	r24, Y+2	; 0x02
    4788:	28 2f       	mov	r18, r24
    478a:	30 e0       	ldi	r19, 0x00	; 0
    478c:	81 e0       	ldi	r24, 0x01	; 1
    478e:	90 e0       	ldi	r25, 0x00	; 0
    4790:	02 2e       	mov	r0, r18
    4792:	02 c0       	rjmp	.+4      	; 0x4798 <DIO_VidSetPinDirection+0x190>
    4794:	88 0f       	add	r24, r24
    4796:	99 1f       	adc	r25, r25
    4798:	0a 94       	dec	r0
    479a:	e2 f7       	brpl	.-8      	; 0x4794 <DIO_VidSetPinDirection+0x18c>
    479c:	80 95       	com	r24
    479e:	84 23       	and	r24, r20
    47a0:	8c 93       	st	X, r24
    47a2:	29 c0       	rjmp	.+82     	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 2:CLR_BIT(DDRC,loc_u8pin);break;
    47a4:	a4 e3       	ldi	r26, 0x34	; 52
    47a6:	b0 e0       	ldi	r27, 0x00	; 0
    47a8:	e4 e3       	ldi	r30, 0x34	; 52
    47aa:	f0 e0       	ldi	r31, 0x00	; 0
    47ac:	80 81       	ld	r24, Z
    47ae:	48 2f       	mov	r20, r24
    47b0:	8a 81       	ldd	r24, Y+2	; 0x02
    47b2:	28 2f       	mov	r18, r24
    47b4:	30 e0       	ldi	r19, 0x00	; 0
    47b6:	81 e0       	ldi	r24, 0x01	; 1
    47b8:	90 e0       	ldi	r25, 0x00	; 0
    47ba:	02 2e       	mov	r0, r18
    47bc:	02 c0       	rjmp	.+4      	; 0x47c2 <DIO_VidSetPinDirection+0x1ba>
    47be:	88 0f       	add	r24, r24
    47c0:	99 1f       	adc	r25, r25
    47c2:	0a 94       	dec	r0
    47c4:	e2 f7       	brpl	.-8      	; 0x47be <DIO_VidSetPinDirection+0x1b6>
    47c6:	80 95       	com	r24
    47c8:	84 23       	and	r24, r20
    47ca:	8c 93       	st	X, r24
    47cc:	14 c0       	rjmp	.+40     	; 0x47f6 <DIO_VidSetPinDirection+0x1ee>
		case 3:CLR_BIT(DDRD,loc_u8pin);break;
    47ce:	a1 e3       	ldi	r26, 0x31	; 49
    47d0:	b0 e0       	ldi	r27, 0x00	; 0
    47d2:	e1 e3       	ldi	r30, 0x31	; 49
    47d4:	f0 e0       	ldi	r31, 0x00	; 0
    47d6:	80 81       	ld	r24, Z
    47d8:	48 2f       	mov	r20, r24
    47da:	8a 81       	ldd	r24, Y+2	; 0x02
    47dc:	28 2f       	mov	r18, r24
    47de:	30 e0       	ldi	r19, 0x00	; 0
    47e0:	81 e0       	ldi	r24, 0x01	; 1
    47e2:	90 e0       	ldi	r25, 0x00	; 0
    47e4:	02 2e       	mov	r0, r18
    47e6:	02 c0       	rjmp	.+4      	; 0x47ec <DIO_VidSetPinDirection+0x1e4>
    47e8:	88 0f       	add	r24, r24
    47ea:	99 1f       	adc	r25, r25
    47ec:	0a 94       	dec	r0
    47ee:	e2 f7       	brpl	.-8      	; 0x47e8 <DIO_VidSetPinDirection+0x1e0>
    47f0:	80 95       	com	r24
    47f2:	84 23       	and	r24, r20
    47f4:	8c 93       	st	X, r24
	 }
	}
	
	
}
    47f6:	27 96       	adiw	r28, 0x07	; 7
    47f8:	0f b6       	in	r0, 0x3f	; 63
    47fa:	f8 94       	cli
    47fc:	de bf       	out	0x3e, r29	; 62
    47fe:	0f be       	out	0x3f, r0	; 63
    4800:	cd bf       	out	0x3d, r28	; 61
    4802:	cf 91       	pop	r28
    4804:	df 91       	pop	r29
    4806:	08 95       	ret

00004808 <DIO_VidSetPinValue>:
void DIO_VidSetPinValue(uint8 loc_u8port,uint8 loc_u8pin, uint8 loc_u8value){
    4808:	df 93       	push	r29
    480a:	cf 93       	push	r28
    480c:	cd b7       	in	r28, 0x3d	; 61
    480e:	de b7       	in	r29, 0x3e	; 62
    4810:	27 97       	sbiw	r28, 0x07	; 7
    4812:	0f b6       	in	r0, 0x3f	; 63
    4814:	f8 94       	cli
    4816:	de bf       	out	0x3e, r29	; 62
    4818:	0f be       	out	0x3f, r0	; 63
    481a:	cd bf       	out	0x3d, r28	; 61
    481c:	89 83       	std	Y+1, r24	; 0x01
    481e:	6a 83       	std	Y+2, r22	; 0x02
    4820:	4b 83       	std	Y+3, r20	; 0x03
	
	if(1==loc_u8value){
    4822:	8b 81       	ldd	r24, Y+3	; 0x03
    4824:	81 30       	cpi	r24, 0x01	; 1
    4826:	09 f0       	breq	.+2      	; 0x482a <DIO_VidSetPinValue+0x22>
    4828:	6f c0       	rjmp	.+222    	; 0x4908 <DIO_VidSetPinValue+0x100>
	    switch(loc_u8port){
    482a:	89 81       	ldd	r24, Y+1	; 0x01
    482c:	28 2f       	mov	r18, r24
    482e:	30 e0       	ldi	r19, 0x00	; 0
    4830:	3f 83       	std	Y+7, r19	; 0x07
    4832:	2e 83       	std	Y+6, r18	; 0x06
    4834:	8e 81       	ldd	r24, Y+6	; 0x06
    4836:	9f 81       	ldd	r25, Y+7	; 0x07
    4838:	81 30       	cpi	r24, 0x01	; 1
    483a:	91 05       	cpc	r25, r1
    483c:	49 f1       	breq	.+82     	; 0x4890 <DIO_VidSetPinValue+0x88>
    483e:	2e 81       	ldd	r18, Y+6	; 0x06
    4840:	3f 81       	ldd	r19, Y+7	; 0x07
    4842:	22 30       	cpi	r18, 0x02	; 2
    4844:	31 05       	cpc	r19, r1
    4846:	2c f4       	brge	.+10     	; 0x4852 <DIO_VidSetPinValue+0x4a>
    4848:	8e 81       	ldd	r24, Y+6	; 0x06
    484a:	9f 81       	ldd	r25, Y+7	; 0x07
    484c:	00 97       	sbiw	r24, 0x00	; 0
    484e:	61 f0       	breq	.+24     	; 0x4868 <DIO_VidSetPinValue+0x60>
    4850:	d2 c0       	rjmp	.+420    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
    4852:	2e 81       	ldd	r18, Y+6	; 0x06
    4854:	3f 81       	ldd	r19, Y+7	; 0x07
    4856:	22 30       	cpi	r18, 0x02	; 2
    4858:	31 05       	cpc	r19, r1
    485a:	71 f1       	breq	.+92     	; 0x48b8 <DIO_VidSetPinValue+0xb0>
    485c:	8e 81       	ldd	r24, Y+6	; 0x06
    485e:	9f 81       	ldd	r25, Y+7	; 0x07
    4860:	83 30       	cpi	r24, 0x03	; 3
    4862:	91 05       	cpc	r25, r1
    4864:	e9 f1       	breq	.+122    	; 0x48e0 <DIO_VidSetPinValue+0xd8>
    4866:	c7 c0       	rjmp	.+398    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 0:SET_BIT(PORTA,loc_u8pin);break;
    4868:	ab e3       	ldi	r26, 0x3B	; 59
    486a:	b0 e0       	ldi	r27, 0x00	; 0
    486c:	eb e3       	ldi	r30, 0x3B	; 59
    486e:	f0 e0       	ldi	r31, 0x00	; 0
    4870:	80 81       	ld	r24, Z
    4872:	48 2f       	mov	r20, r24
    4874:	8a 81       	ldd	r24, Y+2	; 0x02
    4876:	28 2f       	mov	r18, r24
    4878:	30 e0       	ldi	r19, 0x00	; 0
    487a:	81 e0       	ldi	r24, 0x01	; 1
    487c:	90 e0       	ldi	r25, 0x00	; 0
    487e:	02 2e       	mov	r0, r18
    4880:	02 c0       	rjmp	.+4      	; 0x4886 <DIO_VidSetPinValue+0x7e>
    4882:	88 0f       	add	r24, r24
    4884:	99 1f       	adc	r25, r25
    4886:	0a 94       	dec	r0
    4888:	e2 f7       	brpl	.-8      	; 0x4882 <DIO_VidSetPinValue+0x7a>
    488a:	84 2b       	or	r24, r20
    488c:	8c 93       	st	X, r24
    488e:	b3 c0       	rjmp	.+358    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 1:SET_BIT(PORTB,loc_u8pin);break;
    4890:	a8 e3       	ldi	r26, 0x38	; 56
    4892:	b0 e0       	ldi	r27, 0x00	; 0
    4894:	e8 e3       	ldi	r30, 0x38	; 56
    4896:	f0 e0       	ldi	r31, 0x00	; 0
    4898:	80 81       	ld	r24, Z
    489a:	48 2f       	mov	r20, r24
    489c:	8a 81       	ldd	r24, Y+2	; 0x02
    489e:	28 2f       	mov	r18, r24
    48a0:	30 e0       	ldi	r19, 0x00	; 0
    48a2:	81 e0       	ldi	r24, 0x01	; 1
    48a4:	90 e0       	ldi	r25, 0x00	; 0
    48a6:	02 2e       	mov	r0, r18
    48a8:	02 c0       	rjmp	.+4      	; 0x48ae <DIO_VidSetPinValue+0xa6>
    48aa:	88 0f       	add	r24, r24
    48ac:	99 1f       	adc	r25, r25
    48ae:	0a 94       	dec	r0
    48b0:	e2 f7       	brpl	.-8      	; 0x48aa <DIO_VidSetPinValue+0xa2>
    48b2:	84 2b       	or	r24, r20
    48b4:	8c 93       	st	X, r24
    48b6:	9f c0       	rjmp	.+318    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 2:SET_BIT(PORTC,loc_u8pin);break;
    48b8:	a5 e3       	ldi	r26, 0x35	; 53
    48ba:	b0 e0       	ldi	r27, 0x00	; 0
    48bc:	e5 e3       	ldi	r30, 0x35	; 53
    48be:	f0 e0       	ldi	r31, 0x00	; 0
    48c0:	80 81       	ld	r24, Z
    48c2:	48 2f       	mov	r20, r24
    48c4:	8a 81       	ldd	r24, Y+2	; 0x02
    48c6:	28 2f       	mov	r18, r24
    48c8:	30 e0       	ldi	r19, 0x00	; 0
    48ca:	81 e0       	ldi	r24, 0x01	; 1
    48cc:	90 e0       	ldi	r25, 0x00	; 0
    48ce:	02 2e       	mov	r0, r18
    48d0:	02 c0       	rjmp	.+4      	; 0x48d6 <DIO_VidSetPinValue+0xce>
    48d2:	88 0f       	add	r24, r24
    48d4:	99 1f       	adc	r25, r25
    48d6:	0a 94       	dec	r0
    48d8:	e2 f7       	brpl	.-8      	; 0x48d2 <DIO_VidSetPinValue+0xca>
    48da:	84 2b       	or	r24, r20
    48dc:	8c 93       	st	X, r24
    48de:	8b c0       	rjmp	.+278    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 3:SET_BIT(PORTD,loc_u8pin);break;
    48e0:	a2 e3       	ldi	r26, 0x32	; 50
    48e2:	b0 e0       	ldi	r27, 0x00	; 0
    48e4:	e2 e3       	ldi	r30, 0x32	; 50
    48e6:	f0 e0       	ldi	r31, 0x00	; 0
    48e8:	80 81       	ld	r24, Z
    48ea:	48 2f       	mov	r20, r24
    48ec:	8a 81       	ldd	r24, Y+2	; 0x02
    48ee:	28 2f       	mov	r18, r24
    48f0:	30 e0       	ldi	r19, 0x00	; 0
    48f2:	81 e0       	ldi	r24, 0x01	; 1
    48f4:	90 e0       	ldi	r25, 0x00	; 0
    48f6:	02 2e       	mov	r0, r18
    48f8:	02 c0       	rjmp	.+4      	; 0x48fe <DIO_VidSetPinValue+0xf6>
    48fa:	88 0f       	add	r24, r24
    48fc:	99 1f       	adc	r25, r25
    48fe:	0a 94       	dec	r0
    4900:	e2 f7       	brpl	.-8      	; 0x48fa <DIO_VidSetPinValue+0xf2>
    4902:	84 2b       	or	r24, r20
    4904:	8c 93       	st	X, r24
    4906:	77 c0       	rjmp	.+238    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
	 }
	}
	else if(0==loc_u8value){
    4908:	8b 81       	ldd	r24, Y+3	; 0x03
    490a:	88 23       	and	r24, r24
    490c:	09 f0       	breq	.+2      	; 0x4910 <DIO_VidSetPinValue+0x108>
    490e:	73 c0       	rjmp	.+230    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
	    switch(loc_u8port){
    4910:	89 81       	ldd	r24, Y+1	; 0x01
    4912:	28 2f       	mov	r18, r24
    4914:	30 e0       	ldi	r19, 0x00	; 0
    4916:	3d 83       	std	Y+5, r19	; 0x05
    4918:	2c 83       	std	Y+4, r18	; 0x04
    491a:	8c 81       	ldd	r24, Y+4	; 0x04
    491c:	9d 81       	ldd	r25, Y+5	; 0x05
    491e:	81 30       	cpi	r24, 0x01	; 1
    4920:	91 05       	cpc	r25, r1
    4922:	59 f1       	breq	.+86     	; 0x497a <DIO_VidSetPinValue+0x172>
    4924:	2c 81       	ldd	r18, Y+4	; 0x04
    4926:	3d 81       	ldd	r19, Y+5	; 0x05
    4928:	22 30       	cpi	r18, 0x02	; 2
    492a:	31 05       	cpc	r19, r1
    492c:	2c f4       	brge	.+10     	; 0x4938 <DIO_VidSetPinValue+0x130>
    492e:	8c 81       	ldd	r24, Y+4	; 0x04
    4930:	9d 81       	ldd	r25, Y+5	; 0x05
    4932:	00 97       	sbiw	r24, 0x00	; 0
    4934:	69 f0       	breq	.+26     	; 0x4950 <DIO_VidSetPinValue+0x148>
    4936:	5f c0       	rjmp	.+190    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
    4938:	2c 81       	ldd	r18, Y+4	; 0x04
    493a:	3d 81       	ldd	r19, Y+5	; 0x05
    493c:	22 30       	cpi	r18, 0x02	; 2
    493e:	31 05       	cpc	r19, r1
    4940:	89 f1       	breq	.+98     	; 0x49a4 <DIO_VidSetPinValue+0x19c>
    4942:	8c 81       	ldd	r24, Y+4	; 0x04
    4944:	9d 81       	ldd	r25, Y+5	; 0x05
    4946:	83 30       	cpi	r24, 0x03	; 3
    4948:	91 05       	cpc	r25, r1
    494a:	09 f4       	brne	.+2      	; 0x494e <DIO_VidSetPinValue+0x146>
    494c:	40 c0       	rjmp	.+128    	; 0x49ce <DIO_VidSetPinValue+0x1c6>
    494e:	53 c0       	rjmp	.+166    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 0:CLR_BIT(PORTA,loc_u8pin);break;
    4950:	ab e3       	ldi	r26, 0x3B	; 59
    4952:	b0 e0       	ldi	r27, 0x00	; 0
    4954:	eb e3       	ldi	r30, 0x3B	; 59
    4956:	f0 e0       	ldi	r31, 0x00	; 0
    4958:	80 81       	ld	r24, Z
    495a:	48 2f       	mov	r20, r24
    495c:	8a 81       	ldd	r24, Y+2	; 0x02
    495e:	28 2f       	mov	r18, r24
    4960:	30 e0       	ldi	r19, 0x00	; 0
    4962:	81 e0       	ldi	r24, 0x01	; 1
    4964:	90 e0       	ldi	r25, 0x00	; 0
    4966:	02 2e       	mov	r0, r18
    4968:	02 c0       	rjmp	.+4      	; 0x496e <DIO_VidSetPinValue+0x166>
    496a:	88 0f       	add	r24, r24
    496c:	99 1f       	adc	r25, r25
    496e:	0a 94       	dec	r0
    4970:	e2 f7       	brpl	.-8      	; 0x496a <DIO_VidSetPinValue+0x162>
    4972:	80 95       	com	r24
    4974:	84 23       	and	r24, r20
    4976:	8c 93       	st	X, r24
    4978:	3e c0       	rjmp	.+124    	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 1:CLR_BIT(PORTB,loc_u8pin);break;
    497a:	a8 e3       	ldi	r26, 0x38	; 56
    497c:	b0 e0       	ldi	r27, 0x00	; 0
    497e:	e8 e3       	ldi	r30, 0x38	; 56
    4980:	f0 e0       	ldi	r31, 0x00	; 0
    4982:	80 81       	ld	r24, Z
    4984:	48 2f       	mov	r20, r24
    4986:	8a 81       	ldd	r24, Y+2	; 0x02
    4988:	28 2f       	mov	r18, r24
    498a:	30 e0       	ldi	r19, 0x00	; 0
    498c:	81 e0       	ldi	r24, 0x01	; 1
    498e:	90 e0       	ldi	r25, 0x00	; 0
    4990:	02 2e       	mov	r0, r18
    4992:	02 c0       	rjmp	.+4      	; 0x4998 <DIO_VidSetPinValue+0x190>
    4994:	88 0f       	add	r24, r24
    4996:	99 1f       	adc	r25, r25
    4998:	0a 94       	dec	r0
    499a:	e2 f7       	brpl	.-8      	; 0x4994 <DIO_VidSetPinValue+0x18c>
    499c:	80 95       	com	r24
    499e:	84 23       	and	r24, r20
    49a0:	8c 93       	st	X, r24
    49a2:	29 c0       	rjmp	.+82     	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 2:CLR_BIT(PORTC,loc_u8pin);break;
    49a4:	a5 e3       	ldi	r26, 0x35	; 53
    49a6:	b0 e0       	ldi	r27, 0x00	; 0
    49a8:	e5 e3       	ldi	r30, 0x35	; 53
    49aa:	f0 e0       	ldi	r31, 0x00	; 0
    49ac:	80 81       	ld	r24, Z
    49ae:	48 2f       	mov	r20, r24
    49b0:	8a 81       	ldd	r24, Y+2	; 0x02
    49b2:	28 2f       	mov	r18, r24
    49b4:	30 e0       	ldi	r19, 0x00	; 0
    49b6:	81 e0       	ldi	r24, 0x01	; 1
    49b8:	90 e0       	ldi	r25, 0x00	; 0
    49ba:	02 2e       	mov	r0, r18
    49bc:	02 c0       	rjmp	.+4      	; 0x49c2 <DIO_VidSetPinValue+0x1ba>
    49be:	88 0f       	add	r24, r24
    49c0:	99 1f       	adc	r25, r25
    49c2:	0a 94       	dec	r0
    49c4:	e2 f7       	brpl	.-8      	; 0x49be <DIO_VidSetPinValue+0x1b6>
    49c6:	80 95       	com	r24
    49c8:	84 23       	and	r24, r20
    49ca:	8c 93       	st	X, r24
    49cc:	14 c0       	rjmp	.+40     	; 0x49f6 <DIO_VidSetPinValue+0x1ee>
		case 3:CLR_BIT(PORTD,loc_u8pin);break;
    49ce:	a2 e3       	ldi	r26, 0x32	; 50
    49d0:	b0 e0       	ldi	r27, 0x00	; 0
    49d2:	e2 e3       	ldi	r30, 0x32	; 50
    49d4:	f0 e0       	ldi	r31, 0x00	; 0
    49d6:	80 81       	ld	r24, Z
    49d8:	48 2f       	mov	r20, r24
    49da:	8a 81       	ldd	r24, Y+2	; 0x02
    49dc:	28 2f       	mov	r18, r24
    49de:	30 e0       	ldi	r19, 0x00	; 0
    49e0:	81 e0       	ldi	r24, 0x01	; 1
    49e2:	90 e0       	ldi	r25, 0x00	; 0
    49e4:	02 2e       	mov	r0, r18
    49e6:	02 c0       	rjmp	.+4      	; 0x49ec <DIO_VidSetPinValue+0x1e4>
    49e8:	88 0f       	add	r24, r24
    49ea:	99 1f       	adc	r25, r25
    49ec:	0a 94       	dec	r0
    49ee:	e2 f7       	brpl	.-8      	; 0x49e8 <DIO_VidSetPinValue+0x1e0>
    49f0:	80 95       	com	r24
    49f2:	84 23       	and	r24, r20
    49f4:	8c 93       	st	X, r24
	 }
	}
}
    49f6:	27 96       	adiw	r28, 0x07	; 7
    49f8:	0f b6       	in	r0, 0x3f	; 63
    49fa:	f8 94       	cli
    49fc:	de bf       	out	0x3e, r29	; 62
    49fe:	0f be       	out	0x3f, r0	; 63
    4a00:	cd bf       	out	0x3d, r28	; 61
    4a02:	cf 91       	pop	r28
    4a04:	df 91       	pop	r29
    4a06:	08 95       	ret

00004a08 <DIO_VidSetPortDirection>:
void DIO_VidSetPortDirection(uint8 loc_u8port,uint8 loc_u8value){
    4a08:	df 93       	push	r29
    4a0a:	cf 93       	push	r28
    4a0c:	00 d0       	rcall	.+0      	; 0x4a0e <DIO_VidSetPortDirection+0x6>
    4a0e:	00 d0       	rcall	.+0      	; 0x4a10 <DIO_VidSetPortDirection+0x8>
    4a10:	cd b7       	in	r28, 0x3d	; 61
    4a12:	de b7       	in	r29, 0x3e	; 62
    4a14:	89 83       	std	Y+1, r24	; 0x01
    4a16:	6a 83       	std	Y+2, r22	; 0x02
	

			switch(loc_u8port){
    4a18:	89 81       	ldd	r24, Y+1	; 0x01
    4a1a:	28 2f       	mov	r18, r24
    4a1c:	30 e0       	ldi	r19, 0x00	; 0
    4a1e:	3c 83       	std	Y+4, r19	; 0x04
    4a20:	2b 83       	std	Y+3, r18	; 0x03
    4a22:	8b 81       	ldd	r24, Y+3	; 0x03
    4a24:	9c 81       	ldd	r25, Y+4	; 0x04
    4a26:	81 30       	cpi	r24, 0x01	; 1
    4a28:	91 05       	cpc	r25, r1
    4a2a:	d1 f0       	breq	.+52     	; 0x4a60 <DIO_VidSetPortDirection+0x58>
    4a2c:	2b 81       	ldd	r18, Y+3	; 0x03
    4a2e:	3c 81       	ldd	r19, Y+4	; 0x04
    4a30:	22 30       	cpi	r18, 0x02	; 2
    4a32:	31 05       	cpc	r19, r1
    4a34:	2c f4       	brge	.+10     	; 0x4a40 <DIO_VidSetPortDirection+0x38>
    4a36:	8b 81       	ldd	r24, Y+3	; 0x03
    4a38:	9c 81       	ldd	r25, Y+4	; 0x04
    4a3a:	00 97       	sbiw	r24, 0x00	; 0
    4a3c:	61 f0       	breq	.+24     	; 0x4a56 <DIO_VidSetPortDirection+0x4e>
    4a3e:	1e c0       	rjmp	.+60     	; 0x4a7c <DIO_VidSetPortDirection+0x74>
    4a40:	2b 81       	ldd	r18, Y+3	; 0x03
    4a42:	3c 81       	ldd	r19, Y+4	; 0x04
    4a44:	22 30       	cpi	r18, 0x02	; 2
    4a46:	31 05       	cpc	r19, r1
    4a48:	81 f0       	breq	.+32     	; 0x4a6a <DIO_VidSetPortDirection+0x62>
    4a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a4e:	83 30       	cpi	r24, 0x03	; 3
    4a50:	91 05       	cpc	r25, r1
    4a52:	81 f0       	breq	.+32     	; 0x4a74 <DIO_VidSetPortDirection+0x6c>
    4a54:	13 c0       	rjmp	.+38     	; 0x4a7c <DIO_VidSetPortDirection+0x74>

			case 0:DDRA=loc_u8value;break;
    4a56:	ea e3       	ldi	r30, 0x3A	; 58
    4a58:	f0 e0       	ldi	r31, 0x00	; 0
    4a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a5c:	80 83       	st	Z, r24
    4a5e:	0e c0       	rjmp	.+28     	; 0x4a7c <DIO_VidSetPortDirection+0x74>
			case 1:DDRB=loc_u8value;break;
    4a60:	e7 e3       	ldi	r30, 0x37	; 55
    4a62:	f0 e0       	ldi	r31, 0x00	; 0
    4a64:	8a 81       	ldd	r24, Y+2	; 0x02
    4a66:	80 83       	st	Z, r24
    4a68:	09 c0       	rjmp	.+18     	; 0x4a7c <DIO_VidSetPortDirection+0x74>
			case 2:DDRC=loc_u8value;break;
    4a6a:	e4 e3       	ldi	r30, 0x34	; 52
    4a6c:	f0 e0       	ldi	r31, 0x00	; 0
    4a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a70:	80 83       	st	Z, r24
    4a72:	04 c0       	rjmp	.+8      	; 0x4a7c <DIO_VidSetPortDirection+0x74>
			case 3:DDRD=loc_u8value;break;
    4a74:	e1 e3       	ldi	r30, 0x31	; 49
    4a76:	f0 e0       	ldi	r31, 0x00	; 0
    4a78:	8a 81       	ldd	r24, Y+2	; 0x02
    4a7a:	80 83       	st	Z, r24

			}
		
}
    4a7c:	0f 90       	pop	r0
    4a7e:	0f 90       	pop	r0
    4a80:	0f 90       	pop	r0
    4a82:	0f 90       	pop	r0
    4a84:	cf 91       	pop	r28
    4a86:	df 91       	pop	r29
    4a88:	08 95       	ret

00004a8a <DIO_VidSetPortValue>:
void DIO_VidSetPortValue(uint8 loc_u8port,uint8 loc_u8value){
    4a8a:	df 93       	push	r29
    4a8c:	cf 93       	push	r28
    4a8e:	00 d0       	rcall	.+0      	; 0x4a90 <DIO_VidSetPortValue+0x6>
    4a90:	00 d0       	rcall	.+0      	; 0x4a92 <DIO_VidSetPortValue+0x8>
    4a92:	cd b7       	in	r28, 0x3d	; 61
    4a94:	de b7       	in	r29, 0x3e	; 62
    4a96:	89 83       	std	Y+1, r24	; 0x01
    4a98:	6a 83       	std	Y+2, r22	; 0x02
	
			switch(loc_u8port){
    4a9a:	89 81       	ldd	r24, Y+1	; 0x01
    4a9c:	28 2f       	mov	r18, r24
    4a9e:	30 e0       	ldi	r19, 0x00	; 0
    4aa0:	3c 83       	std	Y+4, r19	; 0x04
    4aa2:	2b 83       	std	Y+3, r18	; 0x03
    4aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    4aa6:	9c 81       	ldd	r25, Y+4	; 0x04
    4aa8:	81 30       	cpi	r24, 0x01	; 1
    4aaa:	91 05       	cpc	r25, r1
    4aac:	d1 f0       	breq	.+52     	; 0x4ae2 <DIO_VidSetPortValue+0x58>
    4aae:	2b 81       	ldd	r18, Y+3	; 0x03
    4ab0:	3c 81       	ldd	r19, Y+4	; 0x04
    4ab2:	22 30       	cpi	r18, 0x02	; 2
    4ab4:	31 05       	cpc	r19, r1
    4ab6:	2c f4       	brge	.+10     	; 0x4ac2 <DIO_VidSetPortValue+0x38>
    4ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    4aba:	9c 81       	ldd	r25, Y+4	; 0x04
    4abc:	00 97       	sbiw	r24, 0x00	; 0
    4abe:	61 f0       	breq	.+24     	; 0x4ad8 <DIO_VidSetPortValue+0x4e>
    4ac0:	1e c0       	rjmp	.+60     	; 0x4afe <DIO_VidSetPortValue+0x74>
    4ac2:	2b 81       	ldd	r18, Y+3	; 0x03
    4ac4:	3c 81       	ldd	r19, Y+4	; 0x04
    4ac6:	22 30       	cpi	r18, 0x02	; 2
    4ac8:	31 05       	cpc	r19, r1
    4aca:	81 f0       	breq	.+32     	; 0x4aec <DIO_VidSetPortValue+0x62>
    4acc:	8b 81       	ldd	r24, Y+3	; 0x03
    4ace:	9c 81       	ldd	r25, Y+4	; 0x04
    4ad0:	83 30       	cpi	r24, 0x03	; 3
    4ad2:	91 05       	cpc	r25, r1
    4ad4:	81 f0       	breq	.+32     	; 0x4af6 <DIO_VidSetPortValue+0x6c>
    4ad6:	13 c0       	rjmp	.+38     	; 0x4afe <DIO_VidSetPortValue+0x74>

			case 0:PORTA=loc_u8value;break;
    4ad8:	eb e3       	ldi	r30, 0x3B	; 59
    4ada:	f0 e0       	ldi	r31, 0x00	; 0
    4adc:	8a 81       	ldd	r24, Y+2	; 0x02
    4ade:	80 83       	st	Z, r24
    4ae0:	0e c0       	rjmp	.+28     	; 0x4afe <DIO_VidSetPortValue+0x74>
			case 1:PORTB=loc_u8value;break;
    4ae2:	e8 e3       	ldi	r30, 0x38	; 56
    4ae4:	f0 e0       	ldi	r31, 0x00	; 0
    4ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae8:	80 83       	st	Z, r24
    4aea:	09 c0       	rjmp	.+18     	; 0x4afe <DIO_VidSetPortValue+0x74>
			case 2:PORTC=loc_u8value;break;
    4aec:	e5 e3       	ldi	r30, 0x35	; 53
    4aee:	f0 e0       	ldi	r31, 0x00	; 0
    4af0:	8a 81       	ldd	r24, Y+2	; 0x02
    4af2:	80 83       	st	Z, r24
    4af4:	04 c0       	rjmp	.+8      	; 0x4afe <DIO_VidSetPortValue+0x74>
			case 3:PORTD=loc_u8value;break;
    4af6:	e2 e3       	ldi	r30, 0x32	; 50
    4af8:	f0 e0       	ldi	r31, 0x00	; 0
    4afa:	8a 81       	ldd	r24, Y+2	; 0x02
    4afc:	80 83       	st	Z, r24

			}
	
}
    4afe:	0f 90       	pop	r0
    4b00:	0f 90       	pop	r0
    4b02:	0f 90       	pop	r0
    4b04:	0f 90       	pop	r0
    4b06:	cf 91       	pop	r28
    4b08:	df 91       	pop	r29
    4b0a:	08 95       	ret

00004b0c <DIO_u8GetPinValue>:
uint8 DIO_u8GetPinValue(uint8 loc_u8port,uint8 loc_u8pin){
    4b0c:	df 93       	push	r29
    4b0e:	cf 93       	push	r28
    4b10:	00 d0       	rcall	.+0      	; 0x4b12 <DIO_u8GetPinValue+0x6>
    4b12:	00 d0       	rcall	.+0      	; 0x4b14 <DIO_u8GetPinValue+0x8>
    4b14:	0f 92       	push	r0
    4b16:	cd b7       	in	r28, 0x3d	; 61
    4b18:	de b7       	in	r29, 0x3e	; 62
    4b1a:	8a 83       	std	Y+2, r24	; 0x02
    4b1c:	6b 83       	std	Y+3, r22	; 0x03
	uint8 VALUE;
	switch(loc_u8port){
    4b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b20:	28 2f       	mov	r18, r24
    4b22:	30 e0       	ldi	r19, 0x00	; 0
    4b24:	3d 83       	std	Y+5, r19	; 0x05
    4b26:	2c 83       	std	Y+4, r18	; 0x04
    4b28:	4c 81       	ldd	r20, Y+4	; 0x04
    4b2a:	5d 81       	ldd	r21, Y+5	; 0x05
    4b2c:	41 30       	cpi	r20, 0x01	; 1
    4b2e:	51 05       	cpc	r21, r1
    4b30:	41 f1       	breq	.+80     	; 0x4b82 <DIO_u8GetPinValue+0x76>
    4b32:	8c 81       	ldd	r24, Y+4	; 0x04
    4b34:	9d 81       	ldd	r25, Y+5	; 0x05
    4b36:	82 30       	cpi	r24, 0x02	; 2
    4b38:	91 05       	cpc	r25, r1
    4b3a:	34 f4       	brge	.+12     	; 0x4b48 <DIO_u8GetPinValue+0x3c>
    4b3c:	2c 81       	ldd	r18, Y+4	; 0x04
    4b3e:	3d 81       	ldd	r19, Y+5	; 0x05
    4b40:	21 15       	cp	r18, r1
    4b42:	31 05       	cpc	r19, r1
    4b44:	61 f0       	breq	.+24     	; 0x4b5e <DIO_u8GetPinValue+0x52>
    4b46:	52 c0       	rjmp	.+164    	; 0x4bec <DIO_u8GetPinValue+0xe0>
    4b48:	4c 81       	ldd	r20, Y+4	; 0x04
    4b4a:	5d 81       	ldd	r21, Y+5	; 0x05
    4b4c:	42 30       	cpi	r20, 0x02	; 2
    4b4e:	51 05       	cpc	r21, r1
    4b50:	51 f1       	breq	.+84     	; 0x4ba6 <DIO_u8GetPinValue+0x9a>
    4b52:	8c 81       	ldd	r24, Y+4	; 0x04
    4b54:	9d 81       	ldd	r25, Y+5	; 0x05
    4b56:	83 30       	cpi	r24, 0x03	; 3
    4b58:	91 05       	cpc	r25, r1
    4b5a:	b9 f1       	breq	.+110    	; 0x4bca <DIO_u8GetPinValue+0xbe>
    4b5c:	47 c0       	rjmp	.+142    	; 0x4bec <DIO_u8GetPinValue+0xe0>
		case 0:VALUE=GET_BIT(PINA,loc_u8pin); break;
    4b5e:	e9 e3       	ldi	r30, 0x39	; 57
    4b60:	f0 e0       	ldi	r31, 0x00	; 0
    4b62:	80 81       	ld	r24, Z
    4b64:	28 2f       	mov	r18, r24
    4b66:	30 e0       	ldi	r19, 0x00	; 0
    4b68:	8b 81       	ldd	r24, Y+3	; 0x03
    4b6a:	88 2f       	mov	r24, r24
    4b6c:	90 e0       	ldi	r25, 0x00	; 0
    4b6e:	a9 01       	movw	r20, r18
    4b70:	02 c0       	rjmp	.+4      	; 0x4b76 <DIO_u8GetPinValue+0x6a>
    4b72:	55 95       	asr	r21
    4b74:	47 95       	ror	r20
    4b76:	8a 95       	dec	r24
    4b78:	e2 f7       	brpl	.-8      	; 0x4b72 <DIO_u8GetPinValue+0x66>
    4b7a:	ca 01       	movw	r24, r20
    4b7c:	81 70       	andi	r24, 0x01	; 1
    4b7e:	89 83       	std	Y+1, r24	; 0x01
    4b80:	35 c0       	rjmp	.+106    	; 0x4bec <DIO_u8GetPinValue+0xe0>
		case 1:VALUE=GET_BIT(PINB,loc_u8pin); break;
    4b82:	e6 e3       	ldi	r30, 0x36	; 54
    4b84:	f0 e0       	ldi	r31, 0x00	; 0
    4b86:	80 81       	ld	r24, Z
    4b88:	28 2f       	mov	r18, r24
    4b8a:	30 e0       	ldi	r19, 0x00	; 0
    4b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b8e:	88 2f       	mov	r24, r24
    4b90:	90 e0       	ldi	r25, 0x00	; 0
    4b92:	a9 01       	movw	r20, r18
    4b94:	02 c0       	rjmp	.+4      	; 0x4b9a <DIO_u8GetPinValue+0x8e>
    4b96:	55 95       	asr	r21
    4b98:	47 95       	ror	r20
    4b9a:	8a 95       	dec	r24
    4b9c:	e2 f7       	brpl	.-8      	; 0x4b96 <DIO_u8GetPinValue+0x8a>
    4b9e:	ca 01       	movw	r24, r20
    4ba0:	81 70       	andi	r24, 0x01	; 1
    4ba2:	89 83       	std	Y+1, r24	; 0x01
    4ba4:	23 c0       	rjmp	.+70     	; 0x4bec <DIO_u8GetPinValue+0xe0>
		case 2:VALUE=GET_BIT(PINC,loc_u8pin); break;
    4ba6:	e3 e3       	ldi	r30, 0x33	; 51
    4ba8:	f0 e0       	ldi	r31, 0x00	; 0
    4baa:	80 81       	ld	r24, Z
    4bac:	28 2f       	mov	r18, r24
    4bae:	30 e0       	ldi	r19, 0x00	; 0
    4bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb2:	88 2f       	mov	r24, r24
    4bb4:	90 e0       	ldi	r25, 0x00	; 0
    4bb6:	a9 01       	movw	r20, r18
    4bb8:	02 c0       	rjmp	.+4      	; 0x4bbe <DIO_u8GetPinValue+0xb2>
    4bba:	55 95       	asr	r21
    4bbc:	47 95       	ror	r20
    4bbe:	8a 95       	dec	r24
    4bc0:	e2 f7       	brpl	.-8      	; 0x4bba <DIO_u8GetPinValue+0xae>
    4bc2:	ca 01       	movw	r24, r20
    4bc4:	81 70       	andi	r24, 0x01	; 1
    4bc6:	89 83       	std	Y+1, r24	; 0x01
    4bc8:	11 c0       	rjmp	.+34     	; 0x4bec <DIO_u8GetPinValue+0xe0>
		case 3:VALUE=GET_BIT(PIND,loc_u8pin); break;
    4bca:	e0 e3       	ldi	r30, 0x30	; 48
    4bcc:	f0 e0       	ldi	r31, 0x00	; 0
    4bce:	80 81       	ld	r24, Z
    4bd0:	28 2f       	mov	r18, r24
    4bd2:	30 e0       	ldi	r19, 0x00	; 0
    4bd4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd6:	88 2f       	mov	r24, r24
    4bd8:	90 e0       	ldi	r25, 0x00	; 0
    4bda:	a9 01       	movw	r20, r18
    4bdc:	02 c0       	rjmp	.+4      	; 0x4be2 <DIO_u8GetPinValue+0xd6>
    4bde:	55 95       	asr	r21
    4be0:	47 95       	ror	r20
    4be2:	8a 95       	dec	r24
    4be4:	e2 f7       	brpl	.-8      	; 0x4bde <DIO_u8GetPinValue+0xd2>
    4be6:	ca 01       	movw	r24, r20
    4be8:	81 70       	andi	r24, 0x01	; 1
    4bea:	89 83       	std	Y+1, r24	; 0x01
	 }
	 return VALUE;
    4bec:	89 81       	ldd	r24, Y+1	; 0x01
}
    4bee:	0f 90       	pop	r0
    4bf0:	0f 90       	pop	r0
    4bf2:	0f 90       	pop	r0
    4bf4:	0f 90       	pop	r0
    4bf6:	0f 90       	pop	r0
    4bf8:	cf 91       	pop	r28
    4bfa:	df 91       	pop	r29
    4bfc:	08 95       	ret

00004bfe <DIO_VidTogBit>:

void DIO_VidTogBit(uint8 loc_u8port,uint8 LOC_u8BitNum){
    4bfe:	df 93       	push	r29
    4c00:	cf 93       	push	r28
    4c02:	00 d0       	rcall	.+0      	; 0x4c04 <DIO_VidTogBit+0x6>
    4c04:	00 d0       	rcall	.+0      	; 0x4c06 <DIO_VidTogBit+0x8>
    4c06:	cd b7       	in	r28, 0x3d	; 61
    4c08:	de b7       	in	r29, 0x3e	; 62
    4c0a:	89 83       	std	Y+1, r24	; 0x01
    4c0c:	6a 83       	std	Y+2, r22	; 0x02
	switch(loc_u8port){
    4c0e:	89 81       	ldd	r24, Y+1	; 0x01
    4c10:	28 2f       	mov	r18, r24
    4c12:	30 e0       	ldi	r19, 0x00	; 0
    4c14:	3c 83       	std	Y+4, r19	; 0x04
    4c16:	2b 83       	std	Y+3, r18	; 0x03
    4c18:	8b 81       	ldd	r24, Y+3	; 0x03
    4c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    4c1c:	81 30       	cpi	r24, 0x01	; 1
    4c1e:	91 05       	cpc	r25, r1
    4c20:	49 f1       	breq	.+82     	; 0x4c74 <DIO_VidTogBit+0x76>
    4c22:	2b 81       	ldd	r18, Y+3	; 0x03
    4c24:	3c 81       	ldd	r19, Y+4	; 0x04
    4c26:	22 30       	cpi	r18, 0x02	; 2
    4c28:	31 05       	cpc	r19, r1
    4c2a:	2c f4       	brge	.+10     	; 0x4c36 <DIO_VidTogBit+0x38>
    4c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c30:	00 97       	sbiw	r24, 0x00	; 0
    4c32:	61 f0       	breq	.+24     	; 0x4c4c <DIO_VidTogBit+0x4e>
    4c34:	5a c0       	rjmp	.+180    	; 0x4cea <DIO_VidTogBit+0xec>
    4c36:	2b 81       	ldd	r18, Y+3	; 0x03
    4c38:	3c 81       	ldd	r19, Y+4	; 0x04
    4c3a:	22 30       	cpi	r18, 0x02	; 2
    4c3c:	31 05       	cpc	r19, r1
    4c3e:	71 f1       	breq	.+92     	; 0x4c9c <DIO_VidTogBit+0x9e>
    4c40:	8b 81       	ldd	r24, Y+3	; 0x03
    4c42:	9c 81       	ldd	r25, Y+4	; 0x04
    4c44:	83 30       	cpi	r24, 0x03	; 3
    4c46:	91 05       	cpc	r25, r1
    4c48:	e9 f1       	breq	.+122    	; 0x4cc4 <DIO_VidTogBit+0xc6>
    4c4a:	4f c0       	rjmp	.+158    	; 0x4cea <DIO_VidTogBit+0xec>
		case 0: TOG_BIT(PORTA,LOC_u8BitNum); break;
    4c4c:	ab e3       	ldi	r26, 0x3B	; 59
    4c4e:	b0 e0       	ldi	r27, 0x00	; 0
    4c50:	eb e3       	ldi	r30, 0x3B	; 59
    4c52:	f0 e0       	ldi	r31, 0x00	; 0
    4c54:	80 81       	ld	r24, Z
    4c56:	48 2f       	mov	r20, r24
    4c58:	8a 81       	ldd	r24, Y+2	; 0x02
    4c5a:	28 2f       	mov	r18, r24
    4c5c:	30 e0       	ldi	r19, 0x00	; 0
    4c5e:	81 e0       	ldi	r24, 0x01	; 1
    4c60:	90 e0       	ldi	r25, 0x00	; 0
    4c62:	02 2e       	mov	r0, r18
    4c64:	02 c0       	rjmp	.+4      	; 0x4c6a <DIO_VidTogBit+0x6c>
    4c66:	88 0f       	add	r24, r24
    4c68:	99 1f       	adc	r25, r25
    4c6a:	0a 94       	dec	r0
    4c6c:	e2 f7       	brpl	.-8      	; 0x4c66 <DIO_VidTogBit+0x68>
    4c6e:	84 27       	eor	r24, r20
    4c70:	8c 93       	st	X, r24
    4c72:	3b c0       	rjmp	.+118    	; 0x4cea <DIO_VidTogBit+0xec>
		case 1: TOG_BIT(PORTB,LOC_u8BitNum); break;
    4c74:	a8 e3       	ldi	r26, 0x38	; 56
    4c76:	b0 e0       	ldi	r27, 0x00	; 0
    4c78:	e8 e3       	ldi	r30, 0x38	; 56
    4c7a:	f0 e0       	ldi	r31, 0x00	; 0
    4c7c:	80 81       	ld	r24, Z
    4c7e:	48 2f       	mov	r20, r24
    4c80:	8a 81       	ldd	r24, Y+2	; 0x02
    4c82:	28 2f       	mov	r18, r24
    4c84:	30 e0       	ldi	r19, 0x00	; 0
    4c86:	81 e0       	ldi	r24, 0x01	; 1
    4c88:	90 e0       	ldi	r25, 0x00	; 0
    4c8a:	02 2e       	mov	r0, r18
    4c8c:	02 c0       	rjmp	.+4      	; 0x4c92 <DIO_VidTogBit+0x94>
    4c8e:	88 0f       	add	r24, r24
    4c90:	99 1f       	adc	r25, r25
    4c92:	0a 94       	dec	r0
    4c94:	e2 f7       	brpl	.-8      	; 0x4c8e <DIO_VidTogBit+0x90>
    4c96:	84 27       	eor	r24, r20
    4c98:	8c 93       	st	X, r24
    4c9a:	27 c0       	rjmp	.+78     	; 0x4cea <DIO_VidTogBit+0xec>
		case 2: TOG_BIT(PORTC,LOC_u8BitNum); break;
    4c9c:	a5 e3       	ldi	r26, 0x35	; 53
    4c9e:	b0 e0       	ldi	r27, 0x00	; 0
    4ca0:	e5 e3       	ldi	r30, 0x35	; 53
    4ca2:	f0 e0       	ldi	r31, 0x00	; 0
    4ca4:	80 81       	ld	r24, Z
    4ca6:	48 2f       	mov	r20, r24
    4ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    4caa:	28 2f       	mov	r18, r24
    4cac:	30 e0       	ldi	r19, 0x00	; 0
    4cae:	81 e0       	ldi	r24, 0x01	; 1
    4cb0:	90 e0       	ldi	r25, 0x00	; 0
    4cb2:	02 2e       	mov	r0, r18
    4cb4:	02 c0       	rjmp	.+4      	; 0x4cba <DIO_VidTogBit+0xbc>
    4cb6:	88 0f       	add	r24, r24
    4cb8:	99 1f       	adc	r25, r25
    4cba:	0a 94       	dec	r0
    4cbc:	e2 f7       	brpl	.-8      	; 0x4cb6 <DIO_VidTogBit+0xb8>
    4cbe:	84 27       	eor	r24, r20
    4cc0:	8c 93       	st	X, r24
    4cc2:	13 c0       	rjmp	.+38     	; 0x4cea <DIO_VidTogBit+0xec>
		case 3: TOG_BIT(PORTD,LOC_u8BitNum); break;
    4cc4:	a2 e3       	ldi	r26, 0x32	; 50
    4cc6:	b0 e0       	ldi	r27, 0x00	; 0
    4cc8:	e2 e3       	ldi	r30, 0x32	; 50
    4cca:	f0 e0       	ldi	r31, 0x00	; 0
    4ccc:	80 81       	ld	r24, Z
    4cce:	48 2f       	mov	r20, r24
    4cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    4cd2:	28 2f       	mov	r18, r24
    4cd4:	30 e0       	ldi	r19, 0x00	; 0
    4cd6:	81 e0       	ldi	r24, 0x01	; 1
    4cd8:	90 e0       	ldi	r25, 0x00	; 0
    4cda:	02 2e       	mov	r0, r18
    4cdc:	02 c0       	rjmp	.+4      	; 0x4ce2 <DIO_VidTogBit+0xe4>
    4cde:	88 0f       	add	r24, r24
    4ce0:	99 1f       	adc	r25, r25
    4ce2:	0a 94       	dec	r0
    4ce4:	e2 f7       	brpl	.-8      	; 0x4cde <DIO_VidTogBit+0xe0>
    4ce6:	84 27       	eor	r24, r20
    4ce8:	8c 93       	st	X, r24
	}	
}
    4cea:	0f 90       	pop	r0
    4cec:	0f 90       	pop	r0
    4cee:	0f 90       	pop	r0
    4cf0:	0f 90       	pop	r0
    4cf2:	cf 91       	pop	r28
    4cf4:	df 91       	pop	r29
    4cf6:	08 95       	ret

00004cf8 <LCD_init>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void LCD_init(void)
{
    4cf8:	df 93       	push	r29
    4cfa:	cf 93       	push	r28
    4cfc:	cd b7       	in	r28, 0x3d	; 61
    4cfe:	de b7       	in	r29, 0x3e	; 62
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */ 
    4d00:	e4 e3       	ldi	r30, 0x34	; 52
    4d02:	f0 e0       	ldi	r31, 0x00	; 0
    4d04:	8f ef       	ldi	r24, 0xFF	; 255
    4d06:	80 83       	st	Z, r24
	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    4d08:	a7 e3       	ldi	r26, 0x37	; 55
    4d0a:	b0 e0       	ldi	r27, 0x00	; 0
    4d0c:	e7 e3       	ldi	r30, 0x37	; 55
    4d0e:	f0 e0       	ldi	r31, 0x00	; 0
    4d10:	80 81       	ld	r24, Z
    4d12:	80 67       	ori	r24, 0x70	; 112
    4d14:	8c 93       	st	X, r24
	
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
    4d16:	88 e3       	ldi	r24, 0x38	; 56
    4d18:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <LCD_sendCommand>
	
	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    4d1c:	8c e0       	ldi	r24, 0x0C	; 12
    4d1e:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <LCD_sendCommand>
	
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    4d22:	81 e0       	ldi	r24, 0x01	; 1
    4d24:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <LCD_sendCommand>
}
    4d28:	cf 91       	pop	r28
    4d2a:	df 91       	pop	r29
    4d2c:	08 95       	ret

00004d2e <LCD_sendCommand>:

void LCD_sendCommand(uint8 command)
{
    4d2e:	df 93       	push	r29
    4d30:	cf 93       	push	r28
    4d32:	cd b7       	in	r28, 0x3d	; 61
    4d34:	de b7       	in	r29, 0x3e	; 62
    4d36:	e9 97       	sbiw	r28, 0x39	; 57
    4d38:	0f b6       	in	r0, 0x3f	; 63
    4d3a:	f8 94       	cli
    4d3c:	de bf       	out	0x3e, r29	; 62
    4d3e:	0f be       	out	0x3f, r0	; 63
    4d40:	cd bf       	out	0x3d, r28	; 61
    4d42:	89 af       	std	Y+57, r24	; 0x39
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    4d44:	a8 e3       	ldi	r26, 0x38	; 56
    4d46:	b0 e0       	ldi	r27, 0x00	; 0
    4d48:	e8 e3       	ldi	r30, 0x38	; 56
    4d4a:	f0 e0       	ldi	r31, 0x00	; 0
    4d4c:	80 81       	ld	r24, Z
    4d4e:	8f 7e       	andi	r24, 0xEF	; 239
    4d50:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    4d52:	a8 e3       	ldi	r26, 0x38	; 56
    4d54:	b0 e0       	ldi	r27, 0x00	; 0
    4d56:	e8 e3       	ldi	r30, 0x38	; 56
    4d58:	f0 e0       	ldi	r31, 0x00	; 0
    4d5a:	80 81       	ld	r24, Z
    4d5c:	8f 7d       	andi	r24, 0xDF	; 223
    4d5e:	8c 93       	st	X, r24
    4d60:	80 e0       	ldi	r24, 0x00	; 0
    4d62:	90 e0       	ldi	r25, 0x00	; 0
    4d64:	a0 e8       	ldi	r26, 0x80	; 128
    4d66:	bf e3       	ldi	r27, 0x3F	; 63
    4d68:	8d ab       	std	Y+53, r24	; 0x35
    4d6a:	9e ab       	std	Y+54, r25	; 0x36
    4d6c:	af ab       	std	Y+55, r26	; 0x37
    4d6e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4d70:	6d a9       	ldd	r22, Y+53	; 0x35
    4d72:	7e a9       	ldd	r23, Y+54	; 0x36
    4d74:	8f a9       	ldd	r24, Y+55	; 0x37
    4d76:	98 ad       	ldd	r25, Y+56	; 0x38
    4d78:	20 e0       	ldi	r18, 0x00	; 0
    4d7a:	30 e0       	ldi	r19, 0x00	; 0
    4d7c:	4a ef       	ldi	r20, 0xFA	; 250
    4d7e:	54 e4       	ldi	r21, 0x44	; 68
    4d80:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    4d84:	dc 01       	movw	r26, r24
    4d86:	cb 01       	movw	r24, r22
    4d88:	89 ab       	std	Y+49, r24	; 0x31
    4d8a:	9a ab       	std	Y+50, r25	; 0x32
    4d8c:	ab ab       	std	Y+51, r26	; 0x33
    4d8e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    4d90:	69 a9       	ldd	r22, Y+49	; 0x31
    4d92:	7a a9       	ldd	r23, Y+50	; 0x32
    4d94:	8b a9       	ldd	r24, Y+51	; 0x33
    4d96:	9c a9       	ldd	r25, Y+52	; 0x34
    4d98:	20 e0       	ldi	r18, 0x00	; 0
    4d9a:	30 e0       	ldi	r19, 0x00	; 0
    4d9c:	40 e8       	ldi	r20, 0x80	; 128
    4d9e:	5f e3       	ldi	r21, 0x3F	; 63
    4da0:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    4da4:	88 23       	and	r24, r24
    4da6:	2c f4       	brge	.+10     	; 0x4db2 <LCD_sendCommand+0x84>
		__ticks = 1;
    4da8:	81 e0       	ldi	r24, 0x01	; 1
    4daa:	90 e0       	ldi	r25, 0x00	; 0
    4dac:	98 ab       	std	Y+48, r25	; 0x30
    4dae:	8f a7       	std	Y+47, r24	; 0x2f
    4db0:	3f c0       	rjmp	.+126    	; 0x4e30 <LCD_sendCommand+0x102>
	else if (__tmp > 65535)
    4db2:	69 a9       	ldd	r22, Y+49	; 0x31
    4db4:	7a a9       	ldd	r23, Y+50	; 0x32
    4db6:	8b a9       	ldd	r24, Y+51	; 0x33
    4db8:	9c a9       	ldd	r25, Y+52	; 0x34
    4dba:	20 e0       	ldi	r18, 0x00	; 0
    4dbc:	3f ef       	ldi	r19, 0xFF	; 255
    4dbe:	4f e7       	ldi	r20, 0x7F	; 127
    4dc0:	57 e4       	ldi	r21, 0x47	; 71
    4dc2:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    4dc6:	18 16       	cp	r1, r24
    4dc8:	4c f5       	brge	.+82     	; 0x4e1c <LCD_sendCommand+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4dca:	6d a9       	ldd	r22, Y+53	; 0x35
    4dcc:	7e a9       	ldd	r23, Y+54	; 0x36
    4dce:	8f a9       	ldd	r24, Y+55	; 0x37
    4dd0:	98 ad       	ldd	r25, Y+56	; 0x38
    4dd2:	20 e0       	ldi	r18, 0x00	; 0
    4dd4:	30 e0       	ldi	r19, 0x00	; 0
    4dd6:	40 e2       	ldi	r20, 0x20	; 32
    4dd8:	51 e4       	ldi	r21, 0x41	; 65
    4dda:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    4dde:	dc 01       	movw	r26, r24
    4de0:	cb 01       	movw	r24, r22
    4de2:	bc 01       	movw	r22, r24
    4de4:	cd 01       	movw	r24, r26
    4de6:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    4dea:	dc 01       	movw	r26, r24
    4dec:	cb 01       	movw	r24, r22
    4dee:	98 ab       	std	Y+48, r25	; 0x30
    4df0:	8f a7       	std	Y+47, r24	; 0x2f
    4df2:	0f c0       	rjmp	.+30     	; 0x4e12 <LCD_sendCommand+0xe4>
    4df4:	88 ec       	ldi	r24, 0xC8	; 200
    4df6:	90 e0       	ldi	r25, 0x00	; 0
    4df8:	9e a7       	std	Y+46, r25	; 0x2e
    4dfa:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4dfc:	8d a5       	ldd	r24, Y+45	; 0x2d
    4dfe:	9e a5       	ldd	r25, Y+46	; 0x2e
    4e00:	01 97       	sbiw	r24, 0x01	; 1
    4e02:	f1 f7       	brne	.-4      	; 0x4e00 <LCD_sendCommand+0xd2>
    4e04:	9e a7       	std	Y+46, r25	; 0x2e
    4e06:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4e08:	8f a5       	ldd	r24, Y+47	; 0x2f
    4e0a:	98 a9       	ldd	r25, Y+48	; 0x30
    4e0c:	01 97       	sbiw	r24, 0x01	; 1
    4e0e:	98 ab       	std	Y+48, r25	; 0x30
    4e10:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e12:	8f a5       	ldd	r24, Y+47	; 0x2f
    4e14:	98 a9       	ldd	r25, Y+48	; 0x30
    4e16:	00 97       	sbiw	r24, 0x00	; 0
    4e18:	69 f7       	brne	.-38     	; 0x4df4 <LCD_sendCommand+0xc6>
    4e1a:	14 c0       	rjmp	.+40     	; 0x4e44 <LCD_sendCommand+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4e1c:	69 a9       	ldd	r22, Y+49	; 0x31
    4e1e:	7a a9       	ldd	r23, Y+50	; 0x32
    4e20:	8b a9       	ldd	r24, Y+51	; 0x33
    4e22:	9c a9       	ldd	r25, Y+52	; 0x34
    4e24:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    4e28:	dc 01       	movw	r26, r24
    4e2a:	cb 01       	movw	r24, r22
    4e2c:	98 ab       	std	Y+48, r25	; 0x30
    4e2e:	8f a7       	std	Y+47, r24	; 0x2f
    4e30:	8f a5       	ldd	r24, Y+47	; 0x2f
    4e32:	98 a9       	ldd	r25, Y+48	; 0x30
    4e34:	9c a7       	std	Y+44, r25	; 0x2c
    4e36:	8b a7       	std	Y+43, r24	; 0x2b
    4e38:	8b a5       	ldd	r24, Y+43	; 0x2b
    4e3a:	9c a5       	ldd	r25, Y+44	; 0x2c
    4e3c:	01 97       	sbiw	r24, 0x01	; 1
    4e3e:	f1 f7       	brne	.-4      	; 0x4e3c <LCD_sendCommand+0x10e>
    4e40:	9c a7       	std	Y+44, r25	; 0x2c
    4e42:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    4e44:	a8 e3       	ldi	r26, 0x38	; 56
    4e46:	b0 e0       	ldi	r27, 0x00	; 0
    4e48:	e8 e3       	ldi	r30, 0x38	; 56
    4e4a:	f0 e0       	ldi	r31, 0x00	; 0
    4e4c:	80 81       	ld	r24, Z
    4e4e:	80 64       	ori	r24, 0x40	; 64
    4e50:	8c 93       	st	X, r24
    4e52:	80 e0       	ldi	r24, 0x00	; 0
    4e54:	90 e0       	ldi	r25, 0x00	; 0
    4e56:	a0 e8       	ldi	r26, 0x80	; 128
    4e58:	bf e3       	ldi	r27, 0x3F	; 63
    4e5a:	8f a3       	std	Y+39, r24	; 0x27
    4e5c:	98 a7       	std	Y+40, r25	; 0x28
    4e5e:	a9 a7       	std	Y+41, r26	; 0x29
    4e60:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4e62:	6f a1       	ldd	r22, Y+39	; 0x27
    4e64:	78 a5       	ldd	r23, Y+40	; 0x28
    4e66:	89 a5       	ldd	r24, Y+41	; 0x29
    4e68:	9a a5       	ldd	r25, Y+42	; 0x2a
    4e6a:	20 e0       	ldi	r18, 0x00	; 0
    4e6c:	30 e0       	ldi	r19, 0x00	; 0
    4e6e:	4a ef       	ldi	r20, 0xFA	; 250
    4e70:	54 e4       	ldi	r21, 0x44	; 68
    4e72:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    4e76:	dc 01       	movw	r26, r24
    4e78:	cb 01       	movw	r24, r22
    4e7a:	8b a3       	std	Y+35, r24	; 0x23
    4e7c:	9c a3       	std	Y+36, r25	; 0x24
    4e7e:	ad a3       	std	Y+37, r26	; 0x25
    4e80:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4e82:	6b a1       	ldd	r22, Y+35	; 0x23
    4e84:	7c a1       	ldd	r23, Y+36	; 0x24
    4e86:	8d a1       	ldd	r24, Y+37	; 0x25
    4e88:	9e a1       	ldd	r25, Y+38	; 0x26
    4e8a:	20 e0       	ldi	r18, 0x00	; 0
    4e8c:	30 e0       	ldi	r19, 0x00	; 0
    4e8e:	40 e8       	ldi	r20, 0x80	; 128
    4e90:	5f e3       	ldi	r21, 0x3F	; 63
    4e92:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    4e96:	88 23       	and	r24, r24
    4e98:	2c f4       	brge	.+10     	; 0x4ea4 <LCD_sendCommand+0x176>
		__ticks = 1;
    4e9a:	81 e0       	ldi	r24, 0x01	; 1
    4e9c:	90 e0       	ldi	r25, 0x00	; 0
    4e9e:	9a a3       	std	Y+34, r25	; 0x22
    4ea0:	89 a3       	std	Y+33, r24	; 0x21
    4ea2:	3f c0       	rjmp	.+126    	; 0x4f22 <LCD_sendCommand+0x1f4>
	else if (__tmp > 65535)
    4ea4:	6b a1       	ldd	r22, Y+35	; 0x23
    4ea6:	7c a1       	ldd	r23, Y+36	; 0x24
    4ea8:	8d a1       	ldd	r24, Y+37	; 0x25
    4eaa:	9e a1       	ldd	r25, Y+38	; 0x26
    4eac:	20 e0       	ldi	r18, 0x00	; 0
    4eae:	3f ef       	ldi	r19, 0xFF	; 255
    4eb0:	4f e7       	ldi	r20, 0x7F	; 127
    4eb2:	57 e4       	ldi	r21, 0x47	; 71
    4eb4:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    4eb8:	18 16       	cp	r1, r24
    4eba:	4c f5       	brge	.+82     	; 0x4f0e <LCD_sendCommand+0x1e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4ebc:	6f a1       	ldd	r22, Y+39	; 0x27
    4ebe:	78 a5       	ldd	r23, Y+40	; 0x28
    4ec0:	89 a5       	ldd	r24, Y+41	; 0x29
    4ec2:	9a a5       	ldd	r25, Y+42	; 0x2a
    4ec4:	20 e0       	ldi	r18, 0x00	; 0
    4ec6:	30 e0       	ldi	r19, 0x00	; 0
    4ec8:	40 e2       	ldi	r20, 0x20	; 32
    4eca:	51 e4       	ldi	r21, 0x41	; 65
    4ecc:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    4ed0:	dc 01       	movw	r26, r24
    4ed2:	cb 01       	movw	r24, r22
    4ed4:	bc 01       	movw	r22, r24
    4ed6:	cd 01       	movw	r24, r26
    4ed8:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    4edc:	dc 01       	movw	r26, r24
    4ede:	cb 01       	movw	r24, r22
    4ee0:	9a a3       	std	Y+34, r25	; 0x22
    4ee2:	89 a3       	std	Y+33, r24	; 0x21
    4ee4:	0f c0       	rjmp	.+30     	; 0x4f04 <LCD_sendCommand+0x1d6>
    4ee6:	88 ec       	ldi	r24, 0xC8	; 200
    4ee8:	90 e0       	ldi	r25, 0x00	; 0
    4eea:	98 a3       	std	Y+32, r25	; 0x20
    4eec:	8f 8f       	std	Y+31, r24	; 0x1f
    4eee:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4ef0:	98 a1       	ldd	r25, Y+32	; 0x20
    4ef2:	01 97       	sbiw	r24, 0x01	; 1
    4ef4:	f1 f7       	brne	.-4      	; 0x4ef2 <LCD_sendCommand+0x1c4>
    4ef6:	98 a3       	std	Y+32, r25	; 0x20
    4ef8:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4efa:	89 a1       	ldd	r24, Y+33	; 0x21
    4efc:	9a a1       	ldd	r25, Y+34	; 0x22
    4efe:	01 97       	sbiw	r24, 0x01	; 1
    4f00:	9a a3       	std	Y+34, r25	; 0x22
    4f02:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4f04:	89 a1       	ldd	r24, Y+33	; 0x21
    4f06:	9a a1       	ldd	r25, Y+34	; 0x22
    4f08:	00 97       	sbiw	r24, 0x00	; 0
    4f0a:	69 f7       	brne	.-38     	; 0x4ee6 <LCD_sendCommand+0x1b8>
    4f0c:	14 c0       	rjmp	.+40     	; 0x4f36 <LCD_sendCommand+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4f0e:	6b a1       	ldd	r22, Y+35	; 0x23
    4f10:	7c a1       	ldd	r23, Y+36	; 0x24
    4f12:	8d a1       	ldd	r24, Y+37	; 0x25
    4f14:	9e a1       	ldd	r25, Y+38	; 0x26
    4f16:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    4f1a:	dc 01       	movw	r26, r24
    4f1c:	cb 01       	movw	r24, r22
    4f1e:	9a a3       	std	Y+34, r25	; 0x22
    4f20:	89 a3       	std	Y+33, r24	; 0x21
    4f22:	89 a1       	ldd	r24, Y+33	; 0x21
    4f24:	9a a1       	ldd	r25, Y+34	; 0x22
    4f26:	9e 8f       	std	Y+30, r25	; 0x1e
    4f28:	8d 8f       	std	Y+29, r24	; 0x1d
    4f2a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4f2c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4f2e:	01 97       	sbiw	r24, 0x01	; 1
    4f30:	f1 f7       	brne	.-4      	; 0x4f2e <LCD_sendCommand+0x200>
    4f32:	9e 8f       	std	Y+30, r25	; 0x1e
    4f34:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
    4f36:	e5 e3       	ldi	r30, 0x35	; 53
    4f38:	f0 e0       	ldi	r31, 0x00	; 0
    4f3a:	89 ad       	ldd	r24, Y+57	; 0x39
    4f3c:	80 83       	st	Z, r24
    4f3e:	80 e0       	ldi	r24, 0x00	; 0
    4f40:	90 e0       	ldi	r25, 0x00	; 0
    4f42:	a0 e8       	ldi	r26, 0x80	; 128
    4f44:	bf e3       	ldi	r27, 0x3F	; 63
    4f46:	89 8f       	std	Y+25, r24	; 0x19
    4f48:	9a 8f       	std	Y+26, r25	; 0x1a
    4f4a:	ab 8f       	std	Y+27, r26	; 0x1b
    4f4c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4f4e:	69 8d       	ldd	r22, Y+25	; 0x19
    4f50:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4f52:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4f54:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4f56:	20 e0       	ldi	r18, 0x00	; 0
    4f58:	30 e0       	ldi	r19, 0x00	; 0
    4f5a:	4a ef       	ldi	r20, 0xFA	; 250
    4f5c:	54 e4       	ldi	r21, 0x44	; 68
    4f5e:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    4f62:	dc 01       	movw	r26, r24
    4f64:	cb 01       	movw	r24, r22
    4f66:	8d 8b       	std	Y+21, r24	; 0x15
    4f68:	9e 8b       	std	Y+22, r25	; 0x16
    4f6a:	af 8b       	std	Y+23, r26	; 0x17
    4f6c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4f6e:	6d 89       	ldd	r22, Y+21	; 0x15
    4f70:	7e 89       	ldd	r23, Y+22	; 0x16
    4f72:	8f 89       	ldd	r24, Y+23	; 0x17
    4f74:	98 8d       	ldd	r25, Y+24	; 0x18
    4f76:	20 e0       	ldi	r18, 0x00	; 0
    4f78:	30 e0       	ldi	r19, 0x00	; 0
    4f7a:	40 e8       	ldi	r20, 0x80	; 128
    4f7c:	5f e3       	ldi	r21, 0x3F	; 63
    4f7e:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    4f82:	88 23       	and	r24, r24
    4f84:	2c f4       	brge	.+10     	; 0x4f90 <LCD_sendCommand+0x262>
		__ticks = 1;
    4f86:	81 e0       	ldi	r24, 0x01	; 1
    4f88:	90 e0       	ldi	r25, 0x00	; 0
    4f8a:	9c 8b       	std	Y+20, r25	; 0x14
    4f8c:	8b 8b       	std	Y+19, r24	; 0x13
    4f8e:	3f c0       	rjmp	.+126    	; 0x500e <LCD_sendCommand+0x2e0>
	else if (__tmp > 65535)
    4f90:	6d 89       	ldd	r22, Y+21	; 0x15
    4f92:	7e 89       	ldd	r23, Y+22	; 0x16
    4f94:	8f 89       	ldd	r24, Y+23	; 0x17
    4f96:	98 8d       	ldd	r25, Y+24	; 0x18
    4f98:	20 e0       	ldi	r18, 0x00	; 0
    4f9a:	3f ef       	ldi	r19, 0xFF	; 255
    4f9c:	4f e7       	ldi	r20, 0x7F	; 127
    4f9e:	57 e4       	ldi	r21, 0x47	; 71
    4fa0:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    4fa4:	18 16       	cp	r1, r24
    4fa6:	4c f5       	brge	.+82     	; 0x4ffa <LCD_sendCommand+0x2cc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4fa8:	69 8d       	ldd	r22, Y+25	; 0x19
    4faa:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4fac:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4fae:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4fb0:	20 e0       	ldi	r18, 0x00	; 0
    4fb2:	30 e0       	ldi	r19, 0x00	; 0
    4fb4:	40 e2       	ldi	r20, 0x20	; 32
    4fb6:	51 e4       	ldi	r21, 0x41	; 65
    4fb8:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    4fbc:	dc 01       	movw	r26, r24
    4fbe:	cb 01       	movw	r24, r22
    4fc0:	bc 01       	movw	r22, r24
    4fc2:	cd 01       	movw	r24, r26
    4fc4:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    4fc8:	dc 01       	movw	r26, r24
    4fca:	cb 01       	movw	r24, r22
    4fcc:	9c 8b       	std	Y+20, r25	; 0x14
    4fce:	8b 8b       	std	Y+19, r24	; 0x13
    4fd0:	0f c0       	rjmp	.+30     	; 0x4ff0 <LCD_sendCommand+0x2c2>
    4fd2:	88 ec       	ldi	r24, 0xC8	; 200
    4fd4:	90 e0       	ldi	r25, 0x00	; 0
    4fd6:	9a 8b       	std	Y+18, r25	; 0x12
    4fd8:	89 8b       	std	Y+17, r24	; 0x11
    4fda:	89 89       	ldd	r24, Y+17	; 0x11
    4fdc:	9a 89       	ldd	r25, Y+18	; 0x12
    4fde:	01 97       	sbiw	r24, 0x01	; 1
    4fe0:	f1 f7       	brne	.-4      	; 0x4fde <LCD_sendCommand+0x2b0>
    4fe2:	9a 8b       	std	Y+18, r25	; 0x12
    4fe4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4fe6:	8b 89       	ldd	r24, Y+19	; 0x13
    4fe8:	9c 89       	ldd	r25, Y+20	; 0x14
    4fea:	01 97       	sbiw	r24, 0x01	; 1
    4fec:	9c 8b       	std	Y+20, r25	; 0x14
    4fee:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ff0:	8b 89       	ldd	r24, Y+19	; 0x13
    4ff2:	9c 89       	ldd	r25, Y+20	; 0x14
    4ff4:	00 97       	sbiw	r24, 0x00	; 0
    4ff6:	69 f7       	brne	.-38     	; 0x4fd2 <LCD_sendCommand+0x2a4>
    4ff8:	14 c0       	rjmp	.+40     	; 0x5022 <LCD_sendCommand+0x2f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ffa:	6d 89       	ldd	r22, Y+21	; 0x15
    4ffc:	7e 89       	ldd	r23, Y+22	; 0x16
    4ffe:	8f 89       	ldd	r24, Y+23	; 0x17
    5000:	98 8d       	ldd	r25, Y+24	; 0x18
    5002:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    5006:	dc 01       	movw	r26, r24
    5008:	cb 01       	movw	r24, r22
    500a:	9c 8b       	std	Y+20, r25	; 0x14
    500c:	8b 8b       	std	Y+19, r24	; 0x13
    500e:	8b 89       	ldd	r24, Y+19	; 0x13
    5010:	9c 89       	ldd	r25, Y+20	; 0x14
    5012:	98 8b       	std	Y+16, r25	; 0x10
    5014:	8f 87       	std	Y+15, r24	; 0x0f
    5016:	8f 85       	ldd	r24, Y+15	; 0x0f
    5018:	98 89       	ldd	r25, Y+16	; 0x10
    501a:	01 97       	sbiw	r24, 0x01	; 1
    501c:	f1 f7       	brne	.-4      	; 0x501a <LCD_sendCommand+0x2ec>
    501e:	98 8b       	std	Y+16, r25	; 0x10
    5020:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    5022:	a8 e3       	ldi	r26, 0x38	; 56
    5024:	b0 e0       	ldi	r27, 0x00	; 0
    5026:	e8 e3       	ldi	r30, 0x38	; 56
    5028:	f0 e0       	ldi	r31, 0x00	; 0
    502a:	80 81       	ld	r24, Z
    502c:	8f 7b       	andi	r24, 0xBF	; 191
    502e:	8c 93       	st	X, r24
    5030:	80 e0       	ldi	r24, 0x00	; 0
    5032:	90 e0       	ldi	r25, 0x00	; 0
    5034:	a0 e8       	ldi	r26, 0x80	; 128
    5036:	bf e3       	ldi	r27, 0x3F	; 63
    5038:	8b 87       	std	Y+11, r24	; 0x0b
    503a:	9c 87       	std	Y+12, r25	; 0x0c
    503c:	ad 87       	std	Y+13, r26	; 0x0d
    503e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5040:	6b 85       	ldd	r22, Y+11	; 0x0b
    5042:	7c 85       	ldd	r23, Y+12	; 0x0c
    5044:	8d 85       	ldd	r24, Y+13	; 0x0d
    5046:	9e 85       	ldd	r25, Y+14	; 0x0e
    5048:	20 e0       	ldi	r18, 0x00	; 0
    504a:	30 e0       	ldi	r19, 0x00	; 0
    504c:	4a ef       	ldi	r20, 0xFA	; 250
    504e:	54 e4       	ldi	r21, 0x44	; 68
    5050:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    5054:	dc 01       	movw	r26, r24
    5056:	cb 01       	movw	r24, r22
    5058:	8f 83       	std	Y+7, r24	; 0x07
    505a:	98 87       	std	Y+8, r25	; 0x08
    505c:	a9 87       	std	Y+9, r26	; 0x09
    505e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5060:	6f 81       	ldd	r22, Y+7	; 0x07
    5062:	78 85       	ldd	r23, Y+8	; 0x08
    5064:	89 85       	ldd	r24, Y+9	; 0x09
    5066:	9a 85       	ldd	r25, Y+10	; 0x0a
    5068:	20 e0       	ldi	r18, 0x00	; 0
    506a:	30 e0       	ldi	r19, 0x00	; 0
    506c:	40 e8       	ldi	r20, 0x80	; 128
    506e:	5f e3       	ldi	r21, 0x3F	; 63
    5070:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    5074:	88 23       	and	r24, r24
    5076:	2c f4       	brge	.+10     	; 0x5082 <LCD_sendCommand+0x354>
		__ticks = 1;
    5078:	81 e0       	ldi	r24, 0x01	; 1
    507a:	90 e0       	ldi	r25, 0x00	; 0
    507c:	9e 83       	std	Y+6, r25	; 0x06
    507e:	8d 83       	std	Y+5, r24	; 0x05
    5080:	3f c0       	rjmp	.+126    	; 0x5100 <LCD_sendCommand+0x3d2>
	else if (__tmp > 65535)
    5082:	6f 81       	ldd	r22, Y+7	; 0x07
    5084:	78 85       	ldd	r23, Y+8	; 0x08
    5086:	89 85       	ldd	r24, Y+9	; 0x09
    5088:	9a 85       	ldd	r25, Y+10	; 0x0a
    508a:	20 e0       	ldi	r18, 0x00	; 0
    508c:	3f ef       	ldi	r19, 0xFF	; 255
    508e:	4f e7       	ldi	r20, 0x7F	; 127
    5090:	57 e4       	ldi	r21, 0x47	; 71
    5092:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    5096:	18 16       	cp	r1, r24
    5098:	4c f5       	brge	.+82     	; 0x50ec <LCD_sendCommand+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    509a:	6b 85       	ldd	r22, Y+11	; 0x0b
    509c:	7c 85       	ldd	r23, Y+12	; 0x0c
    509e:	8d 85       	ldd	r24, Y+13	; 0x0d
    50a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    50a2:	20 e0       	ldi	r18, 0x00	; 0
    50a4:	30 e0       	ldi	r19, 0x00	; 0
    50a6:	40 e2       	ldi	r20, 0x20	; 32
    50a8:	51 e4       	ldi	r21, 0x41	; 65
    50aa:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    50ae:	dc 01       	movw	r26, r24
    50b0:	cb 01       	movw	r24, r22
    50b2:	bc 01       	movw	r22, r24
    50b4:	cd 01       	movw	r24, r26
    50b6:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    50ba:	dc 01       	movw	r26, r24
    50bc:	cb 01       	movw	r24, r22
    50be:	9e 83       	std	Y+6, r25	; 0x06
    50c0:	8d 83       	std	Y+5, r24	; 0x05
    50c2:	0f c0       	rjmp	.+30     	; 0x50e2 <LCD_sendCommand+0x3b4>
    50c4:	88 ec       	ldi	r24, 0xC8	; 200
    50c6:	90 e0       	ldi	r25, 0x00	; 0
    50c8:	9c 83       	std	Y+4, r25	; 0x04
    50ca:	8b 83       	std	Y+3, r24	; 0x03
    50cc:	8b 81       	ldd	r24, Y+3	; 0x03
    50ce:	9c 81       	ldd	r25, Y+4	; 0x04
    50d0:	01 97       	sbiw	r24, 0x01	; 1
    50d2:	f1 f7       	brne	.-4      	; 0x50d0 <LCD_sendCommand+0x3a2>
    50d4:	9c 83       	std	Y+4, r25	; 0x04
    50d6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    50d8:	8d 81       	ldd	r24, Y+5	; 0x05
    50da:	9e 81       	ldd	r25, Y+6	; 0x06
    50dc:	01 97       	sbiw	r24, 0x01	; 1
    50de:	9e 83       	std	Y+6, r25	; 0x06
    50e0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    50e2:	8d 81       	ldd	r24, Y+5	; 0x05
    50e4:	9e 81       	ldd	r25, Y+6	; 0x06
    50e6:	00 97       	sbiw	r24, 0x00	; 0
    50e8:	69 f7       	brne	.-38     	; 0x50c4 <LCD_sendCommand+0x396>
    50ea:	14 c0       	rjmp	.+40     	; 0x5114 <LCD_sendCommand+0x3e6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    50ec:	6f 81       	ldd	r22, Y+7	; 0x07
    50ee:	78 85       	ldd	r23, Y+8	; 0x08
    50f0:	89 85       	ldd	r24, Y+9	; 0x09
    50f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    50f4:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    50f8:	dc 01       	movw	r26, r24
    50fa:	cb 01       	movw	r24, r22
    50fc:	9e 83       	std	Y+6, r25	; 0x06
    50fe:	8d 83       	std	Y+5, r24	; 0x05
    5100:	8d 81       	ldd	r24, Y+5	; 0x05
    5102:	9e 81       	ldd	r25, Y+6	; 0x06
    5104:	9a 83       	std	Y+2, r25	; 0x02
    5106:	89 83       	std	Y+1, r24	; 0x01
    5108:	89 81       	ldd	r24, Y+1	; 0x01
    510a:	9a 81       	ldd	r25, Y+2	; 0x02
    510c:	01 97       	sbiw	r24, 0x01	; 1
    510e:	f1 f7       	brne	.-4      	; 0x510c <LCD_sendCommand+0x3de>
    5110:	9a 83       	std	Y+2, r25	; 0x02
    5112:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
}
    5114:	e9 96       	adiw	r28, 0x39	; 57
    5116:	0f b6       	in	r0, 0x3f	; 63
    5118:	f8 94       	cli
    511a:	de bf       	out	0x3e, r29	; 62
    511c:	0f be       	out	0x3f, r0	; 63
    511e:	cd bf       	out	0x3d, r28	; 61
    5120:	cf 91       	pop	r28
    5122:	df 91       	pop	r29
    5124:	08 95       	ret

00005126 <LCD_displayCharacter>:

void LCD_displayCharacter(uint8 data)
{
    5126:	df 93       	push	r29
    5128:	cf 93       	push	r28
    512a:	cd b7       	in	r28, 0x3d	; 61
    512c:	de b7       	in	r29, 0x3e	; 62
    512e:	e9 97       	sbiw	r28, 0x39	; 57
    5130:	0f b6       	in	r0, 0x3f	; 63
    5132:	f8 94       	cli
    5134:	de bf       	out	0x3e, r29	; 62
    5136:	0f be       	out	0x3f, r0	; 63
    5138:	cd bf       	out	0x3d, r28	; 61
    513a:	89 af       	std	Y+57, r24	; 0x39
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    513c:	a8 e3       	ldi	r26, 0x38	; 56
    513e:	b0 e0       	ldi	r27, 0x00	; 0
    5140:	e8 e3       	ldi	r30, 0x38	; 56
    5142:	f0 e0       	ldi	r31, 0x00	; 0
    5144:	80 81       	ld	r24, Z
    5146:	80 61       	ori	r24, 0x10	; 16
    5148:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    514a:	a8 e3       	ldi	r26, 0x38	; 56
    514c:	b0 e0       	ldi	r27, 0x00	; 0
    514e:	e8 e3       	ldi	r30, 0x38	; 56
    5150:	f0 e0       	ldi	r31, 0x00	; 0
    5152:	80 81       	ld	r24, Z
    5154:	8f 7d       	andi	r24, 0xDF	; 223
    5156:	8c 93       	st	X, r24
    5158:	80 e0       	ldi	r24, 0x00	; 0
    515a:	90 e0       	ldi	r25, 0x00	; 0
    515c:	a0 e8       	ldi	r26, 0x80	; 128
    515e:	bf e3       	ldi	r27, 0x3F	; 63
    5160:	8d ab       	std	Y+53, r24	; 0x35
    5162:	9e ab       	std	Y+54, r25	; 0x36
    5164:	af ab       	std	Y+55, r26	; 0x37
    5166:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5168:	6d a9       	ldd	r22, Y+53	; 0x35
    516a:	7e a9       	ldd	r23, Y+54	; 0x36
    516c:	8f a9       	ldd	r24, Y+55	; 0x37
    516e:	98 ad       	ldd	r25, Y+56	; 0x38
    5170:	20 e0       	ldi	r18, 0x00	; 0
    5172:	30 e0       	ldi	r19, 0x00	; 0
    5174:	4a ef       	ldi	r20, 0xFA	; 250
    5176:	54 e4       	ldi	r21, 0x44	; 68
    5178:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    517c:	dc 01       	movw	r26, r24
    517e:	cb 01       	movw	r24, r22
    5180:	89 ab       	std	Y+49, r24	; 0x31
    5182:	9a ab       	std	Y+50, r25	; 0x32
    5184:	ab ab       	std	Y+51, r26	; 0x33
    5186:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    5188:	69 a9       	ldd	r22, Y+49	; 0x31
    518a:	7a a9       	ldd	r23, Y+50	; 0x32
    518c:	8b a9       	ldd	r24, Y+51	; 0x33
    518e:	9c a9       	ldd	r25, Y+52	; 0x34
    5190:	20 e0       	ldi	r18, 0x00	; 0
    5192:	30 e0       	ldi	r19, 0x00	; 0
    5194:	40 e8       	ldi	r20, 0x80	; 128
    5196:	5f e3       	ldi	r21, 0x3F	; 63
    5198:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    519c:	88 23       	and	r24, r24
    519e:	2c f4       	brge	.+10     	; 0x51aa <LCD_displayCharacter+0x84>
		__ticks = 1;
    51a0:	81 e0       	ldi	r24, 0x01	; 1
    51a2:	90 e0       	ldi	r25, 0x00	; 0
    51a4:	98 ab       	std	Y+48, r25	; 0x30
    51a6:	8f a7       	std	Y+47, r24	; 0x2f
    51a8:	3f c0       	rjmp	.+126    	; 0x5228 <LCD_displayCharacter+0x102>
	else if (__tmp > 65535)
    51aa:	69 a9       	ldd	r22, Y+49	; 0x31
    51ac:	7a a9       	ldd	r23, Y+50	; 0x32
    51ae:	8b a9       	ldd	r24, Y+51	; 0x33
    51b0:	9c a9       	ldd	r25, Y+52	; 0x34
    51b2:	20 e0       	ldi	r18, 0x00	; 0
    51b4:	3f ef       	ldi	r19, 0xFF	; 255
    51b6:	4f e7       	ldi	r20, 0x7F	; 127
    51b8:	57 e4       	ldi	r21, 0x47	; 71
    51ba:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    51be:	18 16       	cp	r1, r24
    51c0:	4c f5       	brge	.+82     	; 0x5214 <LCD_displayCharacter+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    51c2:	6d a9       	ldd	r22, Y+53	; 0x35
    51c4:	7e a9       	ldd	r23, Y+54	; 0x36
    51c6:	8f a9       	ldd	r24, Y+55	; 0x37
    51c8:	98 ad       	ldd	r25, Y+56	; 0x38
    51ca:	20 e0       	ldi	r18, 0x00	; 0
    51cc:	30 e0       	ldi	r19, 0x00	; 0
    51ce:	40 e2       	ldi	r20, 0x20	; 32
    51d0:	51 e4       	ldi	r21, 0x41	; 65
    51d2:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    51d6:	dc 01       	movw	r26, r24
    51d8:	cb 01       	movw	r24, r22
    51da:	bc 01       	movw	r22, r24
    51dc:	cd 01       	movw	r24, r26
    51de:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    51e2:	dc 01       	movw	r26, r24
    51e4:	cb 01       	movw	r24, r22
    51e6:	98 ab       	std	Y+48, r25	; 0x30
    51e8:	8f a7       	std	Y+47, r24	; 0x2f
    51ea:	0f c0       	rjmp	.+30     	; 0x520a <LCD_displayCharacter+0xe4>
    51ec:	88 ec       	ldi	r24, 0xC8	; 200
    51ee:	90 e0       	ldi	r25, 0x00	; 0
    51f0:	9e a7       	std	Y+46, r25	; 0x2e
    51f2:	8d a7       	std	Y+45, r24	; 0x2d
    51f4:	8d a5       	ldd	r24, Y+45	; 0x2d
    51f6:	9e a5       	ldd	r25, Y+46	; 0x2e
    51f8:	01 97       	sbiw	r24, 0x01	; 1
    51fa:	f1 f7       	brne	.-4      	; 0x51f8 <LCD_displayCharacter+0xd2>
    51fc:	9e a7       	std	Y+46, r25	; 0x2e
    51fe:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5200:	8f a5       	ldd	r24, Y+47	; 0x2f
    5202:	98 a9       	ldd	r25, Y+48	; 0x30
    5204:	01 97       	sbiw	r24, 0x01	; 1
    5206:	98 ab       	std	Y+48, r25	; 0x30
    5208:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    520a:	8f a5       	ldd	r24, Y+47	; 0x2f
    520c:	98 a9       	ldd	r25, Y+48	; 0x30
    520e:	00 97       	sbiw	r24, 0x00	; 0
    5210:	69 f7       	brne	.-38     	; 0x51ec <LCD_displayCharacter+0xc6>
    5212:	14 c0       	rjmp	.+40     	; 0x523c <LCD_displayCharacter+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5214:	69 a9       	ldd	r22, Y+49	; 0x31
    5216:	7a a9       	ldd	r23, Y+50	; 0x32
    5218:	8b a9       	ldd	r24, Y+51	; 0x33
    521a:	9c a9       	ldd	r25, Y+52	; 0x34
    521c:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    5220:	dc 01       	movw	r26, r24
    5222:	cb 01       	movw	r24, r22
    5224:	98 ab       	std	Y+48, r25	; 0x30
    5226:	8f a7       	std	Y+47, r24	; 0x2f
    5228:	8f a5       	ldd	r24, Y+47	; 0x2f
    522a:	98 a9       	ldd	r25, Y+48	; 0x30
    522c:	9c a7       	std	Y+44, r25	; 0x2c
    522e:	8b a7       	std	Y+43, r24	; 0x2b
    5230:	8b a5       	ldd	r24, Y+43	; 0x2b
    5232:	9c a5       	ldd	r25, Y+44	; 0x2c
    5234:	01 97       	sbiw	r24, 0x01	; 1
    5236:	f1 f7       	brne	.-4      	; 0x5234 <LCD_displayCharacter+0x10e>
    5238:	9c a7       	std	Y+44, r25	; 0x2c
    523a:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    523c:	a8 e3       	ldi	r26, 0x38	; 56
    523e:	b0 e0       	ldi	r27, 0x00	; 0
    5240:	e8 e3       	ldi	r30, 0x38	; 56
    5242:	f0 e0       	ldi	r31, 0x00	; 0
    5244:	80 81       	ld	r24, Z
    5246:	80 64       	ori	r24, 0x40	; 64
    5248:	8c 93       	st	X, r24
    524a:	80 e0       	ldi	r24, 0x00	; 0
    524c:	90 e0       	ldi	r25, 0x00	; 0
    524e:	a0 e8       	ldi	r26, 0x80	; 128
    5250:	bf e3       	ldi	r27, 0x3F	; 63
    5252:	8f a3       	std	Y+39, r24	; 0x27
    5254:	98 a7       	std	Y+40, r25	; 0x28
    5256:	a9 a7       	std	Y+41, r26	; 0x29
    5258:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    525a:	6f a1       	ldd	r22, Y+39	; 0x27
    525c:	78 a5       	ldd	r23, Y+40	; 0x28
    525e:	89 a5       	ldd	r24, Y+41	; 0x29
    5260:	9a a5       	ldd	r25, Y+42	; 0x2a
    5262:	20 e0       	ldi	r18, 0x00	; 0
    5264:	30 e0       	ldi	r19, 0x00	; 0
    5266:	4a ef       	ldi	r20, 0xFA	; 250
    5268:	54 e4       	ldi	r21, 0x44	; 68
    526a:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    526e:	dc 01       	movw	r26, r24
    5270:	cb 01       	movw	r24, r22
    5272:	8b a3       	std	Y+35, r24	; 0x23
    5274:	9c a3       	std	Y+36, r25	; 0x24
    5276:	ad a3       	std	Y+37, r26	; 0x25
    5278:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    527a:	6b a1       	ldd	r22, Y+35	; 0x23
    527c:	7c a1       	ldd	r23, Y+36	; 0x24
    527e:	8d a1       	ldd	r24, Y+37	; 0x25
    5280:	9e a1       	ldd	r25, Y+38	; 0x26
    5282:	20 e0       	ldi	r18, 0x00	; 0
    5284:	30 e0       	ldi	r19, 0x00	; 0
    5286:	40 e8       	ldi	r20, 0x80	; 128
    5288:	5f e3       	ldi	r21, 0x3F	; 63
    528a:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    528e:	88 23       	and	r24, r24
    5290:	2c f4       	brge	.+10     	; 0x529c <LCD_displayCharacter+0x176>
		__ticks = 1;
    5292:	81 e0       	ldi	r24, 0x01	; 1
    5294:	90 e0       	ldi	r25, 0x00	; 0
    5296:	9a a3       	std	Y+34, r25	; 0x22
    5298:	89 a3       	std	Y+33, r24	; 0x21
    529a:	3f c0       	rjmp	.+126    	; 0x531a <LCD_displayCharacter+0x1f4>
	else if (__tmp > 65535)
    529c:	6b a1       	ldd	r22, Y+35	; 0x23
    529e:	7c a1       	ldd	r23, Y+36	; 0x24
    52a0:	8d a1       	ldd	r24, Y+37	; 0x25
    52a2:	9e a1       	ldd	r25, Y+38	; 0x26
    52a4:	20 e0       	ldi	r18, 0x00	; 0
    52a6:	3f ef       	ldi	r19, 0xFF	; 255
    52a8:	4f e7       	ldi	r20, 0x7F	; 127
    52aa:	57 e4       	ldi	r21, 0x47	; 71
    52ac:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    52b0:	18 16       	cp	r1, r24
    52b2:	4c f5       	brge	.+82     	; 0x5306 <LCD_displayCharacter+0x1e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    52b4:	6f a1       	ldd	r22, Y+39	; 0x27
    52b6:	78 a5       	ldd	r23, Y+40	; 0x28
    52b8:	89 a5       	ldd	r24, Y+41	; 0x29
    52ba:	9a a5       	ldd	r25, Y+42	; 0x2a
    52bc:	20 e0       	ldi	r18, 0x00	; 0
    52be:	30 e0       	ldi	r19, 0x00	; 0
    52c0:	40 e2       	ldi	r20, 0x20	; 32
    52c2:	51 e4       	ldi	r21, 0x41	; 65
    52c4:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    52c8:	dc 01       	movw	r26, r24
    52ca:	cb 01       	movw	r24, r22
    52cc:	bc 01       	movw	r22, r24
    52ce:	cd 01       	movw	r24, r26
    52d0:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    52d4:	dc 01       	movw	r26, r24
    52d6:	cb 01       	movw	r24, r22
    52d8:	9a a3       	std	Y+34, r25	; 0x22
    52da:	89 a3       	std	Y+33, r24	; 0x21
    52dc:	0f c0       	rjmp	.+30     	; 0x52fc <LCD_displayCharacter+0x1d6>
    52de:	88 ec       	ldi	r24, 0xC8	; 200
    52e0:	90 e0       	ldi	r25, 0x00	; 0
    52e2:	98 a3       	std	Y+32, r25	; 0x20
    52e4:	8f 8f       	std	Y+31, r24	; 0x1f
    52e6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    52e8:	98 a1       	ldd	r25, Y+32	; 0x20
    52ea:	01 97       	sbiw	r24, 0x01	; 1
    52ec:	f1 f7       	brne	.-4      	; 0x52ea <LCD_displayCharacter+0x1c4>
    52ee:	98 a3       	std	Y+32, r25	; 0x20
    52f0:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    52f2:	89 a1       	ldd	r24, Y+33	; 0x21
    52f4:	9a a1       	ldd	r25, Y+34	; 0x22
    52f6:	01 97       	sbiw	r24, 0x01	; 1
    52f8:	9a a3       	std	Y+34, r25	; 0x22
    52fa:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    52fc:	89 a1       	ldd	r24, Y+33	; 0x21
    52fe:	9a a1       	ldd	r25, Y+34	; 0x22
    5300:	00 97       	sbiw	r24, 0x00	; 0
    5302:	69 f7       	brne	.-38     	; 0x52de <LCD_displayCharacter+0x1b8>
    5304:	14 c0       	rjmp	.+40     	; 0x532e <LCD_displayCharacter+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5306:	6b a1       	ldd	r22, Y+35	; 0x23
    5308:	7c a1       	ldd	r23, Y+36	; 0x24
    530a:	8d a1       	ldd	r24, Y+37	; 0x25
    530c:	9e a1       	ldd	r25, Y+38	; 0x26
    530e:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    5312:	dc 01       	movw	r26, r24
    5314:	cb 01       	movw	r24, r22
    5316:	9a a3       	std	Y+34, r25	; 0x22
    5318:	89 a3       	std	Y+33, r24	; 0x21
    531a:	89 a1       	ldd	r24, Y+33	; 0x21
    531c:	9a a1       	ldd	r25, Y+34	; 0x22
    531e:	9e 8f       	std	Y+30, r25	; 0x1e
    5320:	8d 8f       	std	Y+29, r24	; 0x1d
    5322:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5324:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5326:	01 97       	sbiw	r24, 0x01	; 1
    5328:	f1 f7       	brne	.-4      	; 0x5326 <LCD_displayCharacter+0x200>
    532a:	9e 8f       	std	Y+30, r25	; 0x1e
    532c:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */
	LCD_DATA_PORT = data; /* out the required data char to the data bus D0 --> D7 */
    532e:	e5 e3       	ldi	r30, 0x35	; 53
    5330:	f0 e0       	ldi	r31, 0x00	; 0
    5332:	89 ad       	ldd	r24, Y+57	; 0x39
    5334:	80 83       	st	Z, r24
    5336:	80 e0       	ldi	r24, 0x00	; 0
    5338:	90 e0       	ldi	r25, 0x00	; 0
    533a:	a0 e8       	ldi	r26, 0x80	; 128
    533c:	bf e3       	ldi	r27, 0x3F	; 63
    533e:	89 8f       	std	Y+25, r24	; 0x19
    5340:	9a 8f       	std	Y+26, r25	; 0x1a
    5342:	ab 8f       	std	Y+27, r26	; 0x1b
    5344:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5346:	69 8d       	ldd	r22, Y+25	; 0x19
    5348:	7a 8d       	ldd	r23, Y+26	; 0x1a
    534a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    534c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    534e:	20 e0       	ldi	r18, 0x00	; 0
    5350:	30 e0       	ldi	r19, 0x00	; 0
    5352:	4a ef       	ldi	r20, 0xFA	; 250
    5354:	54 e4       	ldi	r21, 0x44	; 68
    5356:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    535a:	dc 01       	movw	r26, r24
    535c:	cb 01       	movw	r24, r22
    535e:	8d 8b       	std	Y+21, r24	; 0x15
    5360:	9e 8b       	std	Y+22, r25	; 0x16
    5362:	af 8b       	std	Y+23, r26	; 0x17
    5364:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5366:	6d 89       	ldd	r22, Y+21	; 0x15
    5368:	7e 89       	ldd	r23, Y+22	; 0x16
    536a:	8f 89       	ldd	r24, Y+23	; 0x17
    536c:	98 8d       	ldd	r25, Y+24	; 0x18
    536e:	20 e0       	ldi	r18, 0x00	; 0
    5370:	30 e0       	ldi	r19, 0x00	; 0
    5372:	40 e8       	ldi	r20, 0x80	; 128
    5374:	5f e3       	ldi	r21, 0x3F	; 63
    5376:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    537a:	88 23       	and	r24, r24
    537c:	2c f4       	brge	.+10     	; 0x5388 <LCD_displayCharacter+0x262>
		__ticks = 1;
    537e:	81 e0       	ldi	r24, 0x01	; 1
    5380:	90 e0       	ldi	r25, 0x00	; 0
    5382:	9c 8b       	std	Y+20, r25	; 0x14
    5384:	8b 8b       	std	Y+19, r24	; 0x13
    5386:	3f c0       	rjmp	.+126    	; 0x5406 <LCD_displayCharacter+0x2e0>
	else if (__tmp > 65535)
    5388:	6d 89       	ldd	r22, Y+21	; 0x15
    538a:	7e 89       	ldd	r23, Y+22	; 0x16
    538c:	8f 89       	ldd	r24, Y+23	; 0x17
    538e:	98 8d       	ldd	r25, Y+24	; 0x18
    5390:	20 e0       	ldi	r18, 0x00	; 0
    5392:	3f ef       	ldi	r19, 0xFF	; 255
    5394:	4f e7       	ldi	r20, 0x7F	; 127
    5396:	57 e4       	ldi	r21, 0x47	; 71
    5398:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    539c:	18 16       	cp	r1, r24
    539e:	4c f5       	brge	.+82     	; 0x53f2 <LCD_displayCharacter+0x2cc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    53a0:	69 8d       	ldd	r22, Y+25	; 0x19
    53a2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    53a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    53a6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    53a8:	20 e0       	ldi	r18, 0x00	; 0
    53aa:	30 e0       	ldi	r19, 0x00	; 0
    53ac:	40 e2       	ldi	r20, 0x20	; 32
    53ae:	51 e4       	ldi	r21, 0x41	; 65
    53b0:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    53b4:	dc 01       	movw	r26, r24
    53b6:	cb 01       	movw	r24, r22
    53b8:	bc 01       	movw	r22, r24
    53ba:	cd 01       	movw	r24, r26
    53bc:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    53c0:	dc 01       	movw	r26, r24
    53c2:	cb 01       	movw	r24, r22
    53c4:	9c 8b       	std	Y+20, r25	; 0x14
    53c6:	8b 8b       	std	Y+19, r24	; 0x13
    53c8:	0f c0       	rjmp	.+30     	; 0x53e8 <LCD_displayCharacter+0x2c2>
    53ca:	88 ec       	ldi	r24, 0xC8	; 200
    53cc:	90 e0       	ldi	r25, 0x00	; 0
    53ce:	9a 8b       	std	Y+18, r25	; 0x12
    53d0:	89 8b       	std	Y+17, r24	; 0x11
    53d2:	89 89       	ldd	r24, Y+17	; 0x11
    53d4:	9a 89       	ldd	r25, Y+18	; 0x12
    53d6:	01 97       	sbiw	r24, 0x01	; 1
    53d8:	f1 f7       	brne	.-4      	; 0x53d6 <LCD_displayCharacter+0x2b0>
    53da:	9a 8b       	std	Y+18, r25	; 0x12
    53dc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53de:	8b 89       	ldd	r24, Y+19	; 0x13
    53e0:	9c 89       	ldd	r25, Y+20	; 0x14
    53e2:	01 97       	sbiw	r24, 0x01	; 1
    53e4:	9c 8b       	std	Y+20, r25	; 0x14
    53e6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53e8:	8b 89       	ldd	r24, Y+19	; 0x13
    53ea:	9c 89       	ldd	r25, Y+20	; 0x14
    53ec:	00 97       	sbiw	r24, 0x00	; 0
    53ee:	69 f7       	brne	.-38     	; 0x53ca <LCD_displayCharacter+0x2a4>
    53f0:	14 c0       	rjmp	.+40     	; 0x541a <LCD_displayCharacter+0x2f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53f2:	6d 89       	ldd	r22, Y+21	; 0x15
    53f4:	7e 89       	ldd	r23, Y+22	; 0x16
    53f6:	8f 89       	ldd	r24, Y+23	; 0x17
    53f8:	98 8d       	ldd	r25, Y+24	; 0x18
    53fa:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    53fe:	dc 01       	movw	r26, r24
    5400:	cb 01       	movw	r24, r22
    5402:	9c 8b       	std	Y+20, r25	; 0x14
    5404:	8b 8b       	std	Y+19, r24	; 0x13
    5406:	8b 89       	ldd	r24, Y+19	; 0x13
    5408:	9c 89       	ldd	r25, Y+20	; 0x14
    540a:	98 8b       	std	Y+16, r25	; 0x10
    540c:	8f 87       	std	Y+15, r24	; 0x0f
    540e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5410:	98 89       	ldd	r25, Y+16	; 0x10
    5412:	01 97       	sbiw	r24, 0x01	; 1
    5414:	f1 f7       	brne	.-4      	; 0x5412 <LCD_displayCharacter+0x2ec>
    5416:	98 8b       	std	Y+16, r25	; 0x10
    5418:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    541a:	a8 e3       	ldi	r26, 0x38	; 56
    541c:	b0 e0       	ldi	r27, 0x00	; 0
    541e:	e8 e3       	ldi	r30, 0x38	; 56
    5420:	f0 e0       	ldi	r31, 0x00	; 0
    5422:	80 81       	ld	r24, Z
    5424:	8f 7b       	andi	r24, 0xBF	; 191
    5426:	8c 93       	st	X, r24
    5428:	80 e0       	ldi	r24, 0x00	; 0
    542a:	90 e0       	ldi	r25, 0x00	; 0
    542c:	a0 e8       	ldi	r26, 0x80	; 128
    542e:	bf e3       	ldi	r27, 0x3F	; 63
    5430:	8b 87       	std	Y+11, r24	; 0x0b
    5432:	9c 87       	std	Y+12, r25	; 0x0c
    5434:	ad 87       	std	Y+13, r26	; 0x0d
    5436:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5438:	6b 85       	ldd	r22, Y+11	; 0x0b
    543a:	7c 85       	ldd	r23, Y+12	; 0x0c
    543c:	8d 85       	ldd	r24, Y+13	; 0x0d
    543e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5440:	20 e0       	ldi	r18, 0x00	; 0
    5442:	30 e0       	ldi	r19, 0x00	; 0
    5444:	4a ef       	ldi	r20, 0xFA	; 250
    5446:	54 e4       	ldi	r21, 0x44	; 68
    5448:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    544c:	dc 01       	movw	r26, r24
    544e:	cb 01       	movw	r24, r22
    5450:	8f 83       	std	Y+7, r24	; 0x07
    5452:	98 87       	std	Y+8, r25	; 0x08
    5454:	a9 87       	std	Y+9, r26	; 0x09
    5456:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5458:	6f 81       	ldd	r22, Y+7	; 0x07
    545a:	78 85       	ldd	r23, Y+8	; 0x08
    545c:	89 85       	ldd	r24, Y+9	; 0x09
    545e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5460:	20 e0       	ldi	r18, 0x00	; 0
    5462:	30 e0       	ldi	r19, 0x00	; 0
    5464:	40 e8       	ldi	r20, 0x80	; 128
    5466:	5f e3       	ldi	r21, 0x3F	; 63
    5468:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    546c:	88 23       	and	r24, r24
    546e:	2c f4       	brge	.+10     	; 0x547a <LCD_displayCharacter+0x354>
		__ticks = 1;
    5470:	81 e0       	ldi	r24, 0x01	; 1
    5472:	90 e0       	ldi	r25, 0x00	; 0
    5474:	9e 83       	std	Y+6, r25	; 0x06
    5476:	8d 83       	std	Y+5, r24	; 0x05
    5478:	3f c0       	rjmp	.+126    	; 0x54f8 <LCD_displayCharacter+0x3d2>
	else if (__tmp > 65535)
    547a:	6f 81       	ldd	r22, Y+7	; 0x07
    547c:	78 85       	ldd	r23, Y+8	; 0x08
    547e:	89 85       	ldd	r24, Y+9	; 0x09
    5480:	9a 85       	ldd	r25, Y+10	; 0x0a
    5482:	20 e0       	ldi	r18, 0x00	; 0
    5484:	3f ef       	ldi	r19, 0xFF	; 255
    5486:	4f e7       	ldi	r20, 0x7F	; 127
    5488:	57 e4       	ldi	r21, 0x47	; 71
    548a:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    548e:	18 16       	cp	r1, r24
    5490:	4c f5       	brge	.+82     	; 0x54e4 <LCD_displayCharacter+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5492:	6b 85       	ldd	r22, Y+11	; 0x0b
    5494:	7c 85       	ldd	r23, Y+12	; 0x0c
    5496:	8d 85       	ldd	r24, Y+13	; 0x0d
    5498:	9e 85       	ldd	r25, Y+14	; 0x0e
    549a:	20 e0       	ldi	r18, 0x00	; 0
    549c:	30 e0       	ldi	r19, 0x00	; 0
    549e:	40 e2       	ldi	r20, 0x20	; 32
    54a0:	51 e4       	ldi	r21, 0x41	; 65
    54a2:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    54a6:	dc 01       	movw	r26, r24
    54a8:	cb 01       	movw	r24, r22
    54aa:	bc 01       	movw	r22, r24
    54ac:	cd 01       	movw	r24, r26
    54ae:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    54b2:	dc 01       	movw	r26, r24
    54b4:	cb 01       	movw	r24, r22
    54b6:	9e 83       	std	Y+6, r25	; 0x06
    54b8:	8d 83       	std	Y+5, r24	; 0x05
    54ba:	0f c0       	rjmp	.+30     	; 0x54da <LCD_displayCharacter+0x3b4>
    54bc:	88 ec       	ldi	r24, 0xC8	; 200
    54be:	90 e0       	ldi	r25, 0x00	; 0
    54c0:	9c 83       	std	Y+4, r25	; 0x04
    54c2:	8b 83       	std	Y+3, r24	; 0x03
    54c4:	8b 81       	ldd	r24, Y+3	; 0x03
    54c6:	9c 81       	ldd	r25, Y+4	; 0x04
    54c8:	01 97       	sbiw	r24, 0x01	; 1
    54ca:	f1 f7       	brne	.-4      	; 0x54c8 <LCD_displayCharacter+0x3a2>
    54cc:	9c 83       	std	Y+4, r25	; 0x04
    54ce:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    54d0:	8d 81       	ldd	r24, Y+5	; 0x05
    54d2:	9e 81       	ldd	r25, Y+6	; 0x06
    54d4:	01 97       	sbiw	r24, 0x01	; 1
    54d6:	9e 83       	std	Y+6, r25	; 0x06
    54d8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54da:	8d 81       	ldd	r24, Y+5	; 0x05
    54dc:	9e 81       	ldd	r25, Y+6	; 0x06
    54de:	00 97       	sbiw	r24, 0x00	; 0
    54e0:	69 f7       	brne	.-38     	; 0x54bc <LCD_displayCharacter+0x396>
    54e2:	14 c0       	rjmp	.+40     	; 0x550c <LCD_displayCharacter+0x3e6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54e4:	6f 81       	ldd	r22, Y+7	; 0x07
    54e6:	78 85       	ldd	r23, Y+8	; 0x08
    54e8:	89 85       	ldd	r24, Y+9	; 0x09
    54ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    54ec:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    54f0:	dc 01       	movw	r26, r24
    54f2:	cb 01       	movw	r24, r22
    54f4:	9e 83       	std	Y+6, r25	; 0x06
    54f6:	8d 83       	std	Y+5, r24	; 0x05
    54f8:	8d 81       	ldd	r24, Y+5	; 0x05
    54fa:	9e 81       	ldd	r25, Y+6	; 0x06
    54fc:	9a 83       	std	Y+2, r25	; 0x02
    54fe:	89 83       	std	Y+1, r24	; 0x01
    5500:	89 81       	ldd	r24, Y+1	; 0x01
    5502:	9a 81       	ldd	r25, Y+2	; 0x02
    5504:	01 97       	sbiw	r24, 0x01	; 1
    5506:	f1 f7       	brne	.-4      	; 0x5504 <LCD_displayCharacter+0x3de>
    5508:	9a 83       	std	Y+2, r25	; 0x02
    550a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */	
}
    550c:	e9 96       	adiw	r28, 0x39	; 57
    550e:	0f b6       	in	r0, 0x3f	; 63
    5510:	f8 94       	cli
    5512:	de bf       	out	0x3e, r29	; 62
    5514:	0f be       	out	0x3f, r0	; 63
    5516:	cd bf       	out	0x3d, r28	; 61
    5518:	cf 91       	pop	r28
    551a:	df 91       	pop	r29
    551c:	08 95       	ret

0000551e <LCD_displayString>:

void LCD_displayString(const char *Str)
{
    551e:	df 93       	push	r29
    5520:	cf 93       	push	r28
    5522:	00 d0       	rcall	.+0      	; 0x5524 <LCD_displayString+0x6>
    5524:	0f 92       	push	r0
    5526:	cd b7       	in	r28, 0x3d	; 61
    5528:	de b7       	in	r29, 0x3e	; 62
    552a:	9b 83       	std	Y+3, r25	; 0x03
    552c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    552e:	19 82       	std	Y+1, r1	; 0x01
    5530:	0e c0       	rjmp	.+28     	; 0x554e <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    5532:	89 81       	ldd	r24, Y+1	; 0x01
    5534:	28 2f       	mov	r18, r24
    5536:	30 e0       	ldi	r19, 0x00	; 0
    5538:	8a 81       	ldd	r24, Y+2	; 0x02
    553a:	9b 81       	ldd	r25, Y+3	; 0x03
    553c:	fc 01       	movw	r30, r24
    553e:	e2 0f       	add	r30, r18
    5540:	f3 1f       	adc	r31, r19
    5542:	80 81       	ld	r24, Z
    5544:	0e 94 93 28 	call	0x5126	; 0x5126 <LCD_displayCharacter>
		i++;
    5548:	89 81       	ldd	r24, Y+1	; 0x01
    554a:	8f 5f       	subi	r24, 0xFF	; 255
    554c:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    554e:	89 81       	ldd	r24, Y+1	; 0x01
    5550:	28 2f       	mov	r18, r24
    5552:	30 e0       	ldi	r19, 0x00	; 0
    5554:	8a 81       	ldd	r24, Y+2	; 0x02
    5556:	9b 81       	ldd	r25, Y+3	; 0x03
    5558:	fc 01       	movw	r30, r24
    555a:	e2 0f       	add	r30, r18
    555c:	f3 1f       	adc	r31, r19
    555e:	80 81       	ld	r24, Z
    5560:	88 23       	and	r24, r24
    5562:	39 f7       	brne	.-50     	; 0x5532 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	*********************************************************/
}
    5564:	0f 90       	pop	r0
    5566:	0f 90       	pop	r0
    5568:	0f 90       	pop	r0
    556a:	cf 91       	pop	r28
    556c:	df 91       	pop	r29
    556e:	08 95       	ret

00005570 <LCD_goToRowColumn>:

void LCD_goToRowColumn(uint8 row,uint8 col)
{
    5570:	df 93       	push	r29
    5572:	cf 93       	push	r28
    5574:	00 d0       	rcall	.+0      	; 0x5576 <LCD_goToRowColumn+0x6>
    5576:	00 d0       	rcall	.+0      	; 0x5578 <LCD_goToRowColumn+0x8>
    5578:	0f 92       	push	r0
    557a:	cd b7       	in	r28, 0x3d	; 61
    557c:	de b7       	in	r29, 0x3e	; 62
    557e:	8a 83       	std	Y+2, r24	; 0x02
    5580:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;
	
	/* first of all calculate the required address */
	switch(row)
    5582:	8a 81       	ldd	r24, Y+2	; 0x02
    5584:	28 2f       	mov	r18, r24
    5586:	30 e0       	ldi	r19, 0x00	; 0
    5588:	3d 83       	std	Y+5, r19	; 0x05
    558a:	2c 83       	std	Y+4, r18	; 0x04
    558c:	8c 81       	ldd	r24, Y+4	; 0x04
    558e:	9d 81       	ldd	r25, Y+5	; 0x05
    5590:	81 30       	cpi	r24, 0x01	; 1
    5592:	91 05       	cpc	r25, r1
    5594:	c1 f0       	breq	.+48     	; 0x55c6 <LCD_goToRowColumn+0x56>
    5596:	2c 81       	ldd	r18, Y+4	; 0x04
    5598:	3d 81       	ldd	r19, Y+5	; 0x05
    559a:	22 30       	cpi	r18, 0x02	; 2
    559c:	31 05       	cpc	r19, r1
    559e:	2c f4       	brge	.+10     	; 0x55aa <LCD_goToRowColumn+0x3a>
    55a0:	8c 81       	ldd	r24, Y+4	; 0x04
    55a2:	9d 81       	ldd	r25, Y+5	; 0x05
    55a4:	00 97       	sbiw	r24, 0x00	; 0
    55a6:	61 f0       	breq	.+24     	; 0x55c0 <LCD_goToRowColumn+0x50>
    55a8:	19 c0       	rjmp	.+50     	; 0x55dc <LCD_goToRowColumn+0x6c>
    55aa:	2c 81       	ldd	r18, Y+4	; 0x04
    55ac:	3d 81       	ldd	r19, Y+5	; 0x05
    55ae:	22 30       	cpi	r18, 0x02	; 2
    55b0:	31 05       	cpc	r19, r1
    55b2:	69 f0       	breq	.+26     	; 0x55ce <LCD_goToRowColumn+0x5e>
    55b4:	8c 81       	ldd	r24, Y+4	; 0x04
    55b6:	9d 81       	ldd	r25, Y+5	; 0x05
    55b8:	83 30       	cpi	r24, 0x03	; 3
    55ba:	91 05       	cpc	r25, r1
    55bc:	61 f0       	breq	.+24     	; 0x55d6 <LCD_goToRowColumn+0x66>
    55be:	0e c0       	rjmp	.+28     	; 0x55dc <LCD_goToRowColumn+0x6c>
	{
		case 0:
				Address=col;
    55c0:	8b 81       	ldd	r24, Y+3	; 0x03
    55c2:	89 83       	std	Y+1, r24	; 0x01
    55c4:	0b c0       	rjmp	.+22     	; 0x55dc <LCD_goToRowColumn+0x6c>
				break;
		case 1:
				Address=col+0x40;
    55c6:	8b 81       	ldd	r24, Y+3	; 0x03
    55c8:	80 5c       	subi	r24, 0xC0	; 192
    55ca:	89 83       	std	Y+1, r24	; 0x01
    55cc:	07 c0       	rjmp	.+14     	; 0x55dc <LCD_goToRowColumn+0x6c>
				break;
		case 2:
				Address=col+0x10;
    55ce:	8b 81       	ldd	r24, Y+3	; 0x03
    55d0:	80 5f       	subi	r24, 0xF0	; 240
    55d2:	89 83       	std	Y+1, r24	; 0x01
    55d4:	03 c0       	rjmp	.+6      	; 0x55dc <LCD_goToRowColumn+0x6c>
				break;
		case 3:
				Address=col+0x50;
    55d6:	8b 81       	ldd	r24, Y+3	; 0x03
    55d8:	80 5b       	subi	r24, 0xB0	; 176
    55da:	89 83       	std	Y+1, r24	; 0x01
				break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    55dc:	89 81       	ldd	r24, Y+1	; 0x01
    55de:	80 68       	ori	r24, 0x80	; 128
    55e0:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <LCD_sendCommand>
}
    55e4:	0f 90       	pop	r0
    55e6:	0f 90       	pop	r0
    55e8:	0f 90       	pop	r0
    55ea:	0f 90       	pop	r0
    55ec:	0f 90       	pop	r0
    55ee:	cf 91       	pop	r28
    55f0:	df 91       	pop	r29
    55f2:	08 95       	ret

000055f4 <LCD_displayStringRowColumn>:

void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    55f4:	df 93       	push	r29
    55f6:	cf 93       	push	r28
    55f8:	00 d0       	rcall	.+0      	; 0x55fa <LCD_displayStringRowColumn+0x6>
    55fa:	00 d0       	rcall	.+0      	; 0x55fc <LCD_displayStringRowColumn+0x8>
    55fc:	cd b7       	in	r28, 0x3d	; 61
    55fe:	de b7       	in	r29, 0x3e	; 62
    5600:	89 83       	std	Y+1, r24	; 0x01
    5602:	6a 83       	std	Y+2, r22	; 0x02
    5604:	5c 83       	std	Y+4, r21	; 0x04
    5606:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    5608:	89 81       	ldd	r24, Y+1	; 0x01
    560a:	6a 81       	ldd	r22, Y+2	; 0x02
    560c:	0e 94 b8 2a 	call	0x5570	; 0x5570 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    5610:	8b 81       	ldd	r24, Y+3	; 0x03
    5612:	9c 81       	ldd	r25, Y+4	; 0x04
    5614:	0e 94 8f 2a 	call	0x551e	; 0x551e <LCD_displayString>
}
    5618:	0f 90       	pop	r0
    561a:	0f 90       	pop	r0
    561c:	0f 90       	pop	r0
    561e:	0f 90       	pop	r0
    5620:	cf 91       	pop	r28
    5622:	df 91       	pop	r29
    5624:	08 95       	ret

00005626 <LCD_intgerToString>:

void LCD_intgerToString(int data)
{
    5626:	df 93       	push	r29
    5628:	cf 93       	push	r28
    562a:	cd b7       	in	r28, 0x3d	; 61
    562c:	de b7       	in	r29, 0x3e	; 62
    562e:	62 97       	sbiw	r28, 0x12	; 18
    5630:	0f b6       	in	r0, 0x3f	; 63
    5632:	f8 94       	cli
    5634:	de bf       	out	0x3e, r29	; 62
    5636:	0f be       	out	0x3f, r0	; 63
    5638:	cd bf       	out	0x3d, r28	; 61
    563a:	9a 8b       	std	Y+18, r25	; 0x12
    563c:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* 10 for decimal */
    563e:	89 89       	ldd	r24, Y+17	; 0x11
    5640:	9a 89       	ldd	r25, Y+18	; 0x12
    5642:	9e 01       	movw	r18, r28
    5644:	2f 5f       	subi	r18, 0xFF	; 255
    5646:	3f 4f       	sbci	r19, 0xFF	; 255
    5648:	b9 01       	movw	r22, r18
    564a:	4a e0       	ldi	r20, 0x0A	; 10
    564c:	50 e0       	ldi	r21, 0x00	; 0
    564e:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <itoa>
   LCD_displayString(buff);
    5652:	ce 01       	movw	r24, r28
    5654:	01 96       	adiw	r24, 0x01	; 1
    5656:	0e 94 8f 2a 	call	0x551e	; 0x551e <LCD_displayString>
}
    565a:	62 96       	adiw	r28, 0x12	; 18
    565c:	0f b6       	in	r0, 0x3f	; 63
    565e:	f8 94       	cli
    5660:	de bf       	out	0x3e, r29	; 62
    5662:	0f be       	out	0x3f, r0	; 63
    5664:	cd bf       	out	0x3d, r28	; 61
    5666:	cf 91       	pop	r28
    5668:	df 91       	pop	r29
    566a:	08 95       	ret

0000566c <LCD_clearScreen>:

void LCD_clearScreen(void)
{
    566c:	df 93       	push	r29
    566e:	cf 93       	push	r28
    5670:	cd b7       	in	r28, 0x3d	; 61
    5672:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    5674:	81 e0       	ldi	r24, 0x01	; 1
    5676:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <LCD_sendCommand>
}
    567a:	cf 91       	pop	r28
    567c:	df 91       	pop	r29
    567e:	08 95       	ret

00005680 <main>:
/* Control binary semaphore */
SemaphoreHandle_t 		bsControl;


int main(void)
{
    5680:	af 92       	push	r10
    5682:	bf 92       	push	r11
    5684:	cf 92       	push	r12
    5686:	df 92       	push	r13
    5688:	ef 92       	push	r14
    568a:	ff 92       	push	r15
    568c:	0f 93       	push	r16
    568e:	df 93       	push	r29
    5690:	cf 93       	push	r28
    5692:	cd b7       	in	r28, 0x3d	; 61
    5694:	de b7       	in	r29, 0x3e	; 62
	System_init();
    5696:	0e 94 62 2c 	call	0x58c4	; 0x58c4 <System_init>

	bsControl=xSemaphoreCreateBinary();
    569a:	81 e0       	ldi	r24, 0x01	; 1
    569c:	60 e0       	ldi	r22, 0x00	; 0
    569e:	43 e0       	ldi	r20, 0x03	; 3
    56a0:	0e 94 a1 12 	call	0x2542	; 0x2542 <xQueueGenericCreate>
    56a4:	90 93 29 0c 	sts	0x0C29, r25
    56a8:	80 93 28 0c 	sts	0x0C28, r24

	egDisplay = xEventGroupCreate();
    56ac:	0e 94 83 09 	call	0x1306	; 0x1306 <xEventGroupCreate>
    56b0:	90 93 27 0c 	sts	0x0C27, r25
    56b4:	80 93 26 0c 	sts	0x0C26, r24
	egControl = xEventGroupCreate();
    56b8:	0e 94 83 09 	call	0x1306	; 0x1306 <xEventGroupCreate>
    56bc:	90 93 2f 0c 	sts	0x0C2F, r25
    56c0:	80 93 2e 0c 	sts	0x0C2E, r24

	xTaskCreate(T_UserInput, NULL, 200, NULL, 2, NULL);
    56c4:	85 ec       	ldi	r24, 0xC5	; 197
    56c6:	9b e2       	ldi	r25, 0x2B	; 43
    56c8:	60 e0       	ldi	r22, 0x00	; 0
    56ca:	70 e0       	ldi	r23, 0x00	; 0
    56cc:	48 ec       	ldi	r20, 0xC8	; 200
    56ce:	50 e0       	ldi	r21, 0x00	; 0
    56d0:	20 e0       	ldi	r18, 0x00	; 0
    56d2:	30 e0       	ldi	r19, 0x00	; 0
    56d4:	02 e0       	ldi	r16, 0x02	; 2
    56d6:	ee 24       	eor	r14, r14
    56d8:	ff 24       	eor	r15, r15
    56da:	cc 24       	eor	r12, r12
    56dc:	dd 24       	eor	r13, r13
    56de:	aa 24       	eor	r10, r10
    56e0:	bb 24       	eor	r11, r11
    56e2:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>
	xTaskCreate(T_Alarm, NULL, 200, NULL, 5, NULL);
    56e6:	85 ed       	ldi	r24, 0xD5	; 213
    56e8:	9b e2       	ldi	r25, 0x2B	; 43
    56ea:	60 e0       	ldi	r22, 0x00	; 0
    56ec:	70 e0       	ldi	r23, 0x00	; 0
    56ee:	48 ec       	ldi	r20, 0xC8	; 200
    56f0:	50 e0       	ldi	r21, 0x00	; 0
    56f2:	20 e0       	ldi	r18, 0x00	; 0
    56f4:	30 e0       	ldi	r19, 0x00	; 0
    56f6:	05 e0       	ldi	r16, 0x05	; 5
    56f8:	ee 24       	eor	r14, r14
    56fa:	ff 24       	eor	r15, r15
    56fc:	cc 24       	eor	r12, r12
    56fe:	dd 24       	eor	r13, r13
    5700:	aa 24       	eor	r10, r10
    5702:	bb 24       	eor	r11, r11
    5704:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>
	xTaskCreate(T_Control, NULL, 200, NULL, 4, NULL);
    5708:	83 e2       	ldi	r24, 0x23	; 35
    570a:	9c e2       	ldi	r25, 0x2C	; 44
    570c:	60 e0       	ldi	r22, 0x00	; 0
    570e:	70 e0       	ldi	r23, 0x00	; 0
    5710:	48 ec       	ldi	r20, 0xC8	; 200
    5712:	50 e0       	ldi	r21, 0x00	; 0
    5714:	20 e0       	ldi	r18, 0x00	; 0
    5716:	30 e0       	ldi	r19, 0x00	; 0
    5718:	04 e0       	ldi	r16, 0x04	; 4
    571a:	ee 24       	eor	r14, r14
    571c:	ff 24       	eor	r15, r15
    571e:	cc 24       	eor	r12, r12
    5720:	dd 24       	eor	r13, r13
    5722:	aa 24       	eor	r10, r10
    5724:	bb 24       	eor	r11, r11
    5726:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>
	xTaskCreate(T_Uart, NULL, 300, NULL, 3, NULL);
    572a:	8a e3       	ldi	r24, 0x3A	; 58
    572c:	9c e2       	ldi	r25, 0x2C	; 44
    572e:	60 e0       	ldi	r22, 0x00	; 0
    5730:	70 e0       	ldi	r23, 0x00	; 0
    5732:	4c e2       	ldi	r20, 0x2C	; 44
    5734:	51 e0       	ldi	r21, 0x01	; 1
    5736:	20 e0       	ldi	r18, 0x00	; 0
    5738:	30 e0       	ldi	r19, 0x00	; 0
    573a:	03 e0       	ldi	r16, 0x03	; 3
    573c:	ee 24       	eor	r14, r14
    573e:	ff 24       	eor	r15, r15
    5740:	cc 24       	eor	r12, r12
    5742:	dd 24       	eor	r13, r13
    5744:	aa 24       	eor	r10, r10
    5746:	bb 24       	eor	r11, r11
    5748:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>
	xTaskCreate(T_Display, NULL, 400, NULL, 1, NULL);
    574c:	86 e5       	ldi	r24, 0x56	; 86
    574e:	9c e2       	ldi	r25, 0x2C	; 44
    5750:	60 e0       	ldi	r22, 0x00	; 0
    5752:	70 e0       	ldi	r23, 0x00	; 0
    5754:	40 e9       	ldi	r20, 0x90	; 144
    5756:	51 e0       	ldi	r21, 0x01	; 1
    5758:	20 e0       	ldi	r18, 0x00	; 0
    575a:	30 e0       	ldi	r19, 0x00	; 0
    575c:	01 e0       	ldi	r16, 0x01	; 1
    575e:	ee 24       	eor	r14, r14
    5760:	ff 24       	eor	r15, r15
    5762:	cc 24       	eor	r12, r12
    5764:	dd 24       	eor	r13, r13
    5766:	aa 24       	eor	r10, r10
    5768:	bb 24       	eor	r11, r11
    576a:	0e 94 c7 19 	call	0x338e	; 0x338e <xTaskGenericCreate>

	vTaskStartScheduler();
    576e:	0e 94 b6 1b 	call	0x376c	; 0x376c <vTaskStartScheduler>
    5772:	80 e0       	ldi	r24, 0x00	; 0
    5774:	90 e0       	ldi	r25, 0x00	; 0
}
    5776:	cf 91       	pop	r28
    5778:	df 91       	pop	r29
    577a:	0f 91       	pop	r16
    577c:	ff 90       	pop	r15
    577e:	ef 90       	pop	r14
    5780:	df 90       	pop	r13
    5782:	cf 90       	pop	r12
    5784:	bf 90       	pop	r11
    5786:	af 90       	pop	r10
    5788:	08 95       	ret

0000578a <T_UserInput>:
 * Description: 	Checks the driver's input by any of the five speed limiter and cruise
 * 					control buttons.
 *
 */
void T_UserInput(void *pvInitData)
{
    578a:	df 93       	push	r29
    578c:	cf 93       	push	r28
    578e:	00 d0       	rcall	.+0      	; 0x5790 <T_UserInput+0x6>
    5790:	cd b7       	in	r28, 0x3d	; 61
    5792:	de b7       	in	r29, 0x3e	; 62
    5794:	9a 83       	std	Y+2, r25	; 0x02
    5796:	89 83       	std	Y+1, r24	; 0x01
	usart_puts("T_UserInput Started...\r\n");
    5798:	8d e1       	ldi	r24, 0x1D	; 29
    579a:	91 e0       	ldi	r25, 0x01	; 1
    579c:	0e 94 2b 2d 	call	0x5a56	; 0x5a56 <usart_puts>

	while(1)
	{
		/*TODO*/
		vTaskDelay(150);
    57a0:	86 e9       	ldi	r24, 0x96	; 150
    57a2:	90 e0       	ldi	r25, 0x00	; 0
    57a4:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
    57a8:	fb cf       	rjmp	.-10     	; 0x57a0 <T_UserInput+0x16>

000057aa <T_Alarm>:
 * 					(The dangerous case is when the vehicle speed exceeds the speed limit
 * 					 while the driver is not pressing the gas pedal)
 *
 */
void T_Alarm(void *pvInitData)
{
    57aa:	0f 93       	push	r16
    57ac:	1f 93       	push	r17
    57ae:	df 93       	push	r29
    57b0:	cf 93       	push	r28
    57b2:	00 d0       	rcall	.+0      	; 0x57b4 <T_Alarm+0xa>
    57b4:	cd b7       	in	r28, 0x3d	; 61
    57b6:	de b7       	in	r29, 0x3e	; 62
    57b8:	9a 83       	std	Y+2, r25	; 0x02
    57ba:	89 83       	std	Y+1, r24	; 0x01
	usart_puts("T_Alarm Started...\r\n");
    57bc:	86 e3       	ldi	r24, 0x36	; 54
    57be:	91 e0       	ldi	r25, 0x01	; 1
    57c0:	0e 94 2b 2d 	call	0x5a56	; 0x5a56 <usart_puts>
	while(1)
	{
		ebControl = xEventGroupWaitBits(egControl,
    57c4:	80 91 2e 0c 	lds	r24, 0x0C2E
    57c8:	90 91 2f 0c 	lds	r25, 0x0C2F
    57cc:	61 e0       	ldi	r22, 0x01	; 1
    57ce:	70 e0       	ldi	r23, 0x00	; 0
    57d0:	40 e0       	ldi	r20, 0x00	; 0
    57d2:	20 e0       	ldi	r18, 0x00	; 0
    57d4:	0f ef       	ldi	r16, 0xFF	; 255
    57d6:	1f ef       	ldi	r17, 0xFF	; 255
    57d8:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <xEventGroupWaitBits>
    57dc:	90 93 2b 0c 	sts	0x0C2B, r25
    57e0:	80 93 2a 0c 	sts	0x0C2A, r24
				E_ALARM,
				0,
				0,
				portMAX_DELAY);

		if(ebControl & E_ALARM)
    57e4:	80 91 2a 0c 	lds	r24, 0x0C2A
    57e8:	90 91 2b 0c 	lds	r25, 0x0C2B
    57ec:	81 70       	andi	r24, 0x01	; 1
    57ee:	90 70       	andi	r25, 0x00	; 0
    57f0:	88 23       	and	r24, r24
    57f2:	41 f3       	breq	.-48     	; 0x57c4 <T_Alarm+0x1a>
		{
			xEventGroupSetBits(egDisplay, E_ALARM_SCR);
    57f4:	80 91 26 0c 	lds	r24, 0x0C26
    57f8:	90 91 27 0c 	lds	r25, 0x0C27
    57fc:	68 e0       	ldi	r22, 0x08	; 8
    57fe:	70 e0       	ldi	r23, 0x00	; 0
    5800:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <xEventGroupSetBits>

			/* Turn Led ON */
			DIO_VidSetPinValue(0, LED, 0);
    5804:	80 e0       	ldi	r24, 0x00	; 0
    5806:	65 e0       	ldi	r22, 0x05	; 5
    5808:	40 e0       	ldi	r20, 0x00	; 0
    580a:	0e 94 04 24 	call	0x4808	; 0x4808 <DIO_VidSetPinValue>

			if(Param.GasPedal == UNPRESSED)
    580e:	80 91 b2 01 	lds	r24, 0x01B2
    5812:	88 23       	and	r24, r24
    5814:	29 f4       	brne	.+10     	; 0x5820 <T_Alarm+0x76>
			{
				/* Turn Buzzer ON */
				DIO_VidSetPinValue(0, BUZZER, 1);
    5816:	80 e0       	ldi	r24, 0x00	; 0
    5818:	66 e0       	ldi	r22, 0x06	; 6
    581a:	41 e0       	ldi	r20, 0x01	; 1
    581c:	0e 94 04 24 	call	0x4808	; 0x4808 <DIO_VidSetPinValue>
			}

			vTaskDelay(500);
    5820:	84 ef       	ldi	r24, 0xF4	; 244
    5822:	91 e0       	ldi	r25, 0x01	; 1
    5824:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>

			/* Turn OFF Led and Buzzer */
			DIO_VidSetPinValue(0, LED, 1);
    5828:	80 e0       	ldi	r24, 0x00	; 0
    582a:	65 e0       	ldi	r22, 0x05	; 5
    582c:	41 e0       	ldi	r20, 0x01	; 1
    582e:	0e 94 04 24 	call	0x4808	; 0x4808 <DIO_VidSetPinValue>
			DIO_VidSetPinValue(0, BUZZER, 0);
    5832:	80 e0       	ldi	r24, 0x00	; 0
    5834:	66 e0       	ldi	r22, 0x06	; 6
    5836:	40 e0       	ldi	r20, 0x00	; 0
    5838:	0e 94 04 24 	call	0x4808	; 0x4808 <DIO_VidSetPinValue>

			vTaskDelay(500);
    583c:	84 ef       	ldi	r24, 0xF4	; 244
    583e:	91 e0       	ldi	r25, 0x01	; 1
    5840:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
    5844:	bf cf       	rjmp	.-130    	; 0x57c4 <T_Alarm+0x1a>

00005846 <T_Control>:
 * Description:		Determine the control needed when either Speed Limiter or Cruise
 * 					Control are ON, and sends control action over UART.
 *
 */
void T_Control(void *pvInitData)
{
    5846:	df 93       	push	r29
    5848:	cf 93       	push	r28
    584a:	00 d0       	rcall	.+0      	; 0x584c <T_Control+0x6>
    584c:	cd b7       	in	r28, 0x3d	; 61
    584e:	de b7       	in	r29, 0x3e	; 62
    5850:	9a 83       	std	Y+2, r25	; 0x02
    5852:	89 83       	std	Y+1, r24	; 0x01
	usart_puts("T_Check Started...\r\n");
    5854:	8b e4       	ldi	r24, 0x4B	; 75
    5856:	91 e0       	ldi	r25, 0x01	; 1
    5858:	0e 94 2b 2d 	call	0x5a56	; 0x5a56 <usart_puts>

	while(1)
	{
		if(xSemaphoreTake(bsControl, portMAX_DELAY))
    585c:	80 91 28 0c 	lds	r24, 0x0C28
    5860:	90 91 29 0c 	lds	r25, 0x0C29
    5864:	60 e0       	ldi	r22, 0x00	; 0
    5866:	70 e0       	ldi	r23, 0x00	; 0
    5868:	4f ef       	ldi	r20, 0xFF	; 255
    586a:	5f ef       	ldi	r21, 0xFF	; 255
    586c:	20 e0       	ldi	r18, 0x00	; 0
    586e:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <xQueueGenericReceive>
    5872:	f4 cf       	rjmp	.-24     	; 0x585c <T_Control+0x16>

00005874 <T_Uart>:
 *
 * Description:		Receives the vehicle speed, and the press/unpress of gas and brakes.
 *
 */
void T_Uart(void *pvInitData)
{
    5874:	df 93       	push	r29
    5876:	cf 93       	push	r28
    5878:	00 d0       	rcall	.+0      	; 0x587a <T_Uart+0x6>
    587a:	0f 92       	push	r0
    587c:	cd b7       	in	r28, 0x3d	; 61
    587e:	de b7       	in	r29, 0x3e	; 62
    5880:	9b 83       	std	Y+3, r25	; 0x03
    5882:	8a 83       	std	Y+2, r24	; 0x02
	usart_puts("T_Terminal Started...\r\n");
    5884:	80 e6       	ldi	r24, 0x60	; 96
    5886:	91 e0       	ldi	r25, 0x01	; 1
    5888:	0e 94 2b 2d 	call	0x5a56	; 0x5a56 <usart_puts>
	uint8 chr;

	while(1)
	{
		if(!usart_getc_unblock(&chr))
    588c:	ce 01       	movw	r24, r28
    588e:	01 96       	adiw	r24, 0x01	; 1
    5890:	0e 94 f7 2c 	call	0x59ee	; 0x59ee <usart_getc_unblock>
    5894:	88 23       	and	r24, r24
    5896:	29 f4       	brne	.+10     	; 0x58a2 <T_Uart+0x2e>
		{
			vTaskDelay(50);
    5898:	82 e3       	ldi	r24, 0x32	; 50
    589a:	90 e0       	ldi	r25, 0x00	; 0
    589c:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
    58a0:	f5 cf       	rjmp	.-22     	; 0x588c <T_Uart+0x18>
			continue;
		}

		/*TODO*/

		vTaskDelay(50);
    58a2:	82 e3       	ldi	r24, 0x32	; 50
    58a4:	90 e0       	ldi	r25, 0x00	; 0
    58a6:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
    58aa:	f0 cf       	rjmp	.-32     	; 0x588c <T_Uart+0x18>

000058ac <T_Display>:
 *
 * Description:		Displays the speed of the vehicles.
 *
 */
void T_Display(void *pvInitData)
{
    58ac:	df 93       	push	r29
    58ae:	cf 93       	push	r28
    58b0:	00 d0       	rcall	.+0      	; 0x58b2 <T_Display+0x6>
    58b2:	cd b7       	in	r28, 0x3d	; 61
    58b4:	de b7       	in	r29, 0x3e	; 62
    58b6:	9a 83       	std	Y+2, r25	; 0x02
    58b8:	89 83       	std	Y+1, r24	; 0x01
	usart_puts("T_Display Started...\r\n");
    58ba:	88 e7       	ldi	r24, 0x78	; 120
    58bc:	91 e0       	ldi	r25, 0x01	; 1
    58be:	0e 94 2b 2d 	call	0x5a56	; 0x5a56 <usart_puts>
    58c2:	ff cf       	rjmp	.-2      	; 0x58c2 <T_Display+0x16>

000058c4 <System_init>:
 *
 * Description:		Initializes the peripherals and DIO pins needed by the system.
 *
 */
void System_init(void)
{
    58c4:	df 93       	push	r29
    58c6:	cf 93       	push	r28
    58c8:	cd b7       	in	r28, 0x3d	; 61
    58ca:	de b7       	in	r29, 0x3e	; 62
	/* DIOs Initialization */
	/* Five switches to control speed limiter and cruise control */
	DIO_VidSetPinDirection(0, BTN_CC, INPUT);
    58cc:	80 e0       	ldi	r24, 0x00	; 0
    58ce:	60 e0       	ldi	r22, 0x00	; 0
    58d0:	40 e0       	ldi	r20, 0x00	; 0
    58d2:	0e 94 04 23 	call	0x4608	; 0x4608 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(0, BTN_SL, INPUT);
    58d6:	80 e0       	ldi	r24, 0x00	; 0
    58d8:	61 e0       	ldi	r22, 0x01	; 1
    58da:	40 e0       	ldi	r20, 0x00	; 0
    58dc:	0e 94 04 23 	call	0x4608	; 0x4608 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(0, BTN_STANDBY, INPUT);
    58e0:	80 e0       	ldi	r24, 0x00	; 0
    58e2:	62 e0       	ldi	r22, 0x02	; 2
    58e4:	40 e0       	ldi	r20, 0x00	; 0
    58e6:	0e 94 04 23 	call	0x4608	; 0x4608 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(0, BTN_INC, INPUT);
    58ea:	80 e0       	ldi	r24, 0x00	; 0
    58ec:	63 e0       	ldi	r22, 0x03	; 3
    58ee:	40 e0       	ldi	r20, 0x00	; 0
    58f0:	0e 94 04 23 	call	0x4608	; 0x4608 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(0, BTN_DEC, INPUT);
    58f4:	80 e0       	ldi	r24, 0x00	; 0
    58f6:	64 e0       	ldi	r22, 0x04	; 4
    58f8:	40 e0       	ldi	r20, 0x00	; 0
    58fa:	0e 94 04 23 	call	0x4608	; 0x4608 <DIO_VidSetPinDirection>
	/* Outputs */
	DIO_VidSetPinDirection(0, LED, OUTPUT);
    58fe:	80 e0       	ldi	r24, 0x00	; 0
    5900:	65 e0       	ldi	r22, 0x05	; 5
    5902:	41 e0       	ldi	r20, 0x01	; 1
    5904:	0e 94 04 23 	call	0x4608	; 0x4608 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(0, BUZZER, OUTPUT);
    5908:	80 e0       	ldi	r24, 0x00	; 0
    590a:	66 e0       	ldi	r22, 0x06	; 6
    590c:	41 e0       	ldi	r20, 0x01	; 1
    590e:	0e 94 04 23 	call	0x4608	; 0x4608 <DIO_VidSetPinDirection>

	/* UART Initialization */
	usart_init(9600);
    5912:	80 e8       	ldi	r24, 0x80	; 128
    5914:	95 e2       	ldi	r25, 0x25	; 37
    5916:	0e 94 96 2c 	call	0x592c	; 0x592c <usart_init>

	/* LCD Initialization */
	LCD_init();
    591a:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <LCD_init>

	usart_puts("System Started...\r\n");
    591e:	8f e8       	ldi	r24, 0x8F	; 143
    5920:	91 e0       	ldi	r25, 0x01	; 1
    5922:	0e 94 2b 2d 	call	0x5a56	; 0x5a56 <usart_puts>
}
    5926:	cf 91       	pop	r28
    5928:	df 91       	pop	r29
    592a:	08 95       	ret

0000592c <usart_init>:
#include <avr/io.h>
#include "usart_driver.h"

void usart_init(unsigned short int baudrate)
{
    592c:	df 93       	push	r29
    592e:	cf 93       	push	r28
    5930:	00 d0       	rcall	.+0      	; 0x5932 <usart_init+0x6>
    5932:	00 d0       	rcall	.+0      	; 0x5934 <usart_init+0x8>
    5934:	cd b7       	in	r28, 0x3d	; 61
    5936:	de b7       	in	r29, 0x3e	; 62
    5938:	9c 83       	std	Y+4, r25	; 0x04
    593a:	8b 83       	std	Y+3, r24	; 0x03
	//Set baud rate
	unsigned short int UBRRVAL=(FCLK_SYSTEM/(baudrate*16UL))-1;
    593c:	8b 81       	ldd	r24, Y+3	; 0x03
    593e:	9c 81       	ldd	r25, Y+4	; 0x04
    5940:	cc 01       	movw	r24, r24
    5942:	a0 e0       	ldi	r26, 0x00	; 0
    5944:	b0 e0       	ldi	r27, 0x00	; 0
    5946:	88 0f       	add	r24, r24
    5948:	99 1f       	adc	r25, r25
    594a:	aa 1f       	adc	r26, r26
    594c:	bb 1f       	adc	r27, r27
    594e:	88 0f       	add	r24, r24
    5950:	99 1f       	adc	r25, r25
    5952:	aa 1f       	adc	r26, r26
    5954:	bb 1f       	adc	r27, r27
    5956:	88 0f       	add	r24, r24
    5958:	99 1f       	adc	r25, r25
    595a:	aa 1f       	adc	r26, r26
    595c:	bb 1f       	adc	r27, r27
    595e:	88 0f       	add	r24, r24
    5960:	99 1f       	adc	r25, r25
    5962:	aa 1f       	adc	r26, r26
    5964:	bb 1f       	adc	r27, r27
    5966:	9c 01       	movw	r18, r24
    5968:	ad 01       	movw	r20, r26
    596a:	80 e0       	ldi	r24, 0x00	; 0
    596c:	92 e1       	ldi	r25, 0x12	; 18
    596e:	aa e7       	ldi	r26, 0x7A	; 122
    5970:	b0 e0       	ldi	r27, 0x00	; 0
    5972:	bc 01       	movw	r22, r24
    5974:	cd 01       	movw	r24, r26
    5976:	0e 94 75 2d 	call	0x5aea	; 0x5aea <__udivmodsi4>
    597a:	da 01       	movw	r26, r20
    597c:	c9 01       	movw	r24, r18
    597e:	01 97       	sbiw	r24, 0x01	; 1
    5980:	9a 83       	std	Y+2, r25	; 0x02
    5982:	89 83       	std	Y+1, r24	; 0x01
	UBRR0L=UBRRVAL; 			//low byte
    5984:	e9 e2       	ldi	r30, 0x29	; 41
    5986:	f0 e0       	ldi	r31, 0x00	; 0
    5988:	89 81       	ldd	r24, Y+1	; 0x01
    598a:	80 83       	st	Z, r24
	UBRR0H=(UBRRVAL>>8); 	//high byte
    598c:	e0 e9       	ldi	r30, 0x90	; 144
    598e:	f0 e0       	ldi	r31, 0x00	; 0
    5990:	89 81       	ldd	r24, Y+1	; 0x01
    5992:	9a 81       	ldd	r25, Y+2	; 0x02
    5994:	89 2f       	mov	r24, r25
    5996:	99 27       	eor	r25, r25
    5998:	80 83       	st	Z, r24
	//UCSRC=(1<<URSEL)|(0<<UMSEL)|(0<<UPM1)|(0<<UPM0)|(0<<USBS)|(0<<UCSZ2)|(1<<UCSZ1)|(1<<UCSZ0);

	//Enable Transmitter and Receiver
	//UCSRB=(1<<RXEN)|(1<<TXEN);

	UCSR0B= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
    599a:	ea e2       	ldi	r30, 0x2A	; 42
    599c:	f0 e0       	ldi	r31, 0x00	; 0
    599e:	88 e1       	ldi	r24, 0x18	; 24
    59a0:	80 83       	st	Z, r24
	UCSR0C= (1<<UCSZ1) | (1<<UCSZ0);                // Asynchronous mode 8-bit data and 1-stop bit
    59a2:	e5 e9       	ldi	r30, 0x95	; 149
    59a4:	f0 e0       	ldi	r31, 0x00	; 0
    59a6:	86 e0       	ldi	r24, 0x06	; 6
    59a8:	80 83       	st	Z, r24
	UCSR0A= 0x00;
    59aa:	eb e2       	ldi	r30, 0x2B	; 43
    59ac:	f0 e0       	ldi	r31, 0x00	; 0
    59ae:	10 82       	st	Z, r1
}
    59b0:	0f 90       	pop	r0
    59b2:	0f 90       	pop	r0
    59b4:	0f 90       	pop	r0
    59b6:	0f 90       	pop	r0
    59b8:	cf 91       	pop	r28
    59ba:	df 91       	pop	r29
    59bc:	08 95       	ret

000059be <usart_getc>:
unsigned char usart_getc( uint8_t * data )
{
    59be:	df 93       	push	r29
    59c0:	cf 93       	push	r28
    59c2:	00 d0       	rcall	.+0      	; 0x59c4 <usart_getc+0x6>
    59c4:	cd b7       	in	r28, 0x3d	; 61
    59c6:	de b7       	in	r29, 0x3e	; 62
    59c8:	9a 83       	std	Y+2, r25	; 0x02
    59ca:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
	while(!(UCSR0A&(1<<RXC)));  // Wait till the data is received
    59cc:	eb e2       	ldi	r30, 0x2B	; 43
    59ce:	f0 e0       	ldi	r31, 0x00	; 0
    59d0:	80 81       	ld	r24, Z
    59d2:	88 23       	and	r24, r24
    59d4:	dc f7       	brge	.-10     	; 0x59cc <usart_getc+0xe>
	*data = UDR0;
    59d6:	ec e2       	ldi	r30, 0x2C	; 44
    59d8:	f0 e0       	ldi	r31, 0x00	; 0
    59da:	80 81       	ld	r24, Z
    59dc:	e9 81       	ldd	r30, Y+1	; 0x01
    59de:	fa 81       	ldd	r31, Y+2	; 0x02
    59e0:	80 83       	st	Z, r24
	return 1;
    59e2:	81 e0       	ldi	r24, 0x01	; 1
}
    59e4:	0f 90       	pop	r0
    59e6:	0f 90       	pop	r0
    59e8:	cf 91       	pop	r28
    59ea:	df 91       	pop	r29
    59ec:	08 95       	ret

000059ee <usart_getc_unblock>:

unsigned char usart_getc_unblock( uint8_t * data )
{
    59ee:	df 93       	push	r29
    59f0:	cf 93       	push	r28
    59f2:	00 d0       	rcall	.+0      	; 0x59f4 <usart_getc_unblock+0x6>
    59f4:	0f 92       	push	r0
    59f6:	cd b7       	in	r28, 0x3d	; 61
    59f8:	de b7       	in	r29, 0x3e	; 62
    59fa:	9b 83       	std	Y+3, r25	; 0x03
    59fc:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t status=0;
    59fe:	19 82       	std	Y+1, r1	; 0x01
	/* Wait for data to be received */
	if(UCSR0A & (1<<RXC))
    5a00:	eb e2       	ldi	r30, 0x2B	; 43
    5a02:	f0 e0       	ldi	r31, 0x00	; 0
    5a04:	80 81       	ld	r24, Z
    5a06:	88 23       	and	r24, r24
    5a08:	44 f4       	brge	.+16     	; 0x5a1a <usart_getc_unblock+0x2c>
	{
	/* Get and return received data from buffer */
	*data = UDR0;
    5a0a:	ec e2       	ldi	r30, 0x2C	; 44
    5a0c:	f0 e0       	ldi	r31, 0x00	; 0
    5a0e:	80 81       	ld	r24, Z
    5a10:	ea 81       	ldd	r30, Y+2	; 0x02
    5a12:	fb 81       	ldd	r31, Y+3	; 0x03
    5a14:	80 83       	st	Z, r24
	status =1;
    5a16:	81 e0       	ldi	r24, 0x01	; 1
    5a18:	89 83       	std	Y+1, r24	; 0x01
	}
	return status;
    5a1a:	89 81       	ldd	r24, Y+1	; 0x01
}
    5a1c:	0f 90       	pop	r0
    5a1e:	0f 90       	pop	r0
    5a20:	0f 90       	pop	r0
    5a22:	cf 91       	pop	r28
    5a24:	df 91       	pop	r29
    5a26:	08 95       	ret

00005a28 <usart_putc>:

void usart_putc( unsigned char data )
{
    5a28:	df 93       	push	r29
    5a2a:	cf 93       	push	r28
    5a2c:	0f 92       	push	r0
    5a2e:	cd b7       	in	r28, 0x3d	; 61
    5a30:	de b7       	in	r29, 0x3e	; 62
    5a32:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE)));
    5a34:	eb e2       	ldi	r30, 0x2B	; 43
    5a36:	f0 e0       	ldi	r31, 0x00	; 0
    5a38:	80 81       	ld	r24, Z
    5a3a:	88 2f       	mov	r24, r24
    5a3c:	90 e0       	ldi	r25, 0x00	; 0
    5a3e:	80 72       	andi	r24, 0x20	; 32
    5a40:	90 70       	andi	r25, 0x00	; 0
    5a42:	00 97       	sbiw	r24, 0x00	; 0
    5a44:	b9 f3       	breq	.-18     	; 0x5a34 <usart_putc+0xc>
	/* Put data into buffer, sends the data */
	UDR0 = data;
    5a46:	ec e2       	ldi	r30, 0x2C	; 44
    5a48:	f0 e0       	ldi	r31, 0x00	; 0
    5a4a:	89 81       	ldd	r24, Y+1	; 0x01
    5a4c:	80 83       	st	Z, r24
}
    5a4e:	0f 90       	pop	r0
    5a50:	cf 91       	pop	r28
    5a52:	df 91       	pop	r29
    5a54:	08 95       	ret

00005a56 <usart_puts>:
void usart_puts( char* str )
{
    5a56:	df 93       	push	r29
    5a58:	cf 93       	push	r28
    5a5a:	00 d0       	rcall	.+0      	; 0x5a5c <usart_puts+0x6>
    5a5c:	00 d0       	rcall	.+0      	; 0x5a5e <usart_puts+0x8>
    5a5e:	cd b7       	in	r28, 0x3d	; 61
    5a60:	de b7       	in	r29, 0x3e	; 62
    5a62:	9c 83       	std	Y+4, r25	; 0x04
    5a64:	8b 83       	std	Y+3, r24	; 0x03
	short int i=0;
    5a66:	1a 82       	std	Y+2, r1	; 0x02
    5a68:	19 82       	std	Y+1, r1	; 0x01
    5a6a:	0f c0       	rjmp	.+30     	; 0x5a8a <usart_puts+0x34>
	while(str[i])
	{
		usart_putc(str[i]);
    5a6c:	29 81       	ldd	r18, Y+1	; 0x01
    5a6e:	3a 81       	ldd	r19, Y+2	; 0x02
    5a70:	8b 81       	ldd	r24, Y+3	; 0x03
    5a72:	9c 81       	ldd	r25, Y+4	; 0x04
    5a74:	fc 01       	movw	r30, r24
    5a76:	e2 0f       	add	r30, r18
    5a78:	f3 1f       	adc	r31, r19
    5a7a:	80 81       	ld	r24, Z
    5a7c:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <usart_putc>
		i++;
    5a80:	89 81       	ldd	r24, Y+1	; 0x01
    5a82:	9a 81       	ldd	r25, Y+2	; 0x02
    5a84:	01 96       	adiw	r24, 0x01	; 1
    5a86:	9a 83       	std	Y+2, r25	; 0x02
    5a88:	89 83       	std	Y+1, r24	; 0x01
	UDR0 = data;
}
void usart_puts( char* str )
{
	short int i=0;
	while(str[i])
    5a8a:	29 81       	ldd	r18, Y+1	; 0x01
    5a8c:	3a 81       	ldd	r19, Y+2	; 0x02
    5a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a90:	9c 81       	ldd	r25, Y+4	; 0x04
    5a92:	fc 01       	movw	r30, r24
    5a94:	e2 0f       	add	r30, r18
    5a96:	f3 1f       	adc	r31, r19
    5a98:	80 81       	ld	r24, Z
    5a9a:	88 23       	and	r24, r24
    5a9c:	39 f7       	brne	.-50     	; 0x5a6c <usart_puts+0x16>
	{
		usart_putc(str[i]);
		i++;
	}
}
    5a9e:	0f 90       	pop	r0
    5aa0:	0f 90       	pop	r0
    5aa2:	0f 90       	pop	r0
    5aa4:	0f 90       	pop	r0
    5aa6:	cf 91       	pop	r28
    5aa8:	df 91       	pop	r29
    5aaa:	08 95       	ret

00005aac <__mulsi3>:
    5aac:	62 9f       	mul	r22, r18
    5aae:	d0 01       	movw	r26, r0
    5ab0:	73 9f       	mul	r23, r19
    5ab2:	f0 01       	movw	r30, r0
    5ab4:	82 9f       	mul	r24, r18
    5ab6:	e0 0d       	add	r30, r0
    5ab8:	f1 1d       	adc	r31, r1
    5aba:	64 9f       	mul	r22, r20
    5abc:	e0 0d       	add	r30, r0
    5abe:	f1 1d       	adc	r31, r1
    5ac0:	92 9f       	mul	r25, r18
    5ac2:	f0 0d       	add	r31, r0
    5ac4:	83 9f       	mul	r24, r19
    5ac6:	f0 0d       	add	r31, r0
    5ac8:	74 9f       	mul	r23, r20
    5aca:	f0 0d       	add	r31, r0
    5acc:	65 9f       	mul	r22, r21
    5ace:	f0 0d       	add	r31, r0
    5ad0:	99 27       	eor	r25, r25
    5ad2:	72 9f       	mul	r23, r18
    5ad4:	b0 0d       	add	r27, r0
    5ad6:	e1 1d       	adc	r30, r1
    5ad8:	f9 1f       	adc	r31, r25
    5ada:	63 9f       	mul	r22, r19
    5adc:	b0 0d       	add	r27, r0
    5ade:	e1 1d       	adc	r30, r1
    5ae0:	f9 1f       	adc	r31, r25
    5ae2:	bd 01       	movw	r22, r26
    5ae4:	cf 01       	movw	r24, r30
    5ae6:	11 24       	eor	r1, r1
    5ae8:	08 95       	ret

00005aea <__udivmodsi4>:
    5aea:	a1 e2       	ldi	r26, 0x21	; 33
    5aec:	1a 2e       	mov	r1, r26
    5aee:	aa 1b       	sub	r26, r26
    5af0:	bb 1b       	sub	r27, r27
    5af2:	fd 01       	movw	r30, r26
    5af4:	0d c0       	rjmp	.+26     	; 0x5b10 <__udivmodsi4_ep>

00005af6 <__udivmodsi4_loop>:
    5af6:	aa 1f       	adc	r26, r26
    5af8:	bb 1f       	adc	r27, r27
    5afa:	ee 1f       	adc	r30, r30
    5afc:	ff 1f       	adc	r31, r31
    5afe:	a2 17       	cp	r26, r18
    5b00:	b3 07       	cpc	r27, r19
    5b02:	e4 07       	cpc	r30, r20
    5b04:	f5 07       	cpc	r31, r21
    5b06:	20 f0       	brcs	.+8      	; 0x5b10 <__udivmodsi4_ep>
    5b08:	a2 1b       	sub	r26, r18
    5b0a:	b3 0b       	sbc	r27, r19
    5b0c:	e4 0b       	sbc	r30, r20
    5b0e:	f5 0b       	sbc	r31, r21

00005b10 <__udivmodsi4_ep>:
    5b10:	66 1f       	adc	r22, r22
    5b12:	77 1f       	adc	r23, r23
    5b14:	88 1f       	adc	r24, r24
    5b16:	99 1f       	adc	r25, r25
    5b18:	1a 94       	dec	r1
    5b1a:	69 f7       	brne	.-38     	; 0x5af6 <__udivmodsi4_loop>
    5b1c:	60 95       	com	r22
    5b1e:	70 95       	com	r23
    5b20:	80 95       	com	r24
    5b22:	90 95       	com	r25
    5b24:	9b 01       	movw	r18, r22
    5b26:	ac 01       	movw	r20, r24
    5b28:	bd 01       	movw	r22, r26
    5b2a:	cf 01       	movw	r24, r30
    5b2c:	08 95       	ret

00005b2e <__divmodsi4>:
    5b2e:	97 fb       	bst	r25, 7
    5b30:	09 2e       	mov	r0, r25
    5b32:	05 26       	eor	r0, r21
    5b34:	0e d0       	rcall	.+28     	; 0x5b52 <__divmodsi4_neg1>
    5b36:	57 fd       	sbrc	r21, 7
    5b38:	04 d0       	rcall	.+8      	; 0x5b42 <__divmodsi4_neg2>
    5b3a:	d7 df       	rcall	.-82     	; 0x5aea <__udivmodsi4>
    5b3c:	0a d0       	rcall	.+20     	; 0x5b52 <__divmodsi4_neg1>
    5b3e:	00 1c       	adc	r0, r0
    5b40:	38 f4       	brcc	.+14     	; 0x5b50 <__divmodsi4_exit>

00005b42 <__divmodsi4_neg2>:
    5b42:	50 95       	com	r21
    5b44:	40 95       	com	r20
    5b46:	30 95       	com	r19
    5b48:	21 95       	neg	r18
    5b4a:	3f 4f       	sbci	r19, 0xFF	; 255
    5b4c:	4f 4f       	sbci	r20, 0xFF	; 255
    5b4e:	5f 4f       	sbci	r21, 0xFF	; 255

00005b50 <__divmodsi4_exit>:
    5b50:	08 95       	ret

00005b52 <__divmodsi4_neg1>:
    5b52:	f6 f7       	brtc	.-4      	; 0x5b50 <__divmodsi4_exit>
    5b54:	90 95       	com	r25
    5b56:	80 95       	com	r24
    5b58:	70 95       	com	r23
    5b5a:	61 95       	neg	r22
    5b5c:	7f 4f       	sbci	r23, 0xFF	; 255
    5b5e:	8f 4f       	sbci	r24, 0xFF	; 255
    5b60:	9f 4f       	sbci	r25, 0xFF	; 255
    5b62:	08 95       	ret

00005b64 <__prologue_saves__>:
    5b64:	2f 92       	push	r2
    5b66:	3f 92       	push	r3
    5b68:	4f 92       	push	r4
    5b6a:	5f 92       	push	r5
    5b6c:	6f 92       	push	r6
    5b6e:	7f 92       	push	r7
    5b70:	8f 92       	push	r8
    5b72:	9f 92       	push	r9
    5b74:	af 92       	push	r10
    5b76:	bf 92       	push	r11
    5b78:	cf 92       	push	r12
    5b7a:	df 92       	push	r13
    5b7c:	ef 92       	push	r14
    5b7e:	ff 92       	push	r15
    5b80:	0f 93       	push	r16
    5b82:	1f 93       	push	r17
    5b84:	cf 93       	push	r28
    5b86:	df 93       	push	r29
    5b88:	cd b7       	in	r28, 0x3d	; 61
    5b8a:	de b7       	in	r29, 0x3e	; 62
    5b8c:	ca 1b       	sub	r28, r26
    5b8e:	db 0b       	sbc	r29, r27
    5b90:	0f b6       	in	r0, 0x3f	; 63
    5b92:	f8 94       	cli
    5b94:	de bf       	out	0x3e, r29	; 62
    5b96:	0f be       	out	0x3f, r0	; 63
    5b98:	cd bf       	out	0x3d, r28	; 61
    5b9a:	09 94       	ijmp

00005b9c <__epilogue_restores__>:
    5b9c:	2a 88       	ldd	r2, Y+18	; 0x12
    5b9e:	39 88       	ldd	r3, Y+17	; 0x11
    5ba0:	48 88       	ldd	r4, Y+16	; 0x10
    5ba2:	5f 84       	ldd	r5, Y+15	; 0x0f
    5ba4:	6e 84       	ldd	r6, Y+14	; 0x0e
    5ba6:	7d 84       	ldd	r7, Y+13	; 0x0d
    5ba8:	8c 84       	ldd	r8, Y+12	; 0x0c
    5baa:	9b 84       	ldd	r9, Y+11	; 0x0b
    5bac:	aa 84       	ldd	r10, Y+10	; 0x0a
    5bae:	b9 84       	ldd	r11, Y+9	; 0x09
    5bb0:	c8 84       	ldd	r12, Y+8	; 0x08
    5bb2:	df 80       	ldd	r13, Y+7	; 0x07
    5bb4:	ee 80       	ldd	r14, Y+6	; 0x06
    5bb6:	fd 80       	ldd	r15, Y+5	; 0x05
    5bb8:	0c 81       	ldd	r16, Y+4	; 0x04
    5bba:	1b 81       	ldd	r17, Y+3	; 0x03
    5bbc:	aa 81       	ldd	r26, Y+2	; 0x02
    5bbe:	b9 81       	ldd	r27, Y+1	; 0x01
    5bc0:	ce 0f       	add	r28, r30
    5bc2:	d1 1d       	adc	r29, r1
    5bc4:	0f b6       	in	r0, 0x3f	; 63
    5bc6:	f8 94       	cli
    5bc8:	de bf       	out	0x3e, r29	; 62
    5bca:	0f be       	out	0x3f, r0	; 63
    5bcc:	cd bf       	out	0x3d, r28	; 61
    5bce:	ed 01       	movw	r28, r26
    5bd0:	08 95       	ret

00005bd2 <memcpy>:
    5bd2:	fb 01       	movw	r30, r22
    5bd4:	dc 01       	movw	r26, r24
    5bd6:	02 c0       	rjmp	.+4      	; 0x5bdc <memcpy+0xa>
    5bd8:	01 90       	ld	r0, Z+
    5bda:	0d 92       	st	X+, r0
    5bdc:	41 50       	subi	r20, 0x01	; 1
    5bde:	50 40       	sbci	r21, 0x00	; 0
    5be0:	d8 f7       	brcc	.-10     	; 0x5bd8 <memcpy+0x6>
    5be2:	08 95       	ret

00005be4 <itoa>:
    5be4:	fb 01       	movw	r30, r22
    5be6:	9f 01       	movw	r18, r30
    5be8:	e8 94       	clt
    5bea:	42 30       	cpi	r20, 0x02	; 2
    5bec:	c4 f0       	brlt	.+48     	; 0x5c1e <itoa+0x3a>
    5bee:	45 32       	cpi	r20, 0x25	; 37
    5bf0:	b4 f4       	brge	.+44     	; 0x5c1e <itoa+0x3a>
    5bf2:	4a 30       	cpi	r20, 0x0A	; 10
    5bf4:	29 f4       	brne	.+10     	; 0x5c00 <itoa+0x1c>
    5bf6:	97 fb       	bst	r25, 7
    5bf8:	1e f4       	brtc	.+6      	; 0x5c00 <itoa+0x1c>
    5bfa:	90 95       	com	r25
    5bfc:	81 95       	neg	r24
    5bfe:	9f 4f       	sbci	r25, 0xFF	; 255
    5c00:	64 2f       	mov	r22, r20
    5c02:	77 27       	eor	r23, r23
    5c04:	0e 94 23 2e 	call	0x5c46	; 0x5c46 <__udivmodhi4>
    5c08:	80 5d       	subi	r24, 0xD0	; 208
    5c0a:	8a 33       	cpi	r24, 0x3A	; 58
    5c0c:	0c f0       	brlt	.+2      	; 0x5c10 <itoa+0x2c>
    5c0e:	89 5d       	subi	r24, 0xD9	; 217
    5c10:	81 93       	st	Z+, r24
    5c12:	cb 01       	movw	r24, r22
    5c14:	00 97       	sbiw	r24, 0x00	; 0
    5c16:	a1 f7       	brne	.-24     	; 0x5c00 <itoa+0x1c>
    5c18:	16 f4       	brtc	.+4      	; 0x5c1e <itoa+0x3a>
    5c1a:	5d e2       	ldi	r21, 0x2D	; 45
    5c1c:	51 93       	st	Z+, r21
    5c1e:	10 82       	st	Z, r1
    5c20:	c9 01       	movw	r24, r18
    5c22:	0c 94 13 2e 	jmp	0x5c26	; 0x5c26 <strrev>

00005c26 <strrev>:
    5c26:	dc 01       	movw	r26, r24
    5c28:	fc 01       	movw	r30, r24
    5c2a:	67 2f       	mov	r22, r23
    5c2c:	71 91       	ld	r23, Z+
    5c2e:	77 23       	and	r23, r23
    5c30:	e1 f7       	brne	.-8      	; 0x5c2a <strrev+0x4>
    5c32:	32 97       	sbiw	r30, 0x02	; 2
    5c34:	04 c0       	rjmp	.+8      	; 0x5c3e <strrev+0x18>
    5c36:	7c 91       	ld	r23, X
    5c38:	6d 93       	st	X+, r22
    5c3a:	70 83       	st	Z, r23
    5c3c:	62 91       	ld	r22, -Z
    5c3e:	ae 17       	cp	r26, r30
    5c40:	bf 07       	cpc	r27, r31
    5c42:	c8 f3       	brcs	.-14     	; 0x5c36 <strrev+0x10>
    5c44:	08 95       	ret

00005c46 <__udivmodhi4>:
    5c46:	aa 1b       	sub	r26, r26
    5c48:	bb 1b       	sub	r27, r27
    5c4a:	51 e1       	ldi	r21, 0x11	; 17
    5c4c:	07 c0       	rjmp	.+14     	; 0x5c5c <__udivmodhi4_ep>

00005c4e <__udivmodhi4_loop>:
    5c4e:	aa 1f       	adc	r26, r26
    5c50:	bb 1f       	adc	r27, r27
    5c52:	a6 17       	cp	r26, r22
    5c54:	b7 07       	cpc	r27, r23
    5c56:	10 f0       	brcs	.+4      	; 0x5c5c <__udivmodhi4_ep>
    5c58:	a6 1b       	sub	r26, r22
    5c5a:	b7 0b       	sbc	r27, r23

00005c5c <__udivmodhi4_ep>:
    5c5c:	88 1f       	adc	r24, r24
    5c5e:	99 1f       	adc	r25, r25
    5c60:	5a 95       	dec	r21
    5c62:	a9 f7       	brne	.-22     	; 0x5c4e <__udivmodhi4_loop>
    5c64:	80 95       	com	r24
    5c66:	90 95       	com	r25
    5c68:	bc 01       	movw	r22, r24
    5c6a:	cd 01       	movw	r24, r26
    5c6c:	08 95       	ret

00005c6e <_exit>:
    5c6e:	f8 94       	cli

00005c70 <__stop_program>:
    5c70:	ff cf       	rjmp	.-2      	; 0x5c70 <__stop_program>
